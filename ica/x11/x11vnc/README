
x11vnc README file                         Date: Tue Jun 27 23:31:08 EDT 2006

The following information is taken from these URLs:

	http://www.karlrunge.com/x11vnc/index.html
	http://www.karlrunge.com/x11vnc/x11vnc_opts.html
	...

they contain the most up to date info.

	
=======================================================================
http://www.karlrunge.com/x11vnc/index.html:


     _________________________________________________________________

x11vnc: a VNC server for real X displays
                (to [1]FAQ)    (to [2]Downloads)    (to [3]Building)    (to
[4]Beta Test)    (to [5]Donations) [6][PayPal] 

   x11vnc allows one to view remotely and interact with real X displays
   (i.e. a display corresponding to a physical monitor, keyboard, and
   mouse) with any VNC viewer. In this way it plays the role for Unix/X11
   that WinVNC plays for Windows.

   It has built-in [7]SSL encryption and authentication, UNIX [8]account
   and password support, server-side [9]scaling, [10]single port HTTPS
   and VNC, and TightVNC and UltraVNC [11]file-transfer. It has also been
   extended to work with [12]webcams and TV tuner capture devices.

   I wrote x11vnc back in 2002 because x0rfbserver was basically
   impossible to build on Solaris and had poor performance. The primary
   x0rfbserver build problems centered around esoteric C++ toolkits.
   x11vnc is written in plain C and uses only standard libraries. I also
   added a some enhancements to improve the interactive response, add
   esoteric features, etc.

   This page and the [13]FAQ contain a lot of information [14][*] and
   solutions to many problems and interesting applications, but
   nevertheless please feel free to [15]contact me if you have problems
   or questions.

    Background:

   VNC (Virtual Network Computing) is a very useful network graphics
   protocol (applications running on one computer but displaying their
   windows on another) in the spirit of X, however, unlike X, the
   viewing-end is very simple and maintains no state. It is a remote
   framebuffer (RFB) protocol

   Some VNC links:
     * [16]http://www.realvnc.com
     * [17]http://www.tightvnc.com
     * [18]http://www.ultravnc.com/
     * [19]http://www.redstonesoftware.com/

   For Unix, the traditional VNC implementation includes a virtual X11
   server Xvnc (usually launched via the vncserver command) that is not
   associated with a physical display, but provides a "fake" one X11
   clients (xterm, mozilla, etc.) can attach to. A remote user then
   connects to Xvnc via the VNC client vncviewer from anywhere on the
   network to view and interact with the whole virtual X11 desktop.

   The VNC protocol is in most cases better suited for remote connections
   with low bandwidth and high latency than is the X11 protocol (the
   exception is cached pixmap data on the viewing-end). Also, with no
   state maintained the viewing-end can crash, be rebooted, or relocated
   and the applications and desktop continue running. Not so with X11.

   So the standard Xvnc/vncserver program is very useful, I use it for
   things like:
     * Desktop conferencing with other users (e.g. codereviews).
     * Long running apps/tasks I want to be able to view from many
       places.
     * Motif, GNOME, and similar applications that would yield very poor
       performance over a high latency link.

   However, sometimes one wants to connect to a real X11 display (i.e.
   one attached to a physical monitor, keyboard, and mouse: a Workstation
   or a SunRay session) from far away. Maybe you want to close down an
   application cleanly rather than using kill, or want to work a bit in
   an already running application, or would like to help a distant
   colleague solve a problem with their desktop, or would just like to
   work out on your deck for a while. This is where x11vnc is useful.
     _________________________________________________________________

    How to use x11vnc:

   In this basic example let's assume the remote machine with the X
   display you wish to view is "far-away.east:0" and the workstation you
   are presently working at is "sitting-here.west".

   Step 0. Download x11vnc ([20]see below) and have it available to run
   on far-away.east. Similarly, have a VNC viewer (e.g. vncviewer) ready
   to run on sitting-here.west. We recommend [21]TightVNC Viewers.

   Step 1. By some means log in to far-away.east and get a command shell
   running there. You can use ssh, rlogin, telnet, or any other method to
   do this. The x11vnc process needs to be run on the same machine the X
   server process is running on (otherwise things would be extremely
   slow).

   Step 2. In that far-away.east shell (with command prompt "far-away>"
   in this example) run x11vnc directed at the far-away.east X session
   display:

  far-away> x11vnc -display :0

   You could have also set the environment variable DISPLAY=:0 instead of
   using -display. This step attaches x11vnc to the far-away.east:0 X
   display (i.e. no viewer clients yet).

   Common Gotcha: To get X11 permissions right, you may also need to set
   the XAUTHORITY environment variable (or use the [22]-auth option) to
   point to the correct MIT-MAGIC-COOKIE file (e.g.
   /home/joe/.Xauthority). If x11vnc does not have the authority to
   connect to the display it exits immediately. More on how to fix this
   [23]below.

   If you suspect an X11 permissions problem do this simple test: while
   sitting at the physical X display open a terminal window
   (gnome-terminal, xterm, etc). You should be able to run x11vnc
   successfully in that terminal without any need for command line
   options. If that works OK then you know X11 permissions are the only
   thing preventing it from working when you try to start x11vnc via a
   remote shell. Then fix this with the tips [24]below.

   When x11vnc starts up there will then be much chatter printed out,
   until it finally says something like:
  .
  .
  13/05/2004 14:59:54 Autoprobing selected port 5900
  13/05/2004 14:59:54 screen setup finished.
  13/05/2004 14:59:54
  13/05/2004 14:59:54 The VNC desktop is far-away:0
  PORT=5900

   which means all is OK, and we are ready for the final step.

   Step 3. At the place where you are sitting (sitting-here.west in this
   example) you now want to run a VNC viewer program. There are VNC
   viewers for Unix, Windows, MacOS, Java-enabled web browsers, and even
   for PDA's like the Palm Pilot! You can use any of them to connect to
   x11vnc (see the above VNC links under "Background:" on how to obtain a
   viewer for your platform or see [25]this FAQ. For Solaris, vncviewer
   is available in the [26]Companion CD package SFWvnc).

   In this example we'll use the Unix vncviewer program on sitting-here
   by typing the following command in a second terminal window:

  sitting-here> vncviewer far-away.east:0

   That should pop up a viewer window on sitting-here.west showing and
   allowing interaction with the far-away.east:0  X11 desktop. Pretty
   nifty! When finished, exit the viewer: the remote x11vnc process will
   shutdown automatically (or you can use the [27]-forever option to have
   it wait for additional viewer connections).

   Shortcut: Of course if you left x11vnc running on far-away.east:0 in a
   terminal window with the [28]-forever option or as a [29]service,
   you'd only have to do Step 3 as you moved around. Be sure to use a VNC
   [30]Password or [31]other measures if you do that.


   Desktop Sharing: The above more or less assumed nobody was sitting at
   the workstation display "far-away.east:0". This is often the case: a
   user wants to access her workstation remotely. Another usage pattern
   has the user sitting at "far-away.east:0" and invites one or more
   other people to view and interact with his desktop. Perhaps the user
   gives a demo or presentation this way (using the telephone for vocal
   communication). A "Remote Help Desk" mode would be similar: a
   technician remotely connects to the user's desktop to interactively
   solve a problem the user is having.

   For these cases it should be obvious how it is done. The above steps
   will work, but more easily the user sitting at far-away.east:0 simply
   starts up x11vnc from a terminal window, after which the guests would
   start their VNC viewers. For this usage mode the "[32]-connect
   host1,host2" option may be of use automatically connect to vncviewers
   in "-listen" mode on the list of hosts.
     _________________________________________________________________

    Tunnelling x11vnc via ssh:

   The above example had no security or privacy at all. When logging into
   remote machines (certainly when going over the internet) it is best to
   use ssh, or use a VPN. For x11vnc one can tunnel the VNC protocol
   through the encrypted ssh channel. It would look something like this:
  sitting-here> ssh -L 5900:localhost:5900 far-away.east 'x11vnc -localhost -di
splay :0'

   (you will likely have to provide passwords/passphrases for the ssh
   login) and then in another terminal window on sitting-here run the
   command:
  sitting-here> vncviewer -encodings "copyrect tight zrle hextile" localhost:0

   Note: The -encodings option is very important: vncviewer will often
   default to "raw" encoding if it thinks the connection is to the local
   machine, and so vncviewer gets tricked this way by the ssh
   redirection. "raw" encoding will be extremely slow over a networked
   link, so you need to force the issue with -encodings "copyrect tight
   ...".

   Note that "x11vnc -localhost ..." limits incoming vncviewer
   connections to only those from the same machine. This is very natural
   for ssh tunnelling (the redirection appears to come from the same
   machine). Use of a [33]VNC password is also strongly recommended.

   Some VNC viewers will do the ssh tunnelling for you automatically, the
   TightVNC vncviewer does this when the "-via far-away.east" option is
   supplied to it (this requires x11vnc to be already running on
   far-away.east or having it started by [34]inetd(8)). See the 3rd
   script example [35]below for more info.

   If the machine you SSH into is not the same machine with the X display
   you wish to view (e.g. your company provides incoming SSH access to a
   gateway machine), then you need to change the above to, e.g.: "-L
   5900:OtherHOST:5900". Once logged in, you'll need to do a second login
   (ssh, rsh, etc.) to the workstation machine 'otherhost' and then start
   up x11vnc on it (if it isn't already running). For an automatic way to
   use a gateway and have all the network traffic encrypted (including
   inside the firewall) see [36]chaining ssh's

     _________________________________________________________________

   Scripts to automate ssh tunneling: As discussed below, there may be
   some problems with port 5900 being available. If that happens, the
   above port and display numbers may change a bit (e.g. -> 5901 and :1).
   However, if you "know" port 5900 will be free on the local and remote
   machines, you can easily automate the above two steps by using the
   x11vnc option [37]-bg (forks into background after connection to the
   display is set up) or using the -f option of ssh. Some example scripts
   are shown below.
     _________________________________________________________________

   #1. A simple example script, assuming no problems with port 5900 being
   taken on the local or remote sides, looks like:
#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

cmd="x11vnc -display :$disp -localhost -rfbauth .vnc/passwd"
enc="copyrect tight zrle hextile zlib corre rre raw"

ssh -f -L 5900:localhost:5900 $host "$cmd"

for i in 1 2 3
do
        sleep 2
        if vncviewer -encodings "$enc" :0; then break; fi
done

   See also rx11vnc.pl below.
     _________________________________________________________________

   #2. Another method is to start the VNC viewer in listen mode
   "vncviewer -listen" and have x11vnc initiate a reverse connection
   using the [38]-connect option:
#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

cmd="x11vnc -display :$disp -localhost -connect localhost"   # <== note new opt
ion
enc="copyrect tight zrle hextile zlib corre rre raw"

vncviewer -encodings "$enc" -listen &
pid=$!
ssh -R 5500:localhost:5500 $host "$cmd"
kill $pid

   Note the use of the ssh option "-R" instead of "-L" to set up a remote
   port redirection.
     _________________________________________________________________

   #3. A third way is specific to the TightVNC vncviewer special option
   -via for gateways. The only tricky part is we need to start up x11vnc
   and give it some time (5 seconds in this example) to start listening
   for connections (so we cannot use the TightVNC default setting for
   VNC_VIA_CMD):
#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

VNC_VIA_CMD="ssh -f -L %L:%H:%R %G x11vnc -localhost -rfbport 5900 -display :$d
isp; sleep 5"
export VNC_VIA_CMD

vncviewer -via $host localhost:0      # must be TightVNC vncviewer.

   Of course if you already have the x11vnc running waiting for
   connections (or have it started out of [39]inetd(8)), you can simply
   use the TightVNC "vncviewer -via gateway host:port" in its default
   mode to provide secure ssh tunnelling.
     _________________________________________________________________



   VNC password file: Also note in the #1. example script that the
   [40]option "-rfbauth .vnc/passwd" provides additional protection by
   requiring a VNC password for every VNC viewer that connects. The
   vncpasswd or storepasswd programs, or the x11vnc [41]-storepasswd
   option can be used to create the password file. x11vnc also has the
   slightly less secure [42]-passwdfile and "-passwd XXXXX" [43]options
   to specify passwords.

   Very Important: It is up to YOU to tell x11vnc to use password
   protection (-rfbauth or -passwdfile), it will NOT do it for you
   automatically or force you to. The same goes for encrypting the
   channel between the viewer and x11vnc: it is up to you to use ssh,
   stunnel, [44]-ssl mode, a VPN, etc. For additional safety, also look
   into the -allow and -localhost [45]options and building x11vnc with
   [46]tcp_wrappers support to limit host access.

     _________________________________________________________________

    Tunnelling x11vnc via SSL:

   One can also encrypt the VNC traffic using an SSL tunnel such as
   [47]stunnel or using the built-in (Mar/2006) [48]-ssl openssl mode. A
   SSL-enabled Java applet VNC Viewer is also provided (and https can be
   used to download it).

   Although not as ubiquitous as ssh, SSL tunnelling still provides a
   useful alternative. See [49]this FAQ on -ssl and -stunnel modes for
   details and examples.
     _________________________________________________________________

    Downloading x11vnc:

   x11vnc is a contributed program to the [50]LibVNCServer project at
   SourceForge.net. I use libvncserver for all of the VNC aspects; I
   couldn't have done without it. The full source code may be found and
   downloaded (either file-release tarball or CVS tree) from the above
   link. As of Jun 2006, the [51]x11vnc-0.8.1.tar.gz source package is
   released (recommended download). The [52]x11vnc 0.8.1 release notes.

   The x11vnc package is the subset of the libvncserver package needed to
   build the x11vnc program. Also, you can get a copy of my latest,
   bleeding edge [53]x11vnc-0.8.2.tar.gz tarball to build the most up to
   date one.

   Precompiled Binaries/Packages:  See the [54]FAQ below for information
   about where you might obtain a precompiled x11vnc binary from 3rd
   parties and some ones I create.

   To obtain VNC viewers for the viewing side (Windows, Mac OS, or Unix)
   try these links:
     * [55]http://www.tightvnc.com/download.html
     * [56]http://www.realvnc.com/download-free.html
     * [57]http://sourceforge.net/projects/cotvnc/
     * [58]http://www.ultravnc.com/


   More tools: Here is a rsh/ssh wrapper script rx11vnc that attempts to
   automatically do the above Steps 1-3 for you (provided you have
   rsh/ssh login permission on the machine x11vnc is to be run on). The
   above example would be: "rx11vnc far-away.east:0" typed into a shell
   on sitting-here.west. Also included is an experimental script
   rx11vnc.pl that attempts to tunnel the vnc traffic through an ssh port
   redirection (and does not assume port 5900 is free). Have a look at
   them to see what they do and customize as needed:
     * [59]rx11vnc wrapper script
     * [60]rx11vnc.pl wrapper script to tunnel traffic thru ssh

     _________________________________________________________________

    Building x11vnc:

   If your OS has libjpeg.so and libz.so in standard locations you can
   build as follows (example given for the 0.8.1 release of x11vnc:
   replace with the version you downloaded):
(un-tar the x11vnc+libvncserver tarball)
# gzip -dc x11vnc-0.8.1.tar.gz | tar -xvf -

(cd to the source directory)
# cd x11vnc-0.8.1

(run configure and then run make)
# ./configure
# make

(if all went OK, copy x11vnc to the desired destination, e.g. $HOME/bin)
# cp ./x11vnc/x11vnc $HOME/bin

   Or do make install, it will probably install to /usr/local/bin (run
   ./configure --help for information on customizing your configuration,
   e.g. --prefix=/my/place). You can now run it via typing "x11vnc",
   "x11vnc -help | more", "x11vnc -forever -shared -display :0", etc.


   Note: Currently gcc is recommended to build libvncserver. In some
   cases it will build with non-gcc compilers, but the resulting binary
   sometimes fails to run properly. For Solaris pre-built gcc binaries
   are at [61]http://www.sunfreeware.com/. Some Solaris pre-built x11vnc
   binaries are [62]here.

   However, one user reports it does work fine when built with Sun Studio
   10, so YMMV. In fact, here is a little build script to do this on
   Solaris 10:
#!/bin/sh
PATH=/usr/ccs/bin:/opt/SUNWspro/bin:$PATH; export PATH

CC='cc' \
CFLAGS='-xO4' \
LDFLAGS='-L/usr/sfw/lib -L/usr/X11/lib -R/usr/sfw/lib -R/usr/X11/lib' \
CPPFLAGS='-I /usr/sfw/include -I/usr/X11/include' \
./configure

MAKE="make -e"
AM_CFLAGS=""
export MAKE AM_CFLAGS
$MAKE

   In general you can use the "make -e" trick if you don't like
   libvncserver's choice of AM_CFLAGS. See the [63]build scripts below
   for more ideas.

   You can find information on [64]Misc. Build problems here.

     _________________________________________________________________

   Building on Solaris, FreeBSD, etc:   Depending on your version of
   Solaris or other Unix OS the jpeg and/or zlib libraries may be in
   non-standard places (e.g. /usr/local, /usr/sfw, /opt/sfw, etc).

   Note: If configure cannot find these two libraries then TightVNC and
   ZRLE encoding support will be disabled, and you don't want that!!! The
   TightVNC encoding gives very good compression and performance, it even
   makes a noticeable difference over a fast LAN.


   Shortcuts: On Solaris 10 you can pick up almost everything just by
   insuring that your PATH has /usr/sfw/bin (for gcc) and /usr/ccs/bin
   (for other build tools), e.g.:
  env PATH=/usr/sfw/bin:/usr/ccs/bin:$PATH sh -c './configure; make'

   (The only thing this misses is /usr/X11/lib/libXrandr.so.2, which is
   for the little used -xrandr option, see the script below to pick it up
   as well).


   libjpeg is included in Solaris 9 and later (/usr/sfw/include and
   /usr/sfw/lib), and zlib in Solaris 8 and later (/usr/include and
   /usr/lib). So on Solaris 9 you can pick up everything with something
   like this:
  env PATH=/usr/local/bin:/usr/ccs/bin:$PATH sh -c './configure --with-jpeg=/us
r/sfw; make'

   assuming your gcc is in /usr/local/bin and x11vnc 0.7.1 or later.
   These are getting pretty long, see those assignments split up in the
   build script below.


   If your system does not have these libraries at all you can get the
   source for the libraries to build them: libjpeg is available at
   [65]ftp://ftp.uu.net/graphics/jpeg/ and zlib at
   [66]http://www.gzip.org/zlib/. See also
   [67]http://www.sunfreeware.com/ for Solaris binary packages of these
   libraries as well as for gcc. Normally they will install into
   /usr/local but you can install them anywhere with the
   --prefix=/path/to/anywhere, etc.


   Here is a build script that indicates one way to pass the library
   locations information to the libvncserver configuration via the
   CPPFLAGS and LDFLAGS environment variables.
---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8
<---
#!/bin/sh

# Build script for Solaris, etc, with gcc, libjpeg and libz in
# non-standard locations.

# set to get your gcc, etc:
#
PATH=/path/to/gcc/bin:/usr/ccs/bin:/usr/sfw/bin:$PATH

JPEG=/path/to/jpeg      # set to maybe "/usr/local", "/usr/sfw", or "/opt/sfw"
ZLIB=/path/to/zlib      # set to maybe "/usr/local", "/usr/sfw", or "/opt/sfw"

# Below we assume headers in $JPEG/include and $ZLIB/include and the
# shared libraries are in $JPEG/lib and $ZLIB/lib.  If your situation
# is different change the locations in the two lines below.
#
CPPFLAGS="-I $JPEG/include -I $ZLIB/include"
LDFLAGS="-L $JPEG/lib -R $JPEG/lib -L $ZLIB/lib -R $ZLIB/lib"

# These two lines may not be needed on more recent Solaris releases:
#
CPPFLAGS="$CPPFLAGS -I /usr/openwin/include"
LDFLAGS="$LDFLAGS -L /usr/openwin/lib -R /usr/openwin/lib"

# These are for libXrandr.so on Solaris 10:
#
CPPFLAGS="$CPPFLAGS -I /usr/X11/include"
LDFLAGS="$LDFLAGS -L /usr/X11/lib -R /usr/X11/lib"

# Everything needs to built with _REENTRANT for thread safe errno:
#
CPPFLAGS="$CPPFLAGS -D_REENTRANT"

export PATH CPPFLAGS LDFLAGS

./configure
make

ls -l ./x11vnc/x11vnc

---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8
<---

   Then do make install or copy the x11vnc binary to your desired
   destination.

   BTW, To run a shell script, just cut-and-paste the above into a file,
   say "myscript", then modify the "/path/to/..." items to correspond to
   your system/environment, and then type: "sh myscript" to run it.

   Note that on Solaris make is /usr/ccs/bin/make, so that is why the
   above puts /usr/ccs/bin in PATH. Other important build utilities are
   there too: ld, ar, etc. Also, it is probably a bad idea to have
   /usr/ucb in your PATH while building.

   Starting with the 0.7.1 x11vnc release the "configure --with-jpeg=DIR
   --with-zlib=DIR" options are handy if you want to avoid making a
   script.

   If you need to build on Solaris 2.5.1 or earlier or other older Unix
   OS's, see [68]this workaround FAQ.


   Building on FreeBSD, OpenBSD, ...:   The jpeg libraries seem to be in
   /usr/local or /usr/pkg on these OS's. You won't need the openwin stuff
   in the above script (but you may need /usr/X11R6/...). Also starting
   with the 0.7.1 x11vnc release, this usually works:
  ./configure --with-jpeg=/usr/local
  make


   Building on HP-UX:   For jpeg and zlib you will need to do the same
   sort of thing as described above for Solaris. You set CPPFLAGS and
   LDFLAGS to find them (see below for an example). You do not need to do
   any of the above /usr/openwin stuff. Also, HP-UX does not seem to
   support -R, so get rid of the -R items in LDFLAGS. Because of this, at
   runtime you may need to set LD_LIBRARY_PATH or SHLIB_PATH to indicate
   the directory paths so the libraries can be found. It is a good idea
   to have static archives, e.g. libz.a and libjpeg.a for the nonstandard
   libraries so that they get bolted into the x11vnc binary (and so won't
   get "lost").

   Here is what we recently did to build x11vnc 0.7.2 on HP-UX 11.11
./configure --with-jpeg=$HOME/hpux/jpeg --with-zlib=$HOME/hpux/zlib
make

   Where we had static archives (libjpeg.a, libz.a) only and header files
   in the $HOME/hpux/... directories as discussed for the build script.


   Building on AIX:   AIX: one user had to add the "X11.adt" package to
   AIX 4.3.3 and 5.2 to get build header files like XShm.h, etc. You may
   also want to make sure that /usr/lpp/X11/include, etc is being picked
   up by the configure and make.
     _________________________________________________________________

    Beta Testing:

   I don't have any formal beta-testers for the releases of x11vnc, so
   I'd appreciate any additional testing very much!

   Thanks to those who helped beta test x11vnc 0.8.1 released in Jun
   2006!

   Please help test and debug the 0.8.2 version for release sometime in
   Summer 2006.

   The version 0.8.2 beta tarball is kept here:
   [69]x11vnc-0.8.2.tar.gz

   There are also some Linux, Solaris, and other OS test binaries
   [70]here. Please kick the tires and report bugs, performance
   regressions, undesired behavior, etc. to [71]me.


   Here are some features that appeared in the 0.8.1 release:
     * Improved support for Webcams and TV tuner devices (/dev/video)
       with the [72]-rawfb option. E.g. "-rawfb video0" will autodetect
       the video WxHxB (requires Video4Linux buildtime or the v4l-info
       utility). Use "-rawfb video -pipeinput VID" for a simple keystroke
       utility to configure the capture device.
     * Convenience utility [73]-rawfb cons to connect to the linux
       console (/dev/fb0) and inject keystrokes into it (/dev/ttyX). Like
       LinuxVNC or -pipeinput vcinject.pl, but now built in.
     * The [74]-24to32 option provides automatic translation from 24bpp
       to 32bpp framebuffers to avoid problems with viewers, etc (often
       needed for webcams).
     * The [75]-usepw option will try to use your existing ~/.vnc/passwd
       or ~/.vnc/passwdfile passwords or otherwise prompt you to create
       one (the server exits unless a password file is found and used).
       Use "x11vnc -storepasswd" to prompt for a password without echoing
       and save it in ~/.vnc/passwd
     * The X CLIPBOARD selection is now managed in addition to PRIMARY.
       Use [76]-noclipboard and [77]-nosetclipboard for the previous
       PRIMARY-only behavior.
     * Use [78]-capslock and [79]-skip_lockkeys to help manage CapsLocks
       behavior better.
     * The [80]-fbpm option provides FBPM support for hardware that
       provides framebuffer power management (it needs to be disabled
       when vnc clients are connected).
     * The [81]-xinerama option is now on by default. Use -noxinerama
       option to disable.
     * Bug fixes and speedups.

   Here are some features that will appear in the 0.8.2 release:
     * The [82]-ssl option provides SSL encryption and authentication
       natively via the [83]www.openssl.org library. One can use from a
       simple self-signed certificate server certificate up to full CA
       and client certificate authentication schemes.
     * The [84]-stunnel option starts up a SSL tunnel server stunnel
       (that must be installed separately on the system:
       [85]www.stunnel.org) to allow only encrypted SSL connections from
       the network.
     * The [86]-sslverify option allows for authenticating VNC clients
       via their certificates in either -ssl or -stunnel modes.
     * An SSL enabled Java applet VNC Viewer applet is provided in
       classes/ssl/VncViewer.jar. It may also be loaded into the web
       browser via https (http over SSL) in addition to http. (via the
       VNC port or also by the separate [87]-https port option). A
       wrapper shell script [88]ssl_vncviewer is also provided that sets
       up a stunnel client-side tunnel on Unix systems.
     * The [89]-unixpw option supports Unix username and password
       authentication (a variant is the [90]-unixpw_nis option that works
       in NIS environments). The [91]-ssl or [92]-localhost +
       [93]-stunnel options are enforced in this mode to prevent password
       sniffing. As a convenience, the -ssl or -stunnel requirements are
       lifted if a SSH tunnel can be deduced (but -localhost still
       applies).
     * The [94]-display WAIT:... option extends the normal [95]-display
       option by having x11vnc wait until a VNC viewer connects before
       attaching to an X display. A command can also be supplied that
       will determine the DISPLAY and XAUTHORITY data. A default one is
       built-in for WAIT:cmd=FINDDISPLAY. Coupling this with "-unixpw
       -users unixpw=" provides a way to allow a user to login with their
       UNIX password and have their display connected to
       [96]automatically.

   Here are some [97]previous release notes
     _________________________________________________________________

    Some Notes:

   Both a client and a server:   It is sometimes confusing to people that
   x11vnc is both a client and a server at the same time. It is an X
   client because it connects to the running X server to do the screen
   polls. Think of it as a rather efficient "screenshot" program running
   continuously. It is a server in the sense that it is a VNC server that
   VNC viewers on the network can connect to and view the screen
   framebuffer it manages.

   When trying to debug problems, remember to think of both roles. E.g.
   "how is x11vnc connecting to the X server?", "how is the vncviewer
   connecting to x11vnc?", "what permits/restricts the connection?". Both
   links may have reachability, permission, and other issues.

   Network performance:   Whether you are using Xvnc or x11vnc it is
   always a good idea to have a solid background color instead of a
   pretty background image. Each and every re-exposure of the background
   must be resent over the network: better to have that background be a
   solid color that compresses very well compared to a photo image. (This
   is one place where the X protocol has an advantage over the VNC
   protocol.) I suggest using xsetroot, dtstyle or similar utility to set
   a solid background while using x11vnc. You can turn the pretty
   background image back on when you are using the display directly.
   Update: As of Feb/2005 x11vnc has the [98]-solid [color] option that
   works on recent GNOME, KDE, and CDE and also on classic X (background
   image is on the root window).

   I also find the [99]TightVNC encoding gives the best response for my
   usage (Unix <-> Unix over cable modem). One needs a tightvnc-aware
   vncviewer to take advantage of this encoding.

   TCP port issues:   Notice the lines
  18/07/2003 14:36:31 Autoprobing selected port 5900
  PORT=5900

   in the output. 5900 is the default VNC listening port (just like 6000
   is X11's default listening port). Had port 5900 been taken by some
   other application, x11vnc would have next tried 5901. That would mean
   the viewer command above should be changed to vncviewer
   far-away.east:1. You can force the port with the "[100]-rfbport NNNN"
   option where NNNN is the desired port number. If that port is already
   taken, x11vnc will exit immediately.   (also see the "SunRay Gotcha"
   note below)

   Options:   x11vnc has (far too) many features that may be activated
   via its [101]command line options. Useful options are, e.g., -scale to
   do server-side scaling, and -rfbauth passwd-file to use VNC password
   protection (the vncpasswd or storepasswd programs, or the x11vnc
   [102]-storepasswd option can be used to create the password file).

   Algorithm:   How does x11vnc do it? Rather brute-forcedly: it
   continuously polls the X11 framebuffer for changes using
   XShmGetImage(). When changes are discovered, it instructs libvncserver
   which rectangular regions of the framebuffer have changed, and
   libvncserver compresses the changes and sends them off to any
   connected VNC viewers. A number of applications do similar things,
   such as x0rfbserver, krfb, x0vncserver, vino. x11vnc uses a 32 x 32
   pixel tile model (the desktop is decomposed into roughly 1000 such
   tiles), where changed tiles are found by pseudo-randomly polling 1
   pixel tall horizontal scanlines. This is a surprisingly effective
   algorithm for finding changed regions. For keyboard and mouse user
   input the XTEST extension is used to pass the input events to the X
   server. To detect XBell "beeps" the XKEYBOARD extension is used. If
   available, the XFIXES extension is used to retrieve the current mouse
   cursor shape. Also, if available the X DAMAGE extension is used to
   receive hints from the X server where modified regions on the screen
   are. This greatly reduces the system load when not much is changing on
   the screen and also improves how quickly the screen is updated.

   Barbershop mirrors effect:   What if x11vnc is started up, and
   vncviewer is then started up on the same machine and displayed on the
   same display x11vnc is polling? One might "accidentally" do this when
   first testing out the programs. You get an interesting
   recursive/feedback effect where vncviewer images keep popping up each
   one contained in the previous one and slightly shifted a bit by the
   window manager decorations. There will be an [103]even more
   interesting effect if -scale is used. Also, if the XKEYBOARD is
   supported and the XBell "beeps" once, you get an infinite loop of
   beeps going off. Although all of this is mildly exciting it is not
   much use: you will normally run and display the viewer on a different
   machine!
     _________________________________________________________________

    Sun Ray Notes:

   You can run x11vnc on your (connected or disconnected) [104]SunRay
   session. Here are some [105]notes on SunRay usage with x11vnc.

     _________________________________________________________________

    Limitations:

     * Due to the polling nature, some activities (opaque window moves,
       scrolling), can be pretty choppy/ragged and others (exposures of
       large areas) slow. Experiment with interacting a bit differently
       than you normally do to minimize the effects (e.g. do fullpage
       paging rather than line-by-line scrolling, and move windows in a
       single, quick motion). Recent work has provided the
       [106]-scrollcopyrect and [107]-wireframe speedups using the
       CopyRect VNC encoding and other things, but they only speed up
       certain activities, not all.
     * A rate limiting factor for x11vnc performance is that video
       hardware is optimized for writing, not reading (x11vnc reads the
       video framebuffer for the screen image data). The difference can
       be a factor of 10 to 1000, and so it usually takes about 0.5-1 sec
       to read in the whole video hardware framebuffer (e.g. 5MB for
       1280x1024 at depth 24 with a read rate of 5-10MB/sec). So whenever
       activity changes most of the screen (e.g. moving or iconifying a
       large window) there is a delay of 0.5-1 sec while x11vnc reads the
       changed regions in.
       Note: A quick way to get a 2X speedup for x11vnc is to switch from
       depth 24 (32bpp) to depth 16 (16bpp). You get a 4X speedup going
       to 8bpp, but the lack of color cells is usually unacceptable.
       To get a sense of the read and write speeds of your video card,
       you can run benchmarks like: x11perf -getimage500,  x11perf
       -putimage500,  x11perf -shmput500 and for XFree86 displays with
       direct graphics access the dga command (press "b" to run the
       benchmark and then after a few seconds press "q" to quit). Even
       this "dd if=/dev/fb0 of=/dev/null" often gives a good estimate. We
       have seen a few cases where the hardware fb read speed is greater
       than 65 MB/sec: on high end graphics workstations from SGI and
       Sun, and also from a Linux user using nvidia proprietary drivers
       for his nvidia video card. If you have a card with a fast read
       speed please send us the details.
       On XFree86/Xorg it is actually possible to increase the
       framebuffer read speed considerably (5-100 times) by using the
       Shadow Framebuffer (a copy of the framebuffer is kept in main
       memory and this can be read much more quickly). To do this one
       puts the line Option "ShadowFB" "true" in the Device section of
       the /etc/X11/XF86Config or /etc/X11/xorg.conf file. Note that this
       disables 2D acceleration at the physical display and so likely
       defeats the purpose. Nevertheless this could be handy in some
       circumstances, e.g. if the slower speed while sitting at the
       physical display was acceptable (this seems to be true for most
       video cards these days). Unfortunately it does not seem shadowfb
       can be turned on and off dynamically...
       Another amusing thing one can do is use Xvfb as the X server, e.g.
       "xinit $HOME/.xinitrc -- /usr/X11R6/bin/Xvfb :1 -screen 0
       1024x768x16" x11vnc can poll Xvfb efficiently via main memory.
       It's not exactly clear why one would want to do this (perhaps to
       take advantage of an x11vnc feature, such as framebuffer scaling),
       instead of using vncserver/Xvnc, but we mention it because it may
       be of use for special purpose applications.
       Also, a faster and more accurate way is to use the "dummy"
       XFree86/Xorg device driver (or our Xdummy wrapper script). See
       [108]this FAQ for details.
     * Somewhat surprisingly, the X11 mouse (cursor) shape is write-only
       and cannot be queried from the X server. So traditionally in
       x11vnc the cursor shape stays fixed at an arrow. (see the "-cursor
       X" and "-cursor some" [109]options, however, for a partial hack
       for the root window, etc.). However, on Solaris using the SUN_OVL
       overlay extension, x11vnc can show the correct mouse cursor when
       the [110]-overlay option is also supplied. A similar thing is done
       on IRIX as well when -overlay is supplied.
       More generally, as of Dec/2004 x11vnc supports the new XFIXES
       extension (in Xorg and Solaris 10) to query the X server for the
       exact cursor shape, this works pretty well except that cursors
       with transparency (alpha channel) need to approximated to solid
       RGB values (some cursors look worse than others).
     * Audio from applications is of course not redirected (separate
       redirectors do exist, e.g. esd [111]the FAQ on this below.) The
       XBell() "beeps" will work if the X server supports the XKEYBOARD
       extension. (Note that on Solaris XKEYBOARD is disabled by default.
       Passing +kb to Xsun enables it).
     * The scroll detection algorithm for the [112]-scrollcopyrect option
       can give choppy or bunched up transient output and occasionally
       painting errors.
     * Occasionally a patch of tiles will not get updated correctly.
       Evidently a timing related bug and difficult to reproduce...
     * Using -threads can expose some bugs in libvncserver.

   Please feel free to [113]contact me if you have any questions,
   problems, or comments about x11vnc, etc.
   Also, some people ask if they can make a donation, see [114]this link
   for that.
     _________________________________________________________________

    x11vnc FAQ:


   [Building and Starting]

   [115]Q-1: I can't get x11vnc to start up. It says "XOpenDisplay failed
   (null)" or "Xlib: connection to ":0.0" refused by server Xlib: No
   protocol specified" and then exits. What do I need to do? 

   [116]Q-2: I can't get x11vnc and/or libvncserver to compile. 

   [117]Q-3: I just built x11vnc successfully, but when I use it my
   keystrokes and mouse button clicks are ignored  (I am able to move the
   mouse though). 

   [118]Q-4: Help, I need to run x11vnc on Solaris 2.5.1 (or other old
   Unix/Linux) and it doesn't compile! 

   [119]Q-5: Where can I get a precompiled x11vnc binary for my Operating
   System? 

   [120]Q-6: Where can I get a VNC Viewer binary (or source code) for the
   Operating System I will be viewing from? 

   [121]Q-7: How can I see all of x11vnc's command line options and
   documentation on how to use them? 

   [122]Q-8: I don't like typing arcane command line options every time I
   start x11vnc. What can I do? Is there a config file? Or a GUI? 

   [123]Q-9: How can I get the GUI to run in the System Tray, or at least
   be a smaller, simpler icon? 

   [124]Q-10: Can I make x11vnc more quiet and also go into the
   background after starting up? 

   [125]Q-11: Sometimes when a VNC viewer dies abruptly, x11vnc also dies
   with the error message like: "Broken pipe". I'm using the -forever
   mode and I want x11vnc to keep running. 

   [126]Q-12: Are there any build-time customizations possible, e.g.
   change defaults, create a smaller binary, etc? 

   [Win2VNC Related]

   [127]Q-13: I have two separate machine displays in front of me, one
   Windows the other X11: can I use x11vnc in combination with Win2VNC in
   dual-screen mode to pass the keystrokes and mouse motions to the X11
   display? 

   [128]Q-14: I am running Win2VNC on my Windows machine and "x11vnc
   -nofb" on Unix to pass keyboard and mouse to the Unix monitor.
   Whenever I start Win2VNC it quickly disconnects and x11vnc says:
   rfbProcessClientNormalMessage: read: Connection reset by peer 

   [Color Issues]

   [129]Q-15: The X display I run x11vnc on is only 8 bits per pixel
   (bpp) PseudoColor (i.e. only 256 distinct colors). The x11vnc colors
   may start out OK, but after a while they are incorrect in certain
   windows. 

   [130]Q-16: Color problems: Why are the colors for some windows
   incorrect in x11vnc? BTW, my X display has nice overlay/multi-depth
   visuals of different color depths: e.g. there are both depth 8 and 24
   visuals available at the same time. 

   [131]Q-17: How do I figure out the window id to supply to the -id
   windowid option? 

   [132]Q-18: Why don't menus or other transient windows come up when I
   am using the -id windowid option to view a single application window? 

   [133]Q-19: My X display is depth 24 at 24bpp (instead of the normal
   depth 24 at 32bpp). I'm having lots of color and visual problems with
   x11vnc and/or vncviewer. What's up? 

   [Xterminals]

   [134]Q-20: Can I use x11vnc to view and interact with an Xterminal
   (e.g. NCD) that is not running UNIX and so x11vnc cannot be run on it
   directly? 

   [135]Q-21: How do I get my X permissions (MIT-MAGIC-COOKIE file)
   correct for a Unix/Linux machine acting as an Xterminal? 

   [Sun Rays]

   [136]Q-22: I'm having trouble using x11vnc with my Sun Ray session. 

   [Remote Control]

   [137]Q-23: How do I stop x11vnc once it is running in the background? 

   [138]Q-24: Can I change settings in x11vnc without having to restart
   it? Can I remote control it? 

   [Security and Permissions]

   [139]Q-25: How do I create a VNC password for use with x11vnc? 

   [140]Q-26: Can I make it so -storepasswd doesn't show my password on
   the screen? 

   [141]Q-27: Can I have two passwords for VNC viewers, one for full
   access and the other for view-only access to the display? 

   [142]Q-28: Can I have as many full-access and view-only passwords as I
   like? 

   [143]Q-29: Does x11vnc support Unix usernames and passwords? Can I
   further limit the set of Unix usernames who can connect to the VNC
   desktop? 

   [144]Q-30: Why does x11vnc exit as soon as the VNC viewer disconnects?
   And why doesn't it allow more than one VNC viewer to connect at the
   same time? 

   [145]Q-31: Can I limit which machines incoming VNC clients can connect
   from? 

   [146]Q-32: How do I build x11vnc/libvncserver with libwrap
   (tcp_wrappers) support? 

   [147]Q-33: Can I have x11vnc only listen on one network interface
   (e.g. internal LAN) rather than having it listen on all network
   interfaces and relying on -allow to filter unwanted connections out? 

   [148]Q-34: Now that -localhost implies listening only on the loopback
   interface, how I can occasionally allow in a non-localhost via the -R
   allowonce remote control command? 

   [149]Q-35: Can I fine tune what types of user input are allowed? E.g.
   have some users just be able to move the mouse, but not click or type
   anything? 

   [150]Q-36: Can I prompt the user at the local X display whether the
   incoming VNC client should be accepted or not? Can I decide to make
   some clients view-only? How about running an arbitrary program to make
   the decisions? 

   [151]Q-37: I start x11vnc as root because it is launched via inetd(8)
   or a display manager like gdm(1). Can I have x11vnc later switch to a
   different user? 

   [152]Q-38: I use a screen-lock when I leave my workstation (e.g.
   xscreensaver or xlock). When I remotely access my workstation desktop
   via x11vnc I can unlock the desktop fine, but I am worried people will
   see my activities on the physical monitor. What can I do to prevent
   this, or at least make it more difficult? 

   [153]Q-39: Can I have x11vnc automatically lock the screen when I
   disconnect the VNC viewer? 

   [Encrypted Connections]

   [154]Q-40: How can I tunnel my connection to x11vnc via an encrypted
   SSH channel between two Unix machines? 

   [155]Q-41: How can I tunnel my connection to x11vnc via an encrypted
   SSH channel from Windows using an SSH client like Putty? 

   [156]Q-42: How can I tunnel my connection to x11vnc via an encrypted
   SSL channel using an external tool like stunnel? 

   [157]Q-43: Does x11vnc have built-in SSL tunneling? 

   [158]Q-44: How do I use VNC Viewers with built-in SSL tunneling? 

   [159]Q-45: How do I use VNC Viewers with built-in SSL tunneling when
   going through a Web Proxy? 

   [160]Q-46: Can Apache web server act as a gateway for users to connect
   via SSL from the Internet with a Web browser to x11vnc running on
   their workstations behind a firewall? 

   [161]Q-47: Can I create and use my own SSL Certificate Authority (CA)
   with x11vnc? 

   [Display Managers and Services]

   [162]Q-48: How can I run x11vnc as a "service" that is always
   available? 

   [163]Q-49: How can I use x11vnc to connect to an X login screen like
   xdm, GNOME gdm, KDE kdm, or CDE dtlogin? (i.e. nobody is logged into
   an X session yet). 

   [164]Q-50: Can I run x11vnc out of inetd(8)? How about xinetd(8)? 

   [165]Q-51: Can I have x11vnc allow a user to log in with her UNIX
   password and then have it find her X display on that machine and
   connect to it? 

   [166]Q-52: Can I have x11vnc restart itself after it terminates? 

   [167]Q-53: How do I make x11vnc work with the Java VNC viewer applet
   in a web browser? 

   [168]Q-54: Are reverse connections (i.e. the VNC server connecting to
   the VNC viewer) using "vncviewer -listen" and vncconnect(1) supported?
   
   [169]Q-55: Can I use x11vnc as a replacement for Xvnc? (i.e. not for a
   real display, but for a virtual one I keep around). 

   [170]Q-56: How can I use x11vnc on "headless" machines? Why might I
   want to? 

   [Resource Usage and Performance]

   [171]Q-57: I have lots of memory, but why does x11vnc fail with
   shmget: No space left on device    or    Minor opcode of failed
   request: 1 (X_ShmAttach)? 

   [172]Q-58: How can I make x11vnc use less system resources? 

   [173]Q-59: How can I make x11vnc use MORE system resources? 

   [174]Q-60: I use x11vnc over a slow link with high latency (e.g.
   dialup modem), is there anything I can do to speed things up? 

   [175]Q-61: Does x11vnc support the X DAMAGE Xserver extension to find
   modified regions of the screen quickly and efficiently? 

   [176]Q-62: When I drag windows around with the mouse or scroll up and
   down things really bog down (unless I do the drag in a single, quick
   motion). Is there anything to do to improve things? 

   [177]Q-63: Why not do something like wireframe animations to avoid the
   windows "lurching" when being moved or resized? 

   [178]Q-64: Can x11vnc try to apply heuristics to detect when an window
   is scrolling its contents and use the CopyRect encoding for a speedup?
   
   [Mouse Cursor Shapes]

   [179]Q-65: Why isn't the mouse cursor shape (the little icon shape
   where the mouse pointer is) correct as I move from window to window? 

   [180]Q-66: When using XFIXES cursorshape mode, some of the cursors
   look really bad with extra black borders around the cursor and other
   cruft. How can I improve their appearance? 

   [181]Q-67: In XFIXES mode, are there any hacks to handle cursor
   transparency ("alpha channel") exactly? 

   [Mouse Pointer]

   [182]Q-68: Why does the mouse arrow just stay in one corner in my
   vncviewer, whereas my cursor (that does move) is just a dot? 

   [183]Q-69: Can I take advantage of the TightVNC extension to the VNC
   protocol where Cursor Positions Updates are sent back to all connected
   clients (i.e. passive viewers can see the mouse cursor being moved
   around by another viewer)? 

   [184]Q-70: Is it possible to swap the mouse buttons (e.g. left-handed
   operation), or arbitrarily remap them? How about mapping button clicks
   to keystrokes, e.g. to partially emulate Mouse wheel scrolling? 

   [Keyboard Issues]

   [185]Q-71: How can I get my AltGr and Shift modifiers to work between
   keyboards for different languages? 

   [186]Q-72: When I try to type a "<" (i.e. less than) instead I get ">"
   (i.e. greater than)! Strangely, typing ">" works OK!! 

   [187]Q-73: When I try to type a "<" (i.e. less than) instead I get
   "<," (i.e. an extra comma). 

   [188]Q-74: I'm using an "international" keyboard (e.g. German "de", or
   Danish "dk") and the -modtweak mode works well if the VNC viewer is
   run on a Unix/Linux machine with a similar keyboard.   But if I run
   the VNC viewer on Unix/Linux with a different keyboard (e.g. "us") or
   Windows with any keyboard, I can't type some keys like:   "@", "$",
   "<", ">", etc. How can I fix this? 

   [189]Q-75: When typing I sometimes get double, triple, or more of my
   keystrokes repeated. I'm sure I only typed them once, what can I do? 

   [190]Q-76: The x11vnc -norepeat mode is in effect, but I still get
   repeated keystrokes!! 

   [191]Q-77: The machine where I run x11vnc has an AltGr key, but the
   local machine where I run the VNC viewer does not. Is there a way I
   can map a local unused key to send an AltGr? How about a Compose key
   as well? 

   [192]Q-78: I have a Sun machine I run x11vnc on. Its Sun keyboard has
   just one Alt key labelled "Alt" and two Meta keys labelled with little
   diamonds. The machine where I run the VNC viewer only has Alt keys.
   How can I send a Meta keypress? (e.g. emacs needs this) 

   [193]Q-79: Can I map a keystroke to a mouse button click on the remote
   machine? 

   [194]Q-80: How can I get Caps_Lock to work between my VNC viewer and
   x11vnc? 

   [Screen Related Issues and Features]

   [195]Q-81: The remote display is larger (in number of pixels) than the
   local display I am running the vncviewer on. I don't like the
   vncviewer scrollbars, what I can do? 

   [196]Q-82: Does x11vnc support server-side framebuffer scaling? (E.g.
   to make the desktop smaller). 

   [197]Q-83: Does x11vnc work with Xinerama? (i.e. multiple monitors
   joined together to form one big, single screen). 

   [198]Q-84: Can I use x11vnc on a multi-headed display that is not
   Xinerama (i.e. separate screens :0.0, :0.1, ... for each monitor)? 

   [199]Q-85: Can x11vnc show only a portion of the display? (E.g. for a
   special purpose rfb application). 

   [200]Q-86: Does x11vnc support the XRANDR (X Resize, Rotate and
   Reflection) extension? Whenever I rotate or resize the screen x11vnc
   just seems to crash. 

   [201]Q-87: Why is the view in my VNC viewer completely black? Or why
   is everything flashing around randomly? 

   [202]Q-88: I use Linux Virtual Consoles (VC's) to implement 'Fast User
   Switching' between users' sessions (e.g. Betty is on Ctrl-Alt-F7,
   Bobby is on Ctrl-Alt-F8, and Sid is on Ctrl-Alt-F1: they use those
   keystrokes to switch between their sessions).   How come the view in a
   VNC viewer connecting to x11vnc is either completely black or
   otherwise all messed up unless the X session x11vnc is attached to is
   in the active VC? 

   [203]Q-89: Can I use x11vnc to view my VMWare session remotely? 

   [204]Q-90: Can non-X devices (e.g. a raw framebuffer) be viewed (and
   even controlled) with VNC via x11vnc? 

   [205]Q-91: Can I export via VNC a Webcam or TV tuner framebuffer using
   x11vnc? 

   [206]Q-92: I am using x11vnc where my local machine has "popup/hidden
   taskbars" (e.g. GNOME or MacOS X) and the remote display where x11vnc
   runs also has "popup/hidden taskbars" (e.g. GNOME). When I move the
   mouse to the edge of the screen where the popups happen, the taskbars
   interfere and fight with each other in strange ways. What can I do? 

   [Misc: Clipboard, File Transfer, Sound, Beeps, Thanks, etc.]

   [207]Q-93: Does the Clipboard/Selection get transferred between the
   vncviewer and the X display? 

   [208]Q-94: Can I transfer files back and forth with x11vnc? 

   [209]Q-95: How can I hear the sound (audio) from the remote
   applications on the desktop I am viewing via x11vnc? 

   [210]Q-96: Why don't I hear the "Beeps" in my X session (e.g. when
   typing tput bel in an xterm)? 

   [211]Q-97: Thanks for your program and for your help! Can I make a
   donation? 
     _________________________________________________________________


   [Building and Starting]

   Q-1: I can't get x11vnc to start up. It says "XOpenDisplay failed
   (null)" or "Xlib: connection to ":0.0" refused by server Xlib: No
   protocol specified" and then exits. What do I need to do?

   For the former error, you need to specify the X display to connect to
   (it also needs to be on the same machine the x11vnc process is to run
   on). Set your DISPLAY environment variable or use the [212]-display
   option to specify it. Nearly always the correct value will be ":0"


   For the latter error, you need to set up the X11 permissions
   correctly.

   To make sure X11 permissions are the problem do this simple test:
   while sitting at the physical X display open a terminal window
   (gnome-terminal, xterm, etc). You should be able to run x11vnc
   successfully without any need for special steps or command line
   options in that terminal. If that works OK then you know X11
   permissions are the only thing preventing it from working when you try
   to start x11vnc via, say, a remote shell.

   How to Solve:  See the xauth(1), Xsecurity(7), and xhost(1) man pages
   for much info on X11 permissions. For example, you may need to set
   your XAUTHORITY environment variable or use the [213]-auth option to
   point to the correct MIT-MAGIC-COOKIE file (e.g. /home/joe/.Xauthority
   or /var/gdm/:0.Xauth or /var/lib/kdm/A:0-crWk72K or /tmp/.gdmzndVlR),
   or simply be sure you run x11vnc as the correct user (i.e. the user
   who is logged into the X session you wish to view).

   The MIT cookie file contains the secret key that allows x11vnc to
   connect to the desired X display.

   If, say, sshd has set XAUTHORITY to point to a random file it has
   created for X forwarding that will cause problems. (Under some
   circumstances even su(1) and telnet(1) can set XAUTHORITY. See also
   the gdm parameter NeverPlaceCookiesOnNFS that sets XAUTHORITY to a
   random filename in /tmp for the whole X session).

   Running x11vnc as root is often not enough: you need to know where the
   MIT-MAGIC-COOKIE file for the desired X display is.

   Example solution:
  x11vnc -display :0 -auth /var/gdm/:0.Xauth

   (this is for the display manager gdm and requires root permission to
   read the gdm cookie file, see [214]this faq for other display manager
   cookie file names). While running x11vnc as root, remember it comes
   with no warranty ;-).

   Less safe, but to avoid figuring out where the correct XAUTHORITY file
   is, if the person sitting at the physical X session types "xhost
   +localhost" then one should be able to attach x11vnc to the session
   (from the same machine). The person could then type "xhost -localhost"
   after x11vnc has connected to go back to the default permissions.
   Also, for some situations the "-users lurk=" option may be of use
   (please read the documentation on the [215]-users option).

   To test out your X11 permissions from a remote shell, set DISPLAY and
   possibly XAUTHORITY (see your shell's man page, bash(1), tcsh(1), on
   how to set environment variables) and type xdpyinfo in the same place
   you will be typing (or otherwise running) x11vnc. If information is
   printed out about the X display (screen sizes, supported extensions,
   color visuals info) that means the X11 permissions are set up
   properly: xdpyinfo successfully connected to DISPLAY! You could also
   type xclock and make sure no errors are reported (a clock should
   appear on the X display, press Ctrl-C to stop it). If these work, then
   typing "x11vnc" should also work.

   Important: if you cannot get your X11 permissions so that the xdpyinfo
   or xclock tests work, x11vnc also will not work (all of these X
   clients must be allowed to connect to the X server to function
   properly).


   Q-2: I can't get x11vnc and/or libvncserver to compile.

   Make sure you have all of the required -devel packages installed.
   These include X11/XFree86, libjpeg, libz, ...

   After running the libvncserver configure, carefully examine the output
   and the messages in the config.log file looking for missing
   components. For example, if the configure output looks like:
  checking how to run the C preprocessor... gcc -E
  checking for X... no
  checking for XkbSelectEvents in -lX11... no
  checking for XineramaQueryScreens in -lXinerama... no
  checking for XTestFakeKeyEvent in -lXtst... no

   there is quite a bit wrong with the build environment. Hopefully
   simply adding -devel packages will fix it.

   For Debian the list seems to be:
  gcc
  make
  libc6-dev
  libjpeg62-dev
  libx11-dev
  libxext-dev
  libxrandr-dev
  libxtst-dev
  x-dev
  xlibs-static-dev
  zlib1g-dev

   For Redhat the list seems to be:
  gcc
  make
  glibc-devel
  libjpeg-devel
  XFree86-devel or xorg-x11-devel
  zlib-devel


   Q-3: I just built x11vnc successfully, but when I use it my keystrokes
   and mouse button clicks are ignored  (I am able to move the mouse
   though).

   This is most likely due to you not having a working build environment
   for the XTEST client library libXtst.so. The library is probably
   present on your system, but the package installing the development
   header file is missing.

   If you were watching carefully while configure was running you would
   have seen:
  checking for XTestFakeKeyEvent in -lXtst... no

   The solution is to add the necessary build environment package (and
   the library package if that is missing too). On Debian the build
   package is libxtst-dev. Other distros/OS's may have it in another
   package.

   x11vnc will build without support for this library (e.g. perhaps one
   wants a view-only x11vnc on a stripped down or embedded system...). At
   runtime it will also continue to run even if the X server it connects
   to does not support XTEST. In both cases it cannot inject keystrokes
   or button clicks since XTEST is needed for that (it can still move the
   mouse pointer using the X API XWarpPointer()).

   You will see a warning message something like this at run time:
  20/03/2005 22:33:09 WARNING: XTEST extension not available (either missing fr
om
  20/03/2005 22:33:09   display or client library libXtst missing at build time
).
  20/03/2005 22:33:09   MOST user input (pointer and keyboard) will be DISCARDE
D.
  20/03/2005 22:33:09   If display does have XTEST, be sure to build x11vnc wit
h
  20/03/2005 22:33:09   a working libXtst build environment (e.g. libxtst-dev,
  20/03/2005 22:33:09   or other packages).
  20/03/2005 22:33:09 No XTEST extension, switching to -xwarppointer mode for
  20/03/2005 22:33:09   pointer motion input.


   Q-4: Help, I need to run x11vnc on Solaris 2.5.1 (or other old
   Unix/Linux) and it doesn't compile!

   We apologize that x11vnc does not build cleanly on older versions of
   Solaris, Linux, etc.: very few users are on these old releases.

   We have heard that since Dec/2004 a Solaris 2.6 built x11vnc will run
   on Solaris Solaris 2.5 and 2.5.1 (since a workaround for XConvertCase
   is provided).

   In any event, here is a workaround for Solaris 2.5.1 (and perhaps
   earlier and perhaps non-Solaris):

   First use the environment settings (CPPFLAGS, LDFLAGS, etc.) in the
   above [216]Solaris build script to run the configure command. That
   should succeed without failure. Then you have to hand edit the
   autogenerated rfb/rfbconfig.h file in the source tree, and just before
   the last #endif at the bottom of that file insert these workaround
   lines:
struct timeval _tmp_usleep_tv;
#define usleep(x) \
    _tmp_usleep_tv.tv_sec  = (x) / 1000000; \
    _tmp_usleep_tv.tv_usec = (x) % 1000000; \
    select(0, NULL, NULL, NULL, &_tmp_usleep_tv);
int gethostname(char *name, int namelen);
long random();
int srandom(unsigned int seed);
#undef LIBVNCSERVER_HAVE_LIBPTHREAD
#define SHUT_RDWR 2
typedef unsigned int in_addr_t;
#define snprintf(a, n, args...) sprintf((a), ## args)

   Then run make with the Solaris build script environment, everything
   should compile without problems, and the resulting x11vnc binary
   should work OK. If some non-x11vnc related programs fail (e.g. test
   programs) and the x11vnc binary is not created try "make -k" to have
   it keep going. Similar sorts of kludges in rfb/rfbconfig.h can be done
   on other older OS (Solaris, Linux, ...) releases.

   Here are some notes for similar steps that need to be done to build on
   [217]SunOS 4.x

   Please let us know if you had to use the above workaround (and whether
   it worked or not). If there is enough demand we will try to push clean
   compilations back to earlier Solaris, Linux, etc, releases.


   Q-5: Where can I get a precompiled x11vnc binary for my Operating
   System?

   Hopefully the [218]build steps above and [219]FAQ provide enough info
   for a painless compile for most environments. Please report problems
   with the x11vnc configure, make, etc. on your system (if your system
   is known to compile other GNU packages successfully).

   There are precompiled x11vnc binaries built by other groups that are
   available at the following locations:
    Debian:         (.deb)  [220]http://packages.debian.org/x11vnc

   Slackware: (.tgz) [221]http://www.linuxpackages.net/ Redhat/Fedora:
   (.rpm) [222]http://dag.wieers.com/packages/x11vnc/
   [223]http://dries.ulyssis.org/rpm/packages/x11vnc SuSE: (.rpm)
   [224]http://linux01.gwdg.de/~pbleser/ Solaris: (pkg)
   [225]http://www.sunfreeware.com/ FreeBSD: (.tbz)
   [226]http://www.freebsd.org/ [227]http://www.freshports.org/net/x11vnc
   OpenBSD: (.tgz) [228]http://www.openbsd.org/ NetBSD: (src)
   [229]http://pkgsrc.se/x11/x11vnc Nokia 770 (.deb)
   [230]http://mike.saunby.net/770/x11vnc/ Sharp Zaurus
   [231]http://www.pdaxrom.org/ and [232]http://www.focv.com/

   If the above binaries don't work and building x11vnc on your OS fails
   (and all else fails!) you can try one of [233]my collection of
   binaries for various OS's and x11vnc releases.

   As a general note, the x11vnc program is simple enough you don't
   really need to install a package: the binary will in most cases work
   as is and from any location (as long as your system libraries are not
   too old, etc). So, for Linux distributions that are not one of the
   above, the x11vnc binary from the above packages has a good chance of
   working. You can "install" it by just copying the x11vnc binary to the
   desired directory in your PATH. Tip on extracting files from a Debian
   package: extract the archive via a command like: "ar x
   x11vnc_0.6-2_i386.deb" and then you can find the binary in the
   resulting data.tar.gz tar file. Also, rpm2cpio(1) is useful in
   extracting files from rpm packages.


   Q-6: Where can I get a VNC Viewer binary (or source code) for the
   Operating System I will be viewing from?

   To obtain VNC viewers for the viewing side (Windows, Mac OS, or Unix)
   try here:
     * [234]http://www.tightvnc.com/download.html
     * [235]http://www.realvnc.com/download-free.html
     * [236]http://sourceforge.net/projects/cotvnc/
     * [237]http://www.ultravnc.com/


   Q-7: How can I see all of x11vnc's command line options and
   documentation on how to use them?

   Run:  x11vnc -opts   to list just the option names or run:  x11vnc
   -help   for long descriptions about each option. The output is listed
   [238]here as well.


   Q-8: I don't like typing arcane command line options every time I
   start x11vnc. What can I do? Is there a config file? Or a GUI?

   You could create a shell script that calls x11vnc with your options:
#!/bin/sh
#
# filename: X11vnc  (i.e. not "x11vnc")
# It resides in a directory in $PATH. "chmod 755 X11vnc" has been run on it.
#
x11vnc -wait 50 -localhost -rfbauth $HOME/.vnc/passwd -display :0 $*

   a similar thing can be done via aliases in your shell (bash, tcsh,
   csh, etc..).

   Or as of Jun/2004 you can use the simple $HOME/.x11vncrc config file
   support. If that file exists, each line is taken as a command line
   option. E.g. the above would be:
# this is a comment in my ~/.x11vncrc file
wait 50        # this is a comment to the end of the line.
-localhost     # note: the leading "-" is optional.
rfbauth  /home/fred/.vnc/passwd
display :0

   As of Dec/2004 there is now a simple Tcl/Tk GUI based on the
   remote-control functionality ("-R") that was added. The /usr/bin/wish
   program is needed for operation. The gui is not particularly
   user-friendly, it just provides a point and click mode to set all the
   many x11vnc parameters and obtain help on them. See the [239]-gui
   option for more info. Examples: "x11vnc ... -gui" and "x11vnc ... -gui
   other:0" in the latter case the gui is displayed on other:0, not the X
   display x11vnc is polling. There is also a "[240]-gui tray" system
   tray mode.


   Q-9: How can I get the GUI to run in the System Tray, or at least be a
   smaller, simpler icon?

   As of Jul/2005 the gui can run in a more friendly small icon mode
   "-gui icon" or in the system tray: "-gui tray". It has balloon status,
   a simple menu, and a Properities dialog. The full, complicated, gui is
   only available under "Advanced". Other improvements were added as
   well. Try "Misc -> simple_gui" for a gui with fewer esoteric menu
   items.

   If the gui fails to embed itself in the system tray, do a retry via
   "Window View -> icon" followed by "Window View -> tray" with the popup
   menu.

   For inexperienced users starting up x11vnc and the GUI while sitting
   at the physical X display (not remotely), using something like "x11vnc
   -display :0 -gui tray=setpass" might be something for them that they
   are accustomed to in a Desktop environment (it prompts for an initial
   password, etc). This is a basic "Share My Desktop" mode.


   Q-10: Can I make x11vnc more quiet and also go into the background
   after starting up?

   Use the [241]-q and [242]-bg options, respectively.  (also: -quiet is
   an alias for -q)

   Note that under -bg the stderr messages will be lost unless you use
   the "[243]-o logfile" option.


   Q-11: Sometimes when a VNC viewer dies abruptly, x11vnc also dies with
   the error message like: "Broken pipe". I'm using the -forever mode and
   I want x11vnc to keep running.

   As of Jan/2004 the SIGPIPE signal is ignored. So if a viewer client
   terminates abruptly, libvncserver will notice on the next I/O
   operation and will close the connection and continue on.

   Up until of Apr/2004 the above fix only works for BSD signal systems
   (Linux, FreeBSD, ...) For SYSV systems there is a workaround in place
   since about Jun/2004.


   Q-12: Are there any build-time customizations possible, e.g. change
   defaults, create a smaller binary, etc?

   There are some options. They are enabled by adding something like
   -Dxxxx=1 to the CPPFLAGS environment variable before running configure
   (see the [244]build notes for general background).
/*
 * Mar/2006
 * Build-time customization via CPPFLAGS.
 *
 * Summary of options to include in CPPFLAGS for custom builds:
 *
 * -DVNCSHARED  to have the vnc display shared by default.
 * -DFOREVER  to have -forever on by default.
 * -DNOREPEAT=0  to have -repeat on by default.
 * -DADDKEYSYMS=0  to have -noadd_keysyms the default.
 *
 * -DREMOTE_DEFAULT=0  to disable remote-control on by default (-yesremote).
 * -DREMOTE_CONTROL=0  to disable remote-control mechanism completely.
 * -DEXTERNAL_COMMANDS=0  to disable the running of all external commands.
 * -DFILEXFER=0  disable filexfer.
 *
 * -DHARDWIRE_PASSWD=...      hardwired passwords, quoting necessary.
 * -DHARDWIRE_VIEWPASSWD=...
 * -DNOPW=1                   make -nopw the default (skip warning)
 * -DUSEPW=1                  make -usepw the default
 * -DPASSWD_REQUIRED=1        exit unless a password is supplied.
 * -DPASSWD_UNLESS_NOPW=1     exit unless a password is supplied and no -nopw.
 *
 * -DWIREFRAME=0  to have -nowireframe as the default.
 * -DWIREFRAME_COPYRECT=0  to have -nowirecopyrect as the default.
 * -DWIREFRAME_PARMS=...   set default -wirecopyrect parameters.
 * -DSCROLL_COPYRECT=0     to have -noscrollcopyrect as the default.
 * -DSCROLL_COPYRECT_PARMS=...  set default -scrollcopyrect parameters.
 * -DSCALING_COPYRECT=0
 * -DXDAMAGE=0    to have -noxdamage as the default.
 * -DSKIPDUPS=0   to have -noskip_dups as the default or vice versa.
 *
 * -DPOINTER_MODE_DEFAULT={0,1,2,3,4}  set default -pointer_mode.
 * -DBOLDLY_CLOSE_DISPLAY=0  to not close X DISPLAY under -rawfb.
 * -DSMALL_FOOTPRINT=1  for smaller binary size (no help, no gui, etc)
 *                      use 2 or 3 for even smaller footprint.
 * -DNOGUI  do not include the gui tkx11vnc.
 * -DPOLL_8TO24_DELAY=N
 * -DDEBUG_XEVENTS=1  enable printout for X events.
 *
 * Set these in CPPFLAGS before running configure. E.g.:
 *
 *   % env CPPFLAGS="-DFOREVER -DREMOTE_CONTROL=0" ./configure
 *   % make
 */

   If other things (e.g. "-I ...") are needed in CPPFLAGS add them as
   well.

   On some systems is seems you need to set LC_ALL=C for configure to
   work properly...

   Be careful the following two variables: HARDWIRE_PASSWD and
   HARDWIRE_VIEWPASSWD. If set (remember to include the double quotes
   around the string), they will be used as default values for the
   -passwd and -viewpasswd options. Of course the strings will exist
   unobscured in the x11vnc: the binary better not be readable by
   unintendeds. Perhaps this is of use in remote access for an embedded
   application, etc...

   Let us know if more build-time customizations would be useful.


   [Win2VNC Related]

   Q-13: I have two separate machine displays in front of me, one Windows
   the other X11: can I use x11vnc in combination with Win2VNC in
   dual-screen mode to pass the keystrokes and mouse motions to the X11
   display?

   Yes, for best response start up x11vnc with the "[245]-nofb" option
   (disables framebuffer polling, and does other optimizations) on the
   secondary display (X11) machine. Then start up Win2VNC on the primary
   display (Windows) referring it to the secondary display.

   This will also work X11 to X11 using [246]x2vnc, however you would
   probably just want to avoid VNC and use x2x for that.

   For reference, here are some links to Win2VNC-like programs for
   multiple monitor setups:
     * [247]Original Win2VNC
     * [248]Enhanced Win2VNC and [249]sourceforge link
     * [250]x2vnc
     * [251]x2x also [252]here
     * [253]zvnc (MorphOS)

   All of them will work with x11vnc (except x2x where it is not needed).


   Q-14: I am running Win2VNC on my Windows machine and "x11vnc -nofb" on
   Unix to pass keyboard and mouse to the Unix monitor. Whenever I start
   Win2VNC it quickly disconnects and x11vnc says:
   rfbProcessClientNormalMessage: read: Connection reset by peer

   Is the default visual of the X display you run x11vnc on low color
   (e.g. 8 bit per pixel PseudoColor)? (you can run xdpyinfo to check,
   look in the "screen" section). There seems to be a bug in Win2VNC in
   that it cannot deal correctly with colormaps (PseudoColor is the most
   common example of a visual with a colormap).

   If so, there are a couple options. 1) Can you set the default visual
   on your display to be depth 24 TrueColor? Sun machines often have 8+24
   overlay/multi-depth visuals, and you can make the default visual depth
   24 TrueColor (see fbconfig(1) and Xsun(1)). 2) As of Feb/2004 x11vnc
   has the [254]-visual option to allow you to force the framebuffer
   visual to whatever you want (this usually messes up the colors unless
   you are very clever). In this case, the option provides a convenient
   workaround for the Win2VNC bug:
  x11vnc -nofb -visual TrueColor -display :0 ...

   So the visual will be set to 8bpp TrueColor and Win2VNC can handle
   this. Since Win2VNC does not use the framebuffer data there should be
   no problems in doing this.
   [Color Issues]

   Q-15: The X display I run x11vnc on is only 8 bits per pixel (bpp)
   PseudoColor (i.e. only 256 distinct colors). The x11vnc colors may
   start out OK, but after a while they are incorrect in certain windows.

   Use the [255]-flashcmap option to have x11vnc watch for changes in the
   colormap, and propagate those changes back to connected clients. This
   can be slow (since the whole screen must be updated over the network
   whenever the colormap changes). This flashing colormap behavior often
   happens if an application installs its own private colormap when the
   mouse is in its window. "netscape -install" is a well-known historical
   example of this. Consider reconfiguring the system to 16 bpp or depth
   24 TrueColor if at all possible.

   Also note the option [256]-8to24 (Jan/2006) can often remove the need
   for flashing the colormap. Everything is dynamically transformed to
   depth 24 at 32 bpp using the colormaps. There may be painting errors
   however (see the following FAQ for tips on reducing and correcting
   them).

   In some rare cases the [257]-notruecolor option has corrected colors
   on 8bpp displays. The red, green, and blue masks were non-zero in 8bpp
   PseudoColor on an obscure setup, and this option corrected the
   problems.


   Q-16: Color problems: Why are the colors for some windows incorrect in
   x11vnc? BTW, my X display has nice overlay/multi-depth visuals of
   different color depths: e.g. there are both depth 8 and 24 visuals
   available at the same time.

   You may want to review the [258]previous question regarding 8 bpp
   PseudoColor.

   On some hardware (Sun/SPARC and SGI), the [259]-overlay option
   discussed a couple paragraphs down may solve this for you (you may
   want to skip to it directly). On other hardware the less robust
   [260]-8to24 option may help (also discussed below).

   Run xdpyinfo(1) to see what the default visual is and what the depths
   of the other visuals are. Does the default visual have a depth of 8
   but there are other visuals of depth 24? If it does, can you possibly
   re-configure your X server to make a depth 24 visual the default? If
   you can do it, this will save you a lot of grief WRT colors and x11vnc
   (and for general usage too!). Here is how I do this on an old
   Sparcstation 20 running Solaris 9 with SX graphics
  xinit -- -dev /dev/fb defclass TrueColor defdepth 24

   and it works nicely (note: to log into console from the dtlogin
   window, select "Options -> Command Line Login", then login and enter
   the above command). See the -dev section of the Xsun(1) manpage for a
   description of the above arguments. If you have root permission, a
   more permanent and convenient thing to do is to record the arguments
   in a line like:
  :0  Local local_uid@console root /usr/openwin/bin/Xsun -dev /dev/fb defclass
TrueColor defdepth 24

   in /etc/dt/config/Xservers (copy /usr/dt/config/Xservers). Also look
   at the fbconfig(1) and related manpages (e.g. ffbconfig, m64config,
   pgxconfig, SUNWjfb_config, etc ...) for hardware framebuffer settings
   that may achieve the same effect.

   In general for non-Sun machines, look at the "-cc class" and related
   options in your X server manpage (perhaps Xserver(1)), it may allow
   modifying the default visual (e.g. "-cc 4", see <X11/X.h> for the
   visual class numbers). On XFree86 some video card drivers (e.g. Matrox
   mga) have settings like Option "Overlay" "24,8" to support multi-depth
   overlays. For these, use the "-cc 4" X server command line option to
   get a depth 24 default visual.


   The -overlay mode: Another option is if the system with overlay
   visuals is a Sun system running Solaris or SGI running IRIX you can
   use the [261]-overlay x11vnc option (Aug/2004) to have x11vnc use the
   Solaris XReadScreen(3X11) function to poll the "true view" of the
   whole screen at depth 24 TrueColor. XReadDisplay(3X11) is used on
   IRIX. This is useful for Legacy applications (older versions of
   Cadence CAD apps are mentioned by x11vnc users) that require the
   default depth be 8bpp, or the app will use a 8bpp visual even if depth
   24 visuals are available, and so the default depth workaround
   described in the previous paragraph is not sufficient for these apps.

   It seems that Xorg is working toward supporting XReadDisplay(3X11) as
   part of the RENDER extension work. When it does support it and
   provides a library API x11vnc will be modified to take advantage of
   the feature to support -overlay on Linux, *BSD, etc. Until then see
   the -8to24 mode below.

   Misc. notes on -overlay mode: An amusing by-product of -overlay mode
   is that the mouse cursor shape is correct! (i.e. XFIXES is not
   needed). The -overlay mode may be somewhat slower than normal mode due
   to the extra framebuffer manipulations that must be performed. Also,
   on Solaris there is a bug in that for some popup menus, the windows
   they overlap will have painting errors (flashing colors) while the
   popup is up (a workaround is to disable SaveUnders by passing -su to
   Xsun, e.g. in your /etc/dt/config/Xservers file).


   The -8to24 mode: The [262]-8to24 x11vnc option (Jan/2006) is a kludge
   to try to dynamically rewrite the pixel values so that the 8bpp part
   of the screen is mapped onto depth 24 TrueColor. This is less robust
   than the -overlay mode because it is done by x11vnc outside of the X
   server. So only use it on OS's that do not support -overlay. The
   -8to24 mode will work if the default visual is depth 24 or depth 8. It
   scans for any windows within 3 levels of the root window that are 8bpp
   (i.e. legacy application), or in general ones that are not using the
   default visual. For the windows it finds it uses XGetSubImage() to
   retrieve the pixels values and uses the correct indexed colormap to
   create a depth 24 TrueColor view of the whole screen. This depth 24,
   32bpp view is exported via VNC.

   Even on pure 8bpp displays it can be used as an alternative to
   [263]-flashcmap to avoid color flashing completely.

   This scheme is approximate and can often lead to painting errors. You
   can manually correct most painting errors by pressing 3 Alt_L's in a
   row, or by using something like: [264]-fixscreen V=3.0 to
   automatically refresh the screen every 3 seconds. Also -fixscreen
   8=3.0 has been added to just refresh the non-default visual parts of
   the screen.

   In general the scheme uses many resources and may give rise to
   sluggish behavior. If multiple windows are using different 8bpp
   indexed colormaps all but one window may need to be iconified for the
   colors to be correct. There are a number of tunable parameters to try
   to adjust performance and painting accuracy. The option -8to24
   nogetimage can give a nice speedup if the default depth 24 X server
   supports hiding the 8bpp bits in bits 25-32 of the framebuffer data.
   On very slow machines -8to24 poll=0.2,cachewin=5.0 gives an useful
   speedup. See the [265]-8to24 help description for information on
   tunable parameters, etc.


   Colors still not working correctly? Run xwininfo on the application
   with the incorrect colors to verify that the depth of its visual is
   different from the default visual depth (gotten from xdpyinfo). One
   possible workaround in this case is to use the [266]-id option to
   point x11vnc at the application window itself. If the application is
   complicated (lots of toplevel windows and popup menus) this may not be
   acceptable, and may even crash x11vnc (but not the application).

   It is theoretically possible to solve this problem in general (see
   xwd(1) for example), but it does not seem trivial or sufficiently fast
   for x11vnc to be able to do so in real time. The [267]-8to24 method
   does this approximately and is somewhat usable. Fortunately the
   [268]-overlay option works for Solaris machines with overlay visuals
   where most of this problem occurs.


   Q-17: How do I figure out the window id to supply to the -id windowid
   option?

   Run the xwininfo program in a terminal. It will ask you to click on
   the desired application window. After clicking, it will print out much
   information, including the window id (e.g. 0x6000010). Also, the
   visual and depth of the window printed out is often useful in
   debugging x11vnc [269]color problems.

   Also, as of Dec/2004 you can use "[270]-id pick" to have x11vnc run
   xwininfo(1) for you and after you click the window it extracts the
   windowid. Besides "pick" there is also "id:root" to allow you to go
   back to root window when doing remote-control.


   Q-18: Why don't menus or other transient windows come up when I am
   using the -id windowid option to view a single application window?

   This is related to the behavior of the XGetImage(3X11) and
   XShmGetImage() interfaces regarding backingstore, saveunders, etc. The
   way the image is retrieved depends on some aspects of how the X server
   maintains the display image data and whether other windows are
   clipping or obscuring it. See the XGetImage(3X11) man page for more
   details. If you disable BackingStore and SaveUnders in the X server
   you should be able to see these transient windows.

   If things are not working and you still want to do the single window
   polling, try the [271]-sid windowid option ("shifted" windowid).


   Q-19: My X display is depth 24 at 24bpp (instead of the normal depth
   24 at 32bpp). I'm having lots of color and visual problems with x11vnc
   and/or vncviewer. What's up?

   First off, depth 24 at 24bpp (bpp=bits-per-pixel) is fairly uncommon
   and can cause problems in general. It also can be slower than depth 24
   at 32bpp. You might want to switch to 32bpp (for XFree86 see the
   "-fbbpp 32", DefaultFbBpp, FbBpp and related options). Perhaps you
   have 24bpp because the video memory of the machine is low and the
   screen wouldn't fit in video RAM at 32bpp. For this case depth 16 at
   16bpp might be an acceptable option.

   In any event x11vnc should handle depth 24 at 24bpp (although
   performance may be slower). There are some caveats involving the
   viewer however:

   The RealVNC Unix viewer cannot handle 24bpp from the server, it will
   say: "main: setPF: not 8, 16 or 32 bpp?" and exit. I have not checked
   the RealVNC Windows viewer.

   So you need to use the TightVNC Unix viewer. However there are some
   problems with that too. It seems libvncserver does not do 24bpp
   correctly with the Tight encoding. The colors and screen ultimately
   get messed up. So you have to use a different encoding with the
   TightVNC vncviewer, try "zlib", "hextile", or one of the other
   encodings (e.g. vncviewer -encodings "zlib hextile" ...). I have not
   checked the TightVNC or UltraVNC Windows viewers.

   It appears the older RealVNC Unix viewers (e.g. 3.3.3 and 3.3.7) can
   handle 24bpp from the server, so you may want to use those. They
   evidently request 32 bpp and libvncserver obliges.

   Update: as of Apr/2006 you can use the [272]-24to32 option to have
   x11vnc dynamically transform the 24bpp pixel data to 32bpp. This extra
   transformation could slow things down further.

   Now coming the opposite direction if you are running the vncviewer on
   the 24bpp display, TightVNC will fail with "Can't cope with 24
   bits-per-pixel. Sorry." and RealVNC will fail with "main: Error:
   couldn't find suitable pixmap format" so evidently you cannot use
   24bpp for the vncviewers to work on that X display.
   [Xterminals]

   Q-20: Can I use x11vnc to view and interact with an Xterminal (e.g.
   NCD) that is not running UNIX and so x11vnc cannot be run on it
   directly?

   You can, but it will likely be very wasteful of network bandwidth
   since you will be polling the X display over the network as opposed to
   over the local hardware. To do this, run x11vnc on a UNIX machine as
   close as possible network-wise (e.g. same switch) to the Xterminal
   machine. Use the [273]-display option to point the display to that of
   the Xterminal (you'll of course need basic X11 permission to do that)
   and also supply the [274]-noshm option (this enables the polling over
   the network).

   The response will likely be sluggish (maybe only one "frame" per
   second). This mode is not recommended except for "quick checks" of
   hard to get to X servers. Use something like "-wait 150" to cut down
   on the polling rate. You may also need [275]-flipbyteorder if the
   colors get messed up due to endian byte order differences.

   Q-21: How do I get my X permissions (MIT-MAGIC-COOKIE file) correct
   for a Unix/Linux machine acting as an Xterminal?

   If the X display machine is a traditional Xterminal (where the X
   server process runs on the Xterminal box, but all of the X client
   applications (mozilla, etc) run on a central server (aka "terminal
   server")), you will need to log into the Xterminal machine (i.e. get a
   shell running there) and then start the x11vnc program. If the
   Xterminal Linux/Unix machine is stripped down (e.g. no users besides
   root) that may be difficult.

   The next problem is the login Display Manager (e.g. gdm, kdm), and
   hence the MIT-MAGIC-COOKIE auth files, are on the central server and
   not on the Xterminal box where the X server and x11vnc processes are.

   So unless X permissions are completely turned off (e.g. "xhost +"), to
   run the x11vnc process on the Xterminal box the MIT-MAGIC-COOKIE auth
   file data (XAUTHORITY or $HOME/.Xauthority) must be accessible by or
   copied to the Xterminal. If $HOME/.Xauthority is exported via NFS
   (this is insecure of course, but has been going on for decades), then
   x11vnc can simply pick it up via NFS (you may need to use the
   [276]-auth option to point to the correct file). Other options include
   copying the auth file using scp, or something like:
  central-server>  xauth nextract - xterm123:0 | ssh xterm123 xauth nmerge -

   and then, say, ssh from central-server to xterm123 to start x11vnc.
   Here "xterm123" refers to the computer acting as the Xterminal and
   "central-server" is the terminal server. You can use "xauth -f
   /path/to/cookie-file list" to examine the contents of the cookie(s) in
   a file "/path/to/cookie-file". See the xauth(1) manpage for more
   details.

   If the display name in the cookie file needs to be changed between the
   two hosts, see [277]this note on the "xauth add ..." command.

   A less secure option is to run something like "xhost +127.0.0.1" while
   sitting at the Xterminal box to allow cookie-free local access for
   x11vnc. You can run "xhost -127.0.0.1" after x11vnc connects if you
   want to go back to the original permissions.

   If the Xterminal is really stripped down and doesn't have any user
   accounts, NFS, etc. you'll need to contact your system administrator
   to set something up. It can be done!!!  Some Xterminal projects have
   actually enabled "run locally" facilities for the running of an
   occasional app more efficiently locally on the Xterminal box (e.g.
   realplayer).

   Not recommended, but as a last resort, you could have x11vnc [278]poll
   the Xterminal Display over the network. For this you would run a
   "x11vnc -noshm ..." process on the central-server (and hope the
   network admin doesn't get angry...)

   Note: use of Display Manager (gdm, kdm, ...) auth cookie files (i.e.
   from /var/...,  /tmp/..., or elsewhere) may require modification via
   xauth(1) to correctly include the display x11vnc refers to (e.g.
   "xauth -f cookie-file add :0 . 45be51ae2ce9dfbacd882ab3ef8e96b1",
   where the "45be51..." cookie value was found from an "xauth -f
   /path/to/original/cookie-file list") or other reasons. See xauth(1)
   manpage for full details on how to transfer an MIT-MAGIC-COOKIE
   between machines and displays.

   VNCviewer performance on Xterminals:  This isn't related to x11vnc on
   Xterminals, but we mention it here anyway because of the similar
   issues. If you are on an Xterminal and want to use vncviewer to
   connect to a VNC server somewhere, then performance would be best if
   you ran the viewer on the Xterminal box. Otherwise, (i.e. running the
   viewer process on the central-server) all of the vncviewer screen
   drawing is done more inefficiently over the network. Something to
   consider, especially on a busy network. (BTW, this has all of the
   above permission, etc, problems: both vncviewer and x11vnc are X
   client apps desired to be run on the Xterminal box).

   [Sun Rays]

   Q-22: I'm having trouble using x11vnc with my Sun Ray session.

   The [279]Sun Ray technology is a bit like "VNC done in hardware" (the
   Sun Ray terminal device, DTU, playing the role of the vncviewer).
   Completely independent of that, the SunRay user's session is still an
   X server that speaks the X11 protocol and so x11vnc simply talks to
   the X server part to export the SunRay desktop to any place in the
   world (i.e. not only to a Sun Ray terminal device), creating a sort of
   "Soft Ray". Please see [280]this discussion of Sun Ray issues for
   solutions to problems.

   [Remote Control]

   Q-23: How do I stop x11vnc once it is running in the background?

   As of Dec/2004 there is a remote control feature. It can change a huge
   amount of things on the fly: see the [281]-remote and [282]-query
   options. To shut down the running x11vnc server just type "x11vnc -R
   stop". To disconnect all clients do "x11vnc -R disconnect:all", etc.

   If the [283]-forever option has not been supplied, x11vnc will
   automatically exit after the first client disconnects. In general you
   will have to kill the x11vnc process This can be done via: "kill
   NNNNN" (where NNNNN is the x11vnc process id number found from ps(1)),
   or "pkill x11vnc", or "killall x11vnc" (Linux only).

   If you have not put x11vnc in the background via the [284]-bg option
   or shell & operator, then simply press Ctrl-C in the shell where
   x11vnc is running to stop it.

   Potential Gotcha: If somehow your Keypress of Ctrl-C went through
   x11vnc to the Xserver that then delivered it to x11vnc it is possible
   one or both of the Ctrl or C keys will be left stuck in the pressed
   down state in the Xserver. Tapping the stuck key (either via a new
   x11vnc or at the physical console) will release it from the stuck
   state. If the keyboard seems to be acting strangely it is often fixed
   by tapping Ctrl, Shift, and Alt. Alternatively, the [285]-clear_mods
   option and [286]-clear_keys option can be used to release pressed keys
   at startup and exit.


   Q-24: Can I change settings in x11vnc without having to restart it?
   Can I remote control it?

   Look at the [287]-remote (same as -R) and [288]-query (same as -Q)
   options added in Dec/2004. They allow nearly everything to be changed
   dynamically and settings to be queried. Examples: "x11vnc -R shared",
   "x11vnc -R forever", "x11vnc -R scale:3/4", "x11vnc -Q modtweak",
   "x11vnc -R stop", "x11vnc -R disconnect:all", etc.. These commands do
   not start a x11vnc server, but rather communicate with one that is
   already running. The X display (X11VNC_REMOTE property) is used as the
   communication channel, so the X permissions and DISPLAY must be set up
   correctly for communication to be possible.

   There is also a simple Tcl/Tk gui based on this remote control
   mechanism. See the [289]-gui option for more info. You will need to
   have Tcl/Tk (i.e. /usr/bin/wish) installed for it to work. It can also
   run in the system tray: "-gui tray" or as a standalone icon window:
   "-gui icon".

   [Security and Permissions]

   Q-25: How do I create a VNC password for use with x11vnc?

   You may already have one in $HOME/.vnc/passwd if you have used, say,
   the vncserver program from the regular RealVNC or TightVNC packages
   (i.e. launching the Xvnc server). Otherwise, you could use the
   vncpasswd(1) program from those packages.

   As of Jun/2004 x11vnc supports the -storepasswd "pass" "file"
   [290]option, which is the same functionality of storepasswd. Be sure
   to quote the "pass" if it contains shell meta characters, spaces, etc.
   Example:
  x11vnc -storepasswd 'sword*fish' $HOME/myvncpasswd

   You then use the password via the x11vnc option: "[291]-rfbauth
   $HOME/myvncpasswd"

   If you do not supply any arguments:
  x11vnc -storepasswd

   you will be prompted for a password to save to ~/.vnc/passwd (your
   keystrokes when entering the password will not be echoed to the
   screen). If you supply one argument, e.g. "x11vnc -storepasswd
   ~/.mypass", the password you are prompted for will be stored in that
   file.

   x11vnc also has the [292]-passwdfile and -passwd/-viewpasswd plain
   text (i.e. not obscured like the -rfbauth VNC passwords) password
   options.

   You can use the [293]-usepw option to automatically use any password
   file you have in ~/.vnc/passwd or ~/.vnc/passwdfile (the latter is
   used with the -passwdfile option).

  x11vnc -usepw -display :0 ...

   If neither file exists you are prompted to store a password in
   ~/.vnc/passwd. If a password file cannot be found or created x11vnc
   exits immediately.


   Q-26: Can I make it so -storepasswd doesn't show my password on the
   screen?

   You can use the vncpasswd program from RealVNC or TightVNC mentioned
   above. As of Jan/2006 the -storepasswd option without any arguments
   will not echo your password as you type it and save the file to
   ~/.vnc/passwd:
  # x11vnc -storepasswd
  Enter VNC password:
  Verify password:
  Write password to /home/myname/.vnc/passwd?  [y]/n
  Password written to: /home/myname/.vnc/passwd

   You can also give it an alternate filename, e.g. "x11vnc -storepasswd
   ~/.mypass"


   Q-27: Can I have two passwords for VNC viewers, one for full access
   and the other for view-only access to the display?

   Yes, as of May/2004 there is the [294]-viewpasswd option to supply the
   view-only password. Note the full-access password option [295]-passwd
   must be supplied at the same time. E.g.: -passwd sword -viewpasswd
   fish.

   To avoid specifying the passwords on the command line (where they
   could be observed via the ps(1) command by any user) you can use the
   [296]-passwdfile option to specify a file containing plain text
   passwords. Presumably this file is readable only by you, and ideally
   it is located on the machine x11vnc is run on (to avoid being snooped
   on over the network). The first line of this file is the full-access
   password. If there is a second line in the file and it is non-blank,
   it is taken as the view-only password. (use "__EMPTY__" to supply an
   empty one).

   View-only passwords currently do not work for the [297]-rfbauth
   password option (standard VNC password storing mechanism). FWIW, note
   that although the output (usually placed in $HOME/.vnc/passwd) by the
   vncpasswd or storepasswd programs (or from x11vnc -storepasswd) looks
   encrypted they are really just obscured to avoid "casual" password
   stealing. It takes almost no skill to figure out how to extract the
   plain text passwords from $HOME/.vnc/passwd since it is very
   straight-forward to work out what to do from the VNC source code.


   Q-28: Can I have as many full-access and view-only passwords as I
   like?

   Yes, as of Jan/2006 in the libvncserver CVS the [298]-passwdfile
   option has been extended to handle as many passwords as you like. You
   put the view-only passwords after a line __BEGIN_VIEWONLY__.

   You can also easily annotate and comment out passwords in the file.
   You can have x11vnc re-read the file dynamically when it is modified.


   Q-29: Does x11vnc support Unix usernames and passwords? Can I further
   limit the set of Unix usernames who can connect to the VNC desktop?

   Until the VNC protocol and libvncserver support this things will be
   approximate at best.

   Update: as of Feb/2006 x11vnc has the [299]-unixpw option that does
   this outside of the VNC protocol and libvncserver. The standard su(1)
   program is used to validate the user's password. A familiar "login:"
   and "Password:" dialog is presented to the user on a black screen
   inside the vncviewer. The connection is dropped if the user fails to
   supply the correct password in 3 tries or does not send one before a
   25 second timeout. Existing clients are view-only during this period.
   A list of allowed Unix usernames may also be supplied along with
   per-user settings.

   There is also the [300]-unixpw_nis option for non-shadow-password
   (typically NIS environments, hence the name) systems where the
   traditional getpwnam() and crypt() functions are used instead of
   su(1). The encrypted user passwords must be accessible to the user
   running x11vnc in -unixpw_nis mode, otherwise the logins will always
   fail even when the correct password is supplied. See ypcat(1) and
   shadow(5).

   Two settings are enforced in the -unixpw and -unixpw_nis modes to
   provide extra security: the 1) [301]-localhost and 2) [302]-stunnel
   options. Without these one might send the Unix username and password
   data in clear text over the network which is a very bad idea. They can
   be relaxed if you want to provide encryption other than stunnel (the
   stunnel constraint is automatically relaxed if SSH_CONNECTION is set
   and indicates you have ssh-ed in, however the -localhost requirement
   is still enforced).

   The two -unixpw modes have been tested on Linux, Solaris, HP-UX,
   Tru64, FreeBSD, OpenBSD, and NetBSD. Additional testing is
   appreciated. For the last 4 it appears that su(1) will not prompt for
   a password if su-ing to oneself. Since x11vnc requires a password
   prompt from su, those logins will fail even when the correct password
   is supplied. On *BSD it appears this can be corrected by commenting
   out the pam_self.so entry in /etc/pam.d/su.


   Previous discussion: One approximate method involves starting x11vnc
   with the [303]-localhost option. This basically requires the viewer
   user to log into the workstation where x11vnc is running via their
   Unix username and password, and then somehow set up a port redirection
   of his vncviewer connection to make it appear to emanate from the
   local machine. As discussed above, ssh is useful for this: "ssh -L
   5900:localhost:5900 user@hostname ..." See the ssh wrapper scripts
   mentioned [304]elsewhere on this page. [305]stunnel does this as well.

   Of course a malicious user could allow other users to get in through
   his channel, but that is a problem with every method. Another thing to
   watch out for is a malicious user on the viewer side (where ssh is
   running) trying to sneak in through the ssh port redirection there.

   Regarding limiting the set of Unix usernames who can connect, the
   traditional way would be to further require a VNC password to supplied
   (-rfbauth, -passwd, etc) and only tell the people allowed in what the
   VNC password is. A scheme that avoids a second password involves using
   the [306]-accept option that runs a program to examine the connection
   information to determine which user is connecting from the local
   machine. That may be difficult to do, but, for example, the program
   could use the ident service on the local machine (normally ident
   should not be trusted over the network, but on the local machine it
   should be accurate: otherwise root has been compromised and so there
   are more serious problems! Unfortunately recent Linux distros seem to
   provide a random string (MD5 hash?) instead of the username). An
   example script passed in via -accept scriptname that deduces the Unix
   username and limits who can be accepted might look something like
   this:
#!/bin/sh
if [ "$RFB_CLIENT_IP" != "127.0.0.1" -o "$RFB_SERVER_IP" != "127.0.0.1" ]; then
        exit 1  # something fishy... reject it.
fi
user=`echo "$RFB_CLIENT_PORT, $RFB_SERVER_PORT" | nc -w 1 $RFB_CLIENT_IP 113 \
        | grep 'USERID.*UNIX' | head -1 | sed -e 's/[\r ]//g' | awk -F: '{print
 $4}'`

for okuser in fred barney wilma betty
do
        if [ "X$user" = "X$okuser" ]; then
                exit 0  # accept it
        fi
done
exit 1  # reject it

   For this to work with ssh port redirection, the ssh option
   UsePrivilegeSeparation must be enabled otherwise the userid will
   always be "root".



   Q-30: Why does x11vnc exit as soon as the VNC viewer disconnects? And
   why doesn't it allow more than one VNC viewer to connect at the same
   time?

   These defaults are simple safety measures to avoid someone unknowingly
   leaving his X11 desktop exposed (to the internet, say) for long
   periods of time. Use the [307]-forever option (aka -many) to have
   x11vnc wait for more connections after the first client disconnects.
   Use the [308]-shared option to have x11vnc allow multiple clients to
   connect simultaneously.

   Recommended additional safety measures include using ssh ([309]see
   above), stunnel, or a VPN to authenticate and encrypt the viewer
   connections or to at least use the -rfbauth passwd-file [310]option to
   use VNC password protection (or [311]-passwdfile) It is up to YOU to
   apply these security measures, they will not be done for you
   automatically.


   Q-31: Can I limit which machines incoming VNC clients can connect
   from?

   Yes, look at the [312]-allow and [313]-localhost options to limit
   connections by hostname or IP address. E.g.
  x11vnc -allow 192.168.0.1,192.168.0.2

   for those two hosts or
  x11vnc -allow 192.168.0.

   for a subnet. For individual hosts you can use the hostname instead of
   the IP number, e.g.: "-allow snoopy", and "-allow darkstar,wombat".
   Note that -localhost is the same as "-allow 127.0.0.1"

   For more control, build libvncserver with libwrap support
   [314](tcp_wrappers) and then use /etc/hosts.allow See hosts_access(5)
   for complete details.


   Q-32: How do I build x11vnc/libvncserver with libwrap (tcp_wrappers)
   support?

   Here is one way to pass this information to the configure script:
  env CPPFLAGS=-DUSE_LIBWRAP LDFLAGS=-lwrap ./configure

   then run make as usual. This requires libwrap and its development
   package (tcpd.h) to be installed on the build machine. If additional
   CPPFLAGS or LDFLAGS options are needed supply them as well using
   quotes.

   The resulting x11vnc then uses libwrap/tcp_wrappers for connections.
   The service name you will use in /etc/hosts.allow and /etc/hosts.deny
   is "vnc", e.g.:
  vnc: 192.168.100.3 .example.com

   Note that if you run x11vnc out of [315]inetd you do not need to build
   x11vnc with libwrap support because the /usr/sbin/tcpd reference in
   /etc/inetd.conf handles the tcp_wrappers stuff.


   Q-33: Can I have x11vnc only listen on one network interface (e.g.
   internal LAN) rather than having it listen on all network interfaces
   and relying on -allow to filter unwanted connections out?

   As of Mar/2005 there is the "[316]-listen ipaddr" option that enables
   this. For ipaddr either supply the desired network interface's IP
   address (or use a hostname that resolves to it) or use the string
   "localhost". For additional filtering simultaneously use the
   "[317]-allow host1,..." option to allow only specific hosts in.

   This option is useful if you want to insure that no one can even begin
   a dialog with x11vnc from untrusted network interfaces (e.g. ppp0).
   The option [318]-localhost now implies "-listen localhost" since that
   is what most people expect it to do.


   Q-34: Now that -localhost implies listening only on the loopback
   interface, how I can occasionally allow in a non-localhost via the -R
   allowonce remote control command?

   To do this specify "[319]-allow localhost". Unlike [320]-localhost
   this will leave x11vnc listening on all interfaces (but of course only
   allowing in local connections, e.g. ssh redirs). Then you can later
   run "x11vnc -R allowonce:somehost" or use to gui to permit a one-shot
   connection from a remote host.

   Note that if you do a lot of changing of the listening interface
   ([321]-listen option) via remote control or gui, you may need to also
   manually adjust the [322]-allow list if you unexpectedly get into a
   state where the allow list cannot match any hosts that would be coming
   in on the listening interface. If you just toggle [323]-localhost on
   and off x11vnc should see to it that you never get into such a state.


   Q-35: Can I fine tune what types of user input are allowed? E.g. have
   some users just be able to move the mouse, but not click or type
   anything?

   As of Feb/2005, the [324]-input option allows you to do this. "K",
   "M", and "B" stand for Keystroke, Mouse-motion, and Button-clicks,
   respectively. The setting: "-input M" makes attached viewers only able
   to move the mouse. "-input KMB,M" lets normal clients do everything
   and enables view-only clients to move the mouse.

   These settings can also be applied on a per-viewer basis via the
   remote control mechanism or the GUI. E.g. x11vnc -R input:hostname:M


   Q-36: Can I prompt the user at the local X display whether the
   incoming VNC client should be accepted or not? Can I decide to make
   some clients view-only? How about running an arbitrary program to make
   the decisions?

   Yes, look at the "[325]-accept command" option, it allows you to
   specify an external command that is run for each new client. (use
   quotes around the command if it contains spaces, etc.). If the
   external command returns 0 the client is accepted, otherwise the
   client is rejected. See below how to also accept clients view-only.

   The external command will have the RFB_CLIENT_IP environment variable
   set to the client's numerical IP address, RFB_CLIENT_PORT its port
   number. Similarly for RFB_SERVER_IP and RFB_SERVER_PORT to allow
   identification of the tcp virtual circuit. DISPLAY will be set to that
   of the X11 display being polled. Also, RFB_X11VNC_PID is set to the
   x11vnc process id (e.g. in case you decided to kill it), RFB_CLIENT_ID
   will be an id number, and RFB_CLIENT_COUNT the number of other clients
   currently connected. RFB_MODE will be "accept".

   As a special case, "-accept popup" will instruct x11vnc to create its
   own simple popup window. To accept the client press "y" or click mouse
   on the "Yes" button. To reject the client press "n" or click mouse on
   the "No" button. To accept the client View-only, press "v" or click
   mouse on the "View" button. If the [326]-viewonly option has been
   supplied, the "View" action will not be present: the whole display is
   view only in that case.

   The popup window times out after 120 seconds, to change this behavior
   use "-accept popup:N" where N is the number of seconds (use 0 for no
   timeout). More tricks: "-accept popupmouse" will only take mouse click
   responses, while "-accept popupkey" will only take keystroke responses
   (popup takes both). After any of the 3 popup keywords you can supply a
   position of the window: +N+M, (the default is to center the window)
   e.g. -accept popupmouse+10+10.

   Also as a special case "-accept xmessage" will run the xmessage(1)
   program to prompt the user whether the client should be accepted or
   not. This requires that you have xmessage installed and available via
   PATH. In case it is not already on your system, the xmessage program
   is available at [327]ftp://ftp.x.org/

   To include view-only decisions for the external commands, prefix the
   command something like this: "yes:0,no:*,view:3 mycommand ..." This
   associates the three actions: yes(accept), no(reject), and
   view(accept-view-only), with the numerical return codes. Use "*"
   instead of a number to set the default action (e.g. in case the
   external command returns an unexpected return code).

   Here is an example -accept script called accept_or_lock. It uses
   xmessage and xlock (replace with your screen lock command, maybe it is
   "xscreensaver-command -lock", or kdesktop_lock, or "dtaction
   LockDisplay"). It will prompt the user at the X display whether to
   accept, reject, or accept view-only the client, but if the prompt
   times out after 60 seconds the screen is locked and the VNC client is
   accepted. This allows the remote access when no one is at the display.
#!/bin/sh
#
# accept_or_lock: prompt user at X display whether to accept an incoming
#                 VNC connection.  If timeout expires, screen is locked
#                 and the VNC viewer is accepted (allows remote access
#                 when no one is sitting at the display).
#
# usage: x11vnc ... -forever -accept 'yes:0,no:*,view:4 accept_or_lock'
#
xmessage -buttons yes:2,no:3,view-only:4 -center \
         -timeout 60 "x11vnc: accept connection from $RFB_CLIENT_IP?"
rc=$?
if [ $rc = 0 ]; then
        xlock &
        sleep 5
        exit 0
elif [ $rc = 2 ]; then
        exit 0
elif [ $rc = 4 ]; then
        exit 4
fi
exit 1

   Stefan Radman has written a nice dtksh script [328]dtVncPopup for use
   in CDE environments to do the same sort of thing. Information on how
   to use it is found at the top of the file. He encourages you to
   provide feedback to him to help improve the script.

   Note that in all cases x11vnc will block while the external command or
   popup is being run, so attached clients will not receive screen
   updates, etc during this period.

   To run a command when a client disconnects, use the "[329]-gone
   command" option. This is for the user's convenience only: the return
   code of the command is not interpreted by x11vnc. The same environment
   variables are set as in "-accept command" (except that RFB_MODE will
   be "gone").


   Q-37: I start x11vnc as root because it is launched via inetd(8) or a
   display manager like gdm(1). Can I have x11vnc later switch to a
   different user?

   As of Feb/2005 x11vnc has the [330]-users option that allows things
   like this. Please read the documentation on it (also in the x11vnc
   -help output) carefully for features and caveats. It's use can often
   decrease security unless care is taken.

   BTW, a nice use of it is "-users +nobody" that switches to the Unix
   user nobody right after connections to the X display are established.

   In any event, while running x11vnc as root, remember it comes with no
   warranty ;-).


   Q-38: I use a screen-lock when I leave my workstation (e.g.
   xscreensaver or xlock). When I remotely access my workstation desktop
   via x11vnc I can unlock the desktop fine, but I am worried people will
   see my activities on the physical monitor. What can I do to prevent
   this, or at least make it more difficult?

   Probably most work environments would respect your privacy if you
   powered off the monitor. Also remember if people have physical access
   to your workstation they basically can do anything they want with it
   (e.g. install a backdoor for later use, etc).

   In any event, as of Jun/2004 there is an experimental utility to make
   it more difficult for nosey people to see your x11vnc activities. The
   source for it is [331]blockdpy.c The idea behind it is simple (but
   obviously not bulletproof): when a VNC client attaches to x11vnc put
   the display monitor in the DPMS "off" state, if the DPMS state ever
   changes immediately start up the screen-lock program. The x11vnc user
   will notice something is happening and think about what to do next
   (while the screen is in a locked state).

   This works (or at least has a chance of working) because if the
   intruder moves the mouse or presses a key on the keyboard, the monitor
   wakes up out of the DPMS off state, and this induces the screen lock
   program to activate as soon as possible. Of course there are cracks in
   this, the eavesdropper could detach your monitor and insert a non-DPMS
   one, and there are race conditions. As mentioned above this is not
   bulletproof. A really robust solution would likely require X server
   and perhaps even video hardware support.

   The blockdpy utility is launched by the [332]-accept option and told
   to exit via the [333]-gone option (the vnc client user should
   obviously re-lock the screen before disconnecting!). Instructions can
   be found in the source code for the utility at the above link.


   Q-39: Can I have x11vnc automatically lock the screen when I
   disconnect the VNC viewer?

   Yes, a user mentions he uses the [334]-gone option under CDE to run a
   screen lock program:
  x11vnc -display :0 -forever -gone 'dtaction LockDisplay'

   Other possibilities are:
  x11vnc -display :0 -forever -gone 'xscreensaver-command -lock'
  x11vnc -display :0 -forever -gone 'kdesktop_lock'
  x11vnc -display :0 -forever -gone 'xlock &'

   Here is a scheme using the [335]-afteraccept option (in version 0.7.3)
   to unlock the screen after the first valid VNC login and to lock the
   screen after the last valid VNC login disconnects:
  x11vnc -display :0 -forever -shared -afteraccept ./myxlocker -gone ./myxlocke
r

   Where the script ./myxlocker is:
#!/bin/sh

#/usr/bin/env | grep RFB_ | sort        # for viewing RFB_* settings.

if [ "X$RFB_MODE" = "Xafteraccept" ]; then
        if [ "X$RFB_STATE" = "XNORMAL" ]; then  # require valid login
                if [ "X$RFB_CLIENT_COUNT" = "X1" ]; then
                        killall xlock   # Linux only.
                fi
        fi
elif [ "X$RFB_MODE" = "Xgone" ]; then
        if [ "X$RFB_STATE" = "XNORMAL" ]; then  # require valid login
                if [ "X$RFB_CLIENT_COUNT" = "X0" ]; then
                        xlock -mode blank &
                fi
        fi
fi


   [Encrypted Connections]

   Q-40: How can I tunnel my connection to x11vnc via an encrypted SSH
   channel between two Unix machines?

   See the description earlier on this page on [336]how to tunnel VNC via
   SSH from Unix to Unix. A number of ways are described along with some
   issues you may encounter.

   Other secure encrypted methods exists, e.g. stunnel, IPSEC, various
   VPNs, etc.


   Q-41: How can I tunnel my connection to x11vnc via an encrypted SSH
   channel from Windows using an SSH client like Putty?

   [337]Above we described how to tunnel VNC via SSH from Unix to Unix,
   you may want to review it. To do this from Windows using Putty it
   would go something like this:
     * In the Putty dialog window under 'Session' enter the hostname or
       IP number of the Unix machine with display to be viewed.
     * Make sure the SSH protocol is selected and the server port is
       correct.
     * Under 'Connections/SSH/Tunnels' Add a Local connection with
       'Source port:  5900' and 'Destination:  localhost:5900'
     * Log into the remote machine by pressing 'Open' and supplying
       username, password, etc.
     * In that SSH shell, start up x11vnc by typing the command: x11vnc
       -display :0 plus any other desired options (e.g. -localhost).
     * Finally, start up your VNC Viewer in Windows and enter
       'localhost:0' as the VNC server.

   You can keep all of the settings in a Putty 'Saved Session'. Also,
   once everything is working, you can consider putting x11vnc -display
   :0 (plus other cmdline options) in the 'Remote command' Putty setting
   under 'Connections/SSH'. It is likely possible to script the whole
   process in a BAT file including launching the VNC viewer by using the
   plink Putty utility. Send us the script if you get that working.

   For extra protection feel free to run x11vnc with the [338]-localhost
   and [339]-rfbauth/[340]-passwdfile options.

   If the machine you SSH into via Putty is not the same machine with the
   X display you wish to view (e.g. your company provides incoming SSH
   access to a gateway machine), then you need to change the above Putty
   dialog setting to: 'Destination: otherhost:5900', Once logged in,
   you'll need to do a second login (ssh or rsh) to the workstation
   machine 'otherhost' and then start up x11vnc on it. This can also be
   automated by [341]chaining ssh's.

   As discussed [342]above another option is to first start the VNC
   viewer in "listen" mode, and then launch x11vnc with the
   "[343]-connect localhost" option to establish the reverse connection.
   In this case a Remote port redirection (not Local) is needed for port
   5500 instead of 5900 (i.e. 'Source port:  5500' and
   'Destination:  localhost:5500' for a Remote connection).


   Q-42: How can I tunnel my connection to x11vnc via an encrypted SSL
   channel using an external tool like stunnel?

   It is possible to use a "lighter weight" encryption setup than SSH or
   IPSEC. SSL tunnels such as [344]stunnel provide an encrypted channel
   without the need for Unix users, passwords, and key passphrases
   required for ssh (and at the other extreme can also provide a complete
   signed certificate chain of trust). OTOH, since SSH is usually
   installed everywhere and firewalls often let its port through, ssh is
   frequently the path of least resistance (it also nicely manages public
   keys for you).

   Update: As of Feb/2006 x11vnc has the options [345]-ssl,
   [346]-stunnel, and [347]-sslverify to provide integrated SSL schemes.
   They are discussed [348]in the Next FAQ (you may want to skip to it
   now).

   Here are some basic examples using [349]stunnel but the general idea
   for any SSL tunnel utility is the same:
     * Start up x11vnc and constrain it to listen on localhost.
     * Then start up the SSL tunnel running on the same machine to
       forward incoming connections to that x11vnc.
     * Set up and run a similar SSL tunnel for the outgoing connection on
       the VNC viewer machine pointing it to the SSL/x11vnc server.
     * Optionally, set up server (or even client) public/private keys for
       use in authenticating one side to the other.
     * Finally, start the VNC Viewer and tell it to connect to the local
       port (e.g. a vnc display localhost:0) where its outgoing SSL
       tunnel is listening.

   We'll first use the stunnel version 3 syntax since it is the most
   concise and Unixy.

   Start up x11vnc listening on port 5900:
  x11vnc -display :0 -rfbport 5900 -localhost -bg -passwdfile ~/mypass

   Then start stunnel (version 3) with this command:
  stunnel -d 5901 -r 5900 -p /path/to/stunnel.pem

   The above two commands are run on host "far-away.east". The
   stunnel.pem is the self-signed PEM file certificate created when
   stunnel is built. One can also create certificates [350]signed by
   Certificate Authorities or self-signed if desired using the x11vnc
   utilities described there.

   Next, on the VNC viewer side we need an SSL tunnel to encrypt the
   outgoing connection. The nice thing is any SSL tunnel can be used
   because the protocol is a standard. For this example we'll also use
   stunnel on the viewer side on Unix. First start up the client-side
   stunnel:
  stunnel -c -d localhost:5902 -r far-away.east:5901

   Then point the viewer to the local tunnel on port 5902:
  vncviewer -encodings "copyrect tight zrle hextile" localhost:2

   That's it.  (note that the [351]ssl_vncviewer script can automate
   this.)

   Be sure to use a VNC password because unlike ssh by default the
   encrypted SSL channel provides no authentication (only privacy). With
   some extra configuration one could also set up certificates to provide
   authentication of either or both sides as well (and hence avoid
   man-in-the-middle attacks). See the stunnel and openssl documentation
   and also [352]the key management section for details.

   stunnel has also been ported to Windows, and there are likely others
   to choose from for that OS. Much info for using it on Windows can be
   found at the stunnel site and in this [353]article The article also
   shows the detailed steps to set up all the authentication
   certificates. (for both server and clients, see also the [354]x11vnc
   utilities that do this). The default Windows client setup (no certs)
   is simpler and only 4 files are needed in a folder: stunnel.exe,
   stunnel.conf, libssl32.dll, libeay32.dll. We used an stunnel.conf
   containing:
# stunnel.conf:
client = yes
options = ALL
[myvncssl]
accept = 5902
connect = far-away.east:5901

   then double click on the stunnel.exe icon to launch it (followed by
   pointing the VNC viewer to localhost:2).


   stunnel inetd-like mode:

   As an aside, if you don't like the little "gap" of unencrypted TCP
   traffic (and a localhost listening socket) on the local machine
   between stunnel and x11vnc it can actually be closed by having stunnel
   start up x11vnc in [355]-inetd mode:
  stunnel -p /path/to/stunnel.pem -P none -d 5900 -l ./x11vnc_sh

   Where the script x11vnc_sh starts up x11vnc:
#!/bin/sh
x11vnc -q -inetd -display :0 -passwdfile ~/mypass

   Note that this creates a separate x11vnc process for each incoming
   connection (as any inetd x11vnc usage would), but for the case of
   normally just one viewer at a time it should not be a big problem.


   stunnel 4 syntax:

   Somewhat sadly, the stunnel version 4 syntax is not so amenable to the
   command line or scripts. You need to create a config file with the
   parameters. E.g.:
  stunnel x11vnc.cfg

   Where the file x11vnc.cfg contains:
foreground = yes
pid =
cert = /path/to/stunnel.pem
[x11vnc_stunnel]
accept  = 5901
connect = 5900

   One nice thing about version 4 is often the PEM file does not need to
   be specified because stunnel finds it in its installed area. One other
   gotcha the PEM file is usually only readable by root (it has the
   private key afterall), so you'll need to relax the permissions or make
   a copy that the user running x11vnc/stunnel can read.


   SSL VNC Viewers:

   Regarding VNC viewers that "natively" do SSL unfortunately there do
   not seem to be many. UltraVNC has encryption plugin, but we have not
   tried it (it does not seem to be SSL). Commercial versions of VNC seem
   to have some SSL built in, but we haven't tried those either and they
   probably wouldn't work since the SSL negotiation is likely embedded in
   the VNC protocol unlike our case where it is external.

   Note: as of Mar/2006 libvncserver/x11vnc provides a [356]SSL-enabled
   Java applet that can be served up via the [357]-httpdir or [358]-http
   options when [359]-ssl is enabled. It will also be served via HTTPS
   via either the VNC port (e.g. https://host:5900/) or a 2nd port via
   the [360]-https option.

   In general current SSL VNC solutions are not particularly "seemless".
   But it can be done, and with a wrapper script on the viewer side and
   the [361]-stunnel option on the server side it works well and is
   convenient. Here is a simple script [362]ssl_vncviewer that automates
   running stunnel on the VNC viewer side on Unix a little more carefully
   than the commands printed above. (One could probably do a similar
   thing with a .BAT file on Windows in the stunnel folder.)


   Q-43: Does x11vnc have built-in SSL tunneling?

   You can read about non-built-in methods [363]in the Previous FAQ

   SSL tunnels provide an encrypted channel without the need for Unix
   users, passwords, and key passphrases required for ssh (and at the
   other extreme can also provide a complete signed certificate chain of
   trust). OTOH, since SSH is usually installed everywhere and firewalls
   often let its port through, ssh is frequently the path of least
   resistance.

   Built-in SSL x11vnc options:

   As of Feb/2006 the x11vnc [364]-ssl and [365]-stunnel options automate
   the SSL tunnel creation on the x11vnc server side. An [366]SSL-enabled
   Java Viewer applet is also provided that can be served via http or
   https to automate SSL on the client side.

   The [367]-ssl mode uses the [368]www.openssl.org library if available
   at build time. The [369]-stunnel mode requires the
   [370]www.stunnel.org command stunnel(8) to be installed on the system.

   Both modes require an SSL certificate and key (i.e. .pem file). These
   are usually created via the openssl(1) (in fact in for options "-ssl"
   or "-stunnel SAVE" it will run openssl for you automatically). So the
   SSL is not completely "built-in" since these external tools need to be
   installed, but at least x11vnc runs them for you automatically.

   An -stunnel example:
  x11vnc -display :0 -stunnel /path/to/stunnel.pem -passwdfile ~/mypass

   You'll get output like this:
  The VNC desktop is:      localhost:50
  The SSL VNC desktop is:  far-away.east:0
  PORT=5950
  SSLPORT=5900

   That indicates stunnel is listening on port 5900 for incoming
   SSL-wrapped VNC connections from viewers. x11vnc is listening for
   local connections on port 5950 in this case (remote viewers cannot
   connect to it directly). For -stunnel to work the stunnel command must
   be installed on the machine and available in PATH (note stunnel is
   often installed in sbin directories rather than bin).

   An -ssl example:
  x11vnc -display :0 -ssl -passwdfile ~/mypass

   You'll get output like this:
  09/04/2006 19:27:35 Creating a temporary, self-signed PEM certificate...
  09/04/2006 19:27:35
  ...

  The SSL VNC desktop is:  far-away.east:0
  PORT=5900
  SSLPORT=5900

   In this case openssl(1) was used to create a temporary PEM
   automatically.


   As seen above, the PEM (privacy enhanced mail) file does not need to
   be supplied if the openssl(1) command is available in PATH, in that
   case a self-signed, temporary certificate good only for the single
   x11vnc session is created (this may take a while on very slow
   machines).

   In general, the PEM file contains both the Certificate (i.e. public
   key) and the Private Key. Because of the latter, the file should be
   protected from being read by untrusted users. The best way to do this
   is to encrypt the key with a passphrase (note however this requires
   supplying the passphrase each time x11vnc is started up).

   See the discussion on [371]x11vnc Key Management for some utilities
   provided for creating and managing certificates and keys and even for
   creating your own Certificate Authority (CA) for signing VNC server
   and client certificates. This may be done by importing the certificate
   into Web Browser or Java plugin keystores, or pointing stunnel to it.
   The wrapper script [372]ssl_vncviewer provides an example on unix
   (-verify option).

   Here are some notes on the simpler default (non-CA) operation. To have
   x11vnc save the generated certificate and key, use the "SAVE" keyword
   like this:
  x11vnc -ssl SAVE -display :0 ...

  x11vnc -stunnel SAVE -display :0 ...

   This way it will be saved in the default directory ~/.vnc/certs/ as
   server.crt (the certificate only) and server.pem (both certificate and
   private key). This opens up the possibility of copying the server.crt
   to machines where the VNC Viewer will be run to enable authenticating
   the x11vnc SSL VNC server to the clients. When authentication takes
   place this way (or via the more sophisticated CA signing described
   [373]here), then Man-In-The-Middle-Attacks are prevented. Otherwise,
   the SSL encryption only provides protection against passive network
   traffic "sniffing". Nowadays, most people seem mostly concerned about
   only the latter (and the default x11vnc SSL modes protect against it.)


   One can test to some degree that SSL is working after starting x11vnc
   with the -stunnel or -ssl option. From another machine one can use the
   openssl command something like this:
 openssl s_client -debug -msg -showcerts -connect far-away.east:5900

   After all of the debugging output and informational messages you'll
   see the string "RFB 003.007" that came from x11vnc. Pointing a web
   browser connecting to: https://far-away.east:5900/ and then viewing
   the SSL certificate information about the connection in the panels
   will also work.

   Note: If you serve up the SSL enabled Java VNC Viewer via something
   like:
 x11vnc -ssl -httpdir /usr/local/share/x11vnc/classes/ssl

   (or just the -http option), you can test it out completely using that,
   including using https to download it into the browser and connect to
   x11vnc.

   See the [374]next FAQ for SSL enabled VNC Viewers.


   Q-44: How do I use VNC Viewers with built-in SSL tunneling?

   Notes on the SSL enabled Java VNC Viewer provided in
   classes/ssl/VncViewer.jar:

   The SSL enabled Java VNC Viewer (VncViewer.jar) in the x11vnc package
   supports only SSL based connections by default (set the applet
   parameter disableSSL=yes in index.vnc to override). As mentioned above
   the [375]-httpdir can be used to specify the path to .../classes/ssl.
   A typical location might be /usr/local/share/x11vnc/classes/ssl. Or
   [376]-http can be used to try to have it find the directory
   automatically.

   The Java viewer uses SSL to communicate securely with x11vnc. Note
   that the applet can optionally also be downloaded into your web
   browser via HTTPS (i.e. HTTP over SSL). This way the HTML page and the
   Java applet itself are delivered securely (as opposed to only the VNC
   traffic being encrypted).

   For this case the output will be something like this:
  x11vnc -ssl -http
  ...
  The SSL VNC desktop is:  far-away.east:0
  Java SSL viewer URL:     https://far-away.east:5900/
  Java SSL viewer URL:     http://far-away.east:5800/
  PORT=5900
  SSLPORT=5900

   Indicating the two URLs (the first one encrypted, the second not) one
   could point the web browser at to get the VNC viewer applet.

   The https service provided thru the actual VNC port (5900 in the above
   example) can occasionally be slow or unreliable (it has to read some
   input and try to guess if the connection is VNC or HTTP). If it is
   unreliable and you still want to serve the Java applet via https, use
   the [377]-https option to get an additional port dedicated to https
   (its URL will also be printed in the output).

   Another possibility is to add the GET applet parameter:
  https://far-away.east:5900/?GET=1

   This will have the VNC Viewer send a special HTTP GET string "GET
   /request.https.vnc.connection HTTP/1.0 that x11vnc will more quickly
   notice is a request for a VNC connection. Otherwise it must wait for a
   timeout to expire before it assumes a VNC connection.

   You may also use "?GET=somestring" to have /somestring prepended to
   /request.https.vnc.connection". Perhaps you are using a web server
   [378]proxy scheme to enter a firewall or otherwise have rules applied
   to the URL. If you need to have any slashes "/" in "somestring" use
   "_2F_" (a deficiency in libvncserver prevents using the more natural
   "%2F".)

   If you do serve the SSL enabled Java viewer via https be prepared for
   quite a number of "are you sure you trust this site?" dialogs:
     * First from the Web browser that cannot verify the self-signed
       certificate when it downloads index.vnc.
     * From the Web browser noting that the common name on the
       certificate does not match the hostname of the remote machine.
     * Next from the Java VM that cannot verify the self-signed
       certificate when it downloads VncViewer.jar.
     * And also from the Java VM noting that the common name on the
       certificate does not match the hostname of the remote machine.
     * Finally from the Java VncViewer applet itself saying it cannot
       verify the certificate! (or a popup asking you if you want to see
       the certificate.)

   Note that sometimes if you pause too long at one of the above dialogs
   then x11vnc may exceed a timeout and assume the current socket
   connection is VNC instead of the HTTPS it actually is (but since you
   have paused too long at the dialog the GET request comes too late).
   Often hitting Reload and going through the dialogs more quickly will
   let you connect. Use the [379]-https option if you want a dedicated
   port for HTTPS connections instead of sharing the VNC port.


   Notes on the VNC Viewer ssl_vncviewer wrapper script:

   If you want to use a native VNC Viewer with the SSL enabled x11vnc you
   will need to run an external SSL tunnel on the Viewer side. There do
   not seem to be any native SSL VNC Viewers outside of the x11vnc
   package. The basic ideas of doing this were discussed [380]for
   external tunnel utilities here.

   The [381]ssl_vncviewer script provided with x11vnc can set up the
   stunnel tunnel automatically on unix as long as the stunnel command is
   installed on the Viewer machine and available in PATH (and vncviewer
   too of course). Note that on Debian based system you will need to
   install the package stunnel4 not stunnel. You can set the environment
   variables STUNNEL and VNCVIEWERCMD to point to the correct programs if
   you want to override the defaults.

   Here are some examples:
  1)  ssl_vncviewer far-away.east:0

  2)  ssl_vncviewer far-away.east:0 -encodings "copyrect tight zrle hextile"

  3)  ssl_vncviewer -verify ./server.crt far-away.east:0

  4)  ssl_vncviewer -mycert ./client.pem far-away.east:0

  5)  ssl_vncviewer -proxy far-away.east:8080 myworkstation:0

   The first one is the default mode and accepts the x11vnc certificate
   without question. The second one is as the first, but adds the
   -encodings options to the vncviewer command line.

   The third one requires that the x11vnc server authenticate itself
   against the certificate in the file ./server.crt (e.g. one created by
   "x11vnc -ssl SAVE" and copied to the VNC viewer machine). The fourth
   one is for VNC Viewer authentication, it uses ./client.pem to
   authenticate itself to x11vnc. One can supply both -verify and -mycert
   simultaneously.

   The fifth one shows that Web proxies can be used if that is the only
   way to get out of the firewall. If the "double proxy" situation arises
   separate the two by commas. See [382]this page for more information on
   how Web proxies come into play.

   If one uses a Certificate Authority (CA) scheme described [383]here,
   the wrapper script would use the CA cert instead of the server cert:
  3')  ssl_vncviewer -verify ./cacert.crt far-away.east:0


   Q-45: How do I use VNC Viewers with built-in SSL tunneling when going
   through a Web Proxy?
   The SSL enabled Java VNC Viewer and firewall Proxies:

   SSL/https aside, there is a general problem with Firewall Proxies and
   Java Applets that open sockets. The applet is downloaded successfully
   (through the browser) using http and the proxy, but when the applet
   tries to reconnect to the originating host (the only one allowed by
   security) it does not use the proxy channel. So it cannot reconnect to
   the server the applet came from!

   We have found a convenient workaround: in the directory where
   VncViewer.jar resides there is a digitally signed version of the same
   applet called SignedVncViewer.jar. Since the applet is digitally
   signed, there will be an additional dialog from the Java VM plugin
   asking you if you want to trust the applet fully.

   You should say "Yes". If you do, the applet will be run in a mode
   where it can try to determine the firewall proxy host name and port
   (it will ask you for them if it cannot find them). This way it can
   connect directly to the Proxy and then request the CONNECT method to
   be redirected to the originating host (the x11vnc VNC Server). SSL is
   then layered over this socket.

   To do this you should use the proxy.vnc HTML file like via this URL in
   your browser:
  https://yourmachine.com:5900/proxy.vnc

   (instead of the unsigned one in https://yourmachine.com:5900/ that
   gives the default index.vnc)

   Note that the [384]ssl_vncviewer stunnel wrapper script can use Web
   proxies as well.

   Proxies that limit CONNECT to ports 443 and 563:

   Things become trickier if the proxy restricts which CONNECT ports can
   be redirected to. For security, some (most?) proxies only allow port
   443 (HTTPS) and 563 (SNEWS) by default. In this case, the only thing
   to do is run x11vnc on that low port, e.g. "-rfbport 443", (or use a
   port redirection on, say, a firewall or router port 443 to the
   internal machine).

   If you do such a redirection to an internal machine and x11vnc is not
   listening on port 443, you will probably need to edit proxy.vnc.
   Suppose the SSL x11vnc server was listening on port 5901. YOu should
   change the line in proxy.vnc from:
  <param name=PORT value=$PORT>

   to:
  <param name=PORT value=443>

   Since otherwise $PORT will be expanded to 5901 by x11vnc and the
   viewer applet will fail to connect to that port.

   Another way to acheive the same thing is to use the applet PORT
   parameter:
  https://yourmachine.com/proxy.vnc?PORT=443

   this is cleaner because it avoids editing the file, but requires more
   parameters in the URL. To use the GET [385]trick discussed above, do:
  https://yourmachine.com/proxy.vnc?PORT=443&GET=1


   Q-46: Can Apache web server act as a gateway for users to connect via
   SSL from the Internet with a Web browser to x11vnc running on their
   workstations behind a firewall?
   Yes. You will need to configure apache to forward these connections.
   It is discussed [386]here. This provides a clean alternative to the
   traditional method where the user uses SSH to log in through the
   gateway to create the encrypted port redirection to x11vnc running on
   her desktop.


   Q-47: Can I create and use my own SSL Certificate Authority (CA) with
   x11vnc?
   Yes, see [387]this page for how to do this and the utility commands
   x11vnc provides to create and manage many types of certificates and
   private keys.



   [Display Managers and Services]

   Q-48: How can I run x11vnc as a "service" that is always available?

   There are a number of ways to do this. The primary thing you need to
   decide is whether you want x11vnc to connect to the X session on the
   machine 1) regardless of who (or if anyone) has the X session, or 2)
   only if a certain user has the X session. Because X sessions are
   protected by X permissions (MIT-MAGIC-COOKIE files XAUTHORITY and
   $HOME/.Xauthority) the automatically started x11vnc will of course
   need to have sufficient permissions to connect to the X display.

   Here are some ideas:
     * Use the description under "Continuously" in the [388]FAQ on x11vnc
       and Display Managers
     * Use the description in the [389]FAQ on x11vnc and inetd(8)
     * Use the description in the [390]FAQ on Unix user logins and
       inetd(8)
     * Start x11vnc from your $HOME/.xsession (or $HOME/.xinitrc)
     * Although less reliable, see the [391]x11vnc_loop rc.local hack
       below.

   The display manager scheme will not be specific to which user has the
   X session unless a test is specifically put into the display startup
   script (often named Xsetup). The inetd(8) scheme may or may not be
   specific to which user has the X session (and it may not be able to do
   all users via the XAUTHORITY permission issues).

   The $HOME/.xsession scheme is obviously is specific to a particular
   user. If you do not know what a $HOME/.xsession script is or how to
   use one, perhaps your desktop has a "session startup commands"
   configuration option. The command to be run in the .xsession or
   .xinitrc file may look like this:
x11vnc -logfile $HOME/.x11vnc.log -rfbauth $HOME/.vnc/passwd -forever -bg

   plus any other options you desire.


   Q-49: How can I use x11vnc to connect to an X login screen like xdm,
   GNOME gdm, KDE kdm, or CDE dtlogin? (i.e. nobody is logged into an X
   session yet).

   One time only.   If the X login screen is running and you just want to
   connect to it once (i.e. a one-shot):

   It is usually possible to do this by just adjusting the XAUTHORITY
   environment variable to point to the correct MIT-COOKIE auth file
   while running x11vnc as root, e.g. for the gnome display manager, gdm:
  x11vnc -auth /var/gdm/:0.Xauth -display :0

   (the [392]-auth option sets the XAUTHORITY variable for you).

   There will be a similar thing for xdm using however a different auth
   directory path (perhaps something like
   /var/lib/xdm/authdir/authfiles/A:0-XQvaJk for xdm or
   /var/lib/kdm/A:0-crWk72 for kdm, where the random characters in
   basename will vary a bit). Read your system docs to find out where the
   display manager cookie files are kept.

   Trick: sometimes ps(1) can reveal the X server process -auth argument
   (e.g. "ps wwwwaux | grep auth").

   You next connect to x11vnc with a VNC viewer, give your username and
   password to the X login prompt to start your session.

   Note:  gdm seems to have an annoying setting that causes x11vnc (and
   any other X clients) to be killed after the user logs in. Setting
   KillInitClients=false in the [daemon] section of /etc/X11/gdm/gdm.conf
   avoids this. Otherwise, just restart x11vnc and then reconnect your
   viewer.

   Note:  For dtlogin in addition to the above sort of trick (BTW, the
   auth file should be in /var/dt), you'll also need to add something
   like Dtlogin*grabServer:False to the Xconfig file
   (/etc/dt/config/Xconfig or /usr/dt/config/Xconfig on Solaris, see
   [393]the example at the end of this FAQ). Then restart dtlogin, e.g.:
   /etc/init.d/dtlogin stop; /etc/init.d/dtlogin start or reboot.

   Continuously.   Have x11vnc reattach each time the X server is
   restarted (i.e. after each logout):

   To make x11vnc always attached to the X server including the login
   screen you will need to add a command to a display manager startup
   script.

   Please consider the security implications of this! Besides having the
   VNC display for the X session always available, there are other
   issues: .e.g. if you run the tkx11vnc gui (via say -gui or -gui tray),
   then the gui controls (insecure) are available on the physical X
   display before anyone has logged in (maybe doing "-gui
   tray,geom=+4000+4000" is a good idea...)

   The name of the display manager startup script file depends on desktop
   used and seem to be:
        GNOME        /etc/X11/gdm/Init/Default  (or Init/:0)
        KDE          /etc/kde*/kdm/Xsetup
        XDM          /etc/X11/xdm/Xsetup        (or xdm/Xsetup_0)
        CDE          /etc/dt/config/Xsetup

   although the exact location can depend on operating system and
   distribution. See the documentation for your display manager:  gdm(1),
   kdm(1), xdm(1), dtlogin(1) for additional details. There may also be
   display number specific scripts: e.g. Xsetup_0 vs. Xsetup, you need to
   watch out for.

   Note:  The above gdm setting of KillInitClients=false in
   /etc/X11/gdm/gdm.conf is needed here as well.

   Note:  The above Dtlogin*grabServer:False step will be needed for
   dtlogin here as well.

   In any event, the line you will add to the display manager script will
   look something like:
  /usr/local/bin/x11vnc -rfbauth /path/to/the/vnc/passwd -o /tmp/x11vnc.log -fo
rever -bg

   where you should customize the exact command to your needs.

   Happy, happy, joy, joy:  Note that we do not need to specify -display
   or -auth because happily they are already set for us in the DISPLAY
   and XAUTHORITY environment variables for the Xsetup script!!!

   You may also want to force the VNC port with something like "-rfbport
   5900"
     _________________________________________________________________

   Fedora/gdm: Here is an example of what we did on a vanilla install of
   Fedora-C3 (seems to use gdm by default). Add a line like this to
   /etc/X11/gdm/Init/:0
  /usr/local/bin/x11vnc -rfbauth /etc/x11vnc.passwd -forever -bg -o /tmp/x11vnc
.log

   And then add this line to /etc/X11/gdm/gdm.conf in the [daemon]
   section:
  KillInitClients=false

   Then restart: /usr/sbin/gdm-restart (or reboot). The
   KillInitClients=false setting is important: without it x11vnc will be
   killed immediately after the user logs in. Here are [394]full details
   on how to configure gdm
     _________________________________________________________________

   Solaris/dtlogin: Here is an example of what we did on a vanilla
   install of Solaris:
   Make the directory /etc/dt/config:
  mkdir -p /etc/dt/config

   Copy over the Xconfig file for customization:
  cp /usr/dt/config/Xconfig /etc/dt/config/Xconfig

   Edit /etc/dt/config/Xconfig and uncomment the line:
  Dtlogin*grabServer:        False

   Next, copy over Xsetup for customization:
  cp /usr/dt/config/Xsetup /etc/dt/config/Xsetup

   Edit /etc/dt/config/Xsetup and at the bottom put a line like:
  /usr/local/bin/x11vnc -forever -o /var/tmp/x11vnc.log -bg

   (tweaked to your local setup and preferences, a password via -rfbauth,
   etc. would be a very good idea).

   Restart the X server and dtlogin:
  /etc/init.d/dtlogin stop
  /etc/init.d/dtlogin start

   (or reboot or maybe just restart the X session).
     _________________________________________________________________

   KDM: One user running the kdm display manager reports putting this
   line:
  x11vnc -forever -rfbauth /home/xyz/.vnc/passwd -bg -o /tmp/x11vnc.log

   in /etc/kde/kdm/Xsetup. After rebooting the system it all seemed to
   work fine.
     _________________________________________________________________


   If you do not want to deal with any display manager startup scripts,
   here is a kludgey script that can be run manually or out of a boot
   file like rc.local: [395]x11vnc_loop It will need some local
   customization before running. Because the XAUTHORITY auth file must be
   guessed by this script, use of the display manager script method
   described above is greatly preferred.

   If the machine is a traditional Xterminal you may want to read
   [396]this FAQ.


   Q-50: Can I run x11vnc out of inetd(8)? How about xinetd(8)?

   Yes, perhaps a line something like this in /etc/inetd.conf will do it
   for you:

  5900 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc_sh

   where the shell script /usr/local/bin/x11vnc_sh uses the [397]-inetd
   option and looks something like (you'll need to customize to your
   settings).
#!/bin/sh
/usr/local/bin/x11vnc -inetd -display :0 -auth /home/fred/.Xauthority \
        -rfbauth /home/fred/.vnc/passwd -o /tmp/x11vnc_sh.log

   Important:  Note that you must redirect the standard error output to a
   log file (e.g. -o logfile) or "2>/dev/null" for proper operation via
   inetd (otherwise the standard error also goes to the VNC vncviewer,
   and that confuses it greatly, causing it to abort). If you do not use
   a wrapper script as above but rather call x11vnc directly in
   /etc/inetd.conf and do not redirect stderr to a file, then you must
   specify the -q (aka [398]-quiet) option: "/usr/local/bin/x11vnc -q
   -inetd ...". When you supply both -q and -inet and no "-o logfile"
   then stderr will automatically be closed (to prevent, e.g. library
   stderr messages leaking out to the viewer). The recommended practice
   is to use "-o logfile" to collect the output in a file or wrapper
   script with "2>logfile" redirection because the errors and warnings
   printed out are very useful in troubleshooting problems.

   Note also the need to set XAUTHORITY via [399]-auth to point to the
   MIT-COOKIE auth file to get permission to connect to the X display
   (setting and exporting the XAUTHORITY variable accomplishes the same
   thing). See the x11vnc_loop file in the previous question for more
   ideas on what that auth file may be, etc.

   Note:  On Solaris you cannot have the bare number 5900 in
   /etc/inetd.conf, you'll need to replace it with a word like x11vnc an
   then put something like "x11vnc 5900/tcp" in /etc/services.

   Since the process runs as root, it might be a bad idea to have the
   logfile in a world-writable area like /tmp if there are untrustworthy
   users on the machine. Perhaps /var/log would be a better place. Also,
   while running x11vnc as root, remember it comes with no warranty ;-).

   Be sure to look at your /etc/hosts.allow and /etc/hosts.deny settings
   to limit the machines that can connect to this service (your
   desktop!). For the above example with /etc/hosts.allow:
  x11vnc_sh : 123.45.67.89

   A really safe way to do things is to limit the above inetd to
   localhost only (via /etc/hosts.allow) and use ssh to tunnel the
   incoming connection. Using inetd for this prevents there being a tiny
   window of opportunity between x11vnc starting up and your vncviewer
   connecting to it. Always use a VNC password to further protect against
   unwanted access.

   For xinetd(8), one user reports he created the file
   /etc/xinetd.d/x11vncservice containing the following:
# default: off
# description:
service x11vncservice
{
        flags           = REUSE NAMEINARGS
        port            = 5900
        type            = UNLISTED
        socket_type     = stream
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/sbin/tcpd
        server_args     = /usr/local/bin/x11vnc_sh
        disable         = no
}

   With the contents of /usr/local/bin/x11vnc_sh similar to the example
   given above. One user reports this works with avoiding the wrapper
   script:
service x11vncservice
{
        port            = 5900
        type            = UNLISTED
        socket_type     = stream
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/local/bin/x11vnc
        server_args     = -inetd -q -display :0 -auth /var/gdm/:0.Xauth
        disable         = no
}

   (or one can replace the -q with say "-o /var/log/x11vnc.log" to
   capture a log)


   Q-51: Can I have x11vnc allow a user to log in with her UNIX password
   and then have it find her X display on that machine and connect to it?

   The easiest way to do this is via [400]inetd(8) using the [401]-unixpw
   and [402]-display WAIT options. The reason inetd(8) makes this easier
   is that it starts a new x11vnc process for each new user connection.
   Otherwise a wrapper would have to listen for connections and spawn new
   x11vnc's (see [403]this example).

   The [404]-display WAIT option makes x11vnc wait until a VNC viewer is
   connected before attaching to the X display. Additionally it can be
   used to run an external command that returns the DISPLAY and
   XAUTHORITY data. So one could supply "-display
   WAIT:cmd=/path/to/find_display" where the script find_display might
   look something like:
#!/bin/sh

PATH=$PATH:/bin:/usr/bin:/usr/X11R6/bin:/usr/bin/X11:/usr/openwin/bin
export PATH

if [ "X$user" = "X" ]; then
        user=$USER
fi
if [ "X$user" = "X" ]; then
        user=$LOGNAME
fi
if [ "X$user" = "X" ]; then
        echo ""
        exit 1
fi

display=`who | grep "^${user}[  ][      ]*:[0-9]" | head -1 | awk '{print $2}'`
if [ "X$display" = "X" ]; then
    display=`who | grep "^${user}[      ]" | awk '{print $NF}' | grep '(:[0-9]'
 | sed -e 's/[()]//g' | head -1`
    if [ "X$display" = "X" ]; then
        echo ""
        exit 1
    fi
fi

echo "DISPLAY=$display"
xauth extract - "$display" 2>/dev/null

exit 0

   A default script similar to the above is used under "-display
   WAIT:cmd=FINDDISPLAY" (use "WAIT:cmd=FINDDISPLAY-print" to print it
   out). The format for any such script is that it returns DISPLAY=:disp
   as the first line and any remaining lines are either XAUTHORITY=file
   or raw xauth data (the above example does the latter).

   The [405]-unixpw option allows [406]UNIX password logins. Here are a
   couple /etc/inetd.conf examples for this:
5900  stream  tcp  nowait  nobody  /usr/sbin/tcpd /usr/local/bin/x11vnc -inetd
-unixpw \
      -display WAIT:cmd=FINDDISPLAY -o /var/log/x11vnc.log -ssl SAVE -ssldir /u
sr/local/certs
5900  stream  tcp  nowait  root    /usr/sbin/tcpd /usr/local/bin/x11vnc -inetd
-unixpw \
      -display WAIT:cmd=FINDDISPLAY -o /var/log/x11vnc.log -ssl SAVE -users uni
xpw=

   Note the very long lines have been split. An alternative is to use a
   wrapper script, e.g. /usr/local/bin/x11vnc.sh that has all of the
   options.

   In the first one x11vnc is run as user "nobody" and stays user nobody
   during the whole session. The permissions of the log files and certs
   directory will need to be set up to allow "nobody" to use them.

   In the second one x11vnc is run as root and switches to the user that
   logs in due to the "[407]-users unixpw=" option.

   Note that [408]SSL is required for this mode because otherwise the
   unix password would be passed in clear text over the network. In
   general -unixpw is not required for this sort of scheme, but it is
   convenient because it determines exactly who the user is whose display
   should be sought. Otherwise the find_display script would have to use
   some method to work out DISPLAY, XAUTHORITY, etc.


   Q-52: Can I have x11vnc restart itself after it terminates?

   One could do this in a shell script, but now there is an option
   [409]-loop that makes it easier. Of course when x11vnc restarts it
   needs to have permissions to connect to the (potentially new) X
   display. This mode could be useful if the X server restarts often. Use
   e.g. "-loop5000" to sleep 5000 ms between restarts. Also "-loop2000,5"
   to sleep 2000 ms and only restart 5 times.


   Q-53: How do I make x11vnc work with the Java VNC viewer applet in a
   web browser?

   To have x11vnc serve up a Java VNC viewer applet to any web browsers
   that connect to it, run x11vnc with this [410]option:
  -httpdir /path/to/the/java/classes/dir

   (this directory will contain the files index.vnc and, for example,
   VncViewer.jar) Note that libvncserver contains the TightVNC Java
   classes jar file for your convenience. (it is the file
   classes/VncViewer.jar in the source tree).

   You will see output something like this:
  14/05/2004 11:13:56 Autoprobing selected port 5900
  14/05/2004 11:13:56 Listening for HTTP connections on TCP port 5800
  14/05/2004 11:13:56   URL http://walnut:5800
  14/05/2004 11:13:56 screen setup finished.
  14/05/2004 11:13:56 The VNC desktop is walnut:0
  PORT=5900

   then you can connect to that URL with any Java enabled browser. Feel
   free to customize the default index.vnc file in the classes directory.

   As of May/2005 the [411]-http option will try to guess where the Java
   classes jar file is by looking in expected locations.

   Also note that if you wanted to, you could also start the Java viewer
   entirely from the viewer-side by having the jar file there and using
   either the java or appletviewer commands to run the program.


   Q-54: Are reverse connections (i.e. the VNC server connecting to the
   VNC viewer) using "vncviewer -listen" and vncconnect(1) supported?

   As of Mar/2004 x11vnc supports reverse connections. On Unix one starts
   the VNC viewer in listen mode: vncviewer -listen (see your
   documentation for Windows, etc), and then starts up x11vnc with the
   [412]-connect option. To connect immediately at x11vnc startup time
   use the "-connect host:port" option (use commas for a list of hosts to
   connect to). The ":port" is optional (default is 5500).

   If a file is specified instead: -connect /path/to/some/file then that
   file is checked periodically (about once a second) for new hosts to
   connect to.

   The [413]-remote control option (aka -R) can also be used to do this
   during an active x11vnc session, e.g.:
x11vnc -display :0 -R connect:hostname.domain

   Note that as of Mar/2006 x11vnc requires password authentication for
   reverse connections as well as for forward ones (assuming password
   auth has been enabled, e.g. via -rfbauth, -passwdfile, etc). Many VNC
   servers do not require any password for reverse connections. To regain
   the old behavior set: X11VNC_REVERSE_CONNECTION_NO_AUTH=1 before
   starting x11vnc.

   To use the vncconnect(1) program (from the core VNC package at
   www.realvnc.com) specify the [414]-vncconnect option to x11vnc (Note:
   as of Dec/2004 -vncconnect is now the default). vncconnect(1) must be
   pointed to the same X11 DISPLAY as x11vnc (since it uses X properties
   to communicate with x11vnc). If you do not have or do not want to get
   the vncconnect(1) program, the following script (named "Vncconnect")
   may work if your xprop(1) supports the -set option:
#!/bin/sh
# usage: Vncconnect <host>
#        Vncconnect <host:port>
# note: not all xprop(1) support -set.
#
xprop -root -f VNC_CONNECT 8s -set VNC_CONNECT "$1"


   Q-55: Can I use x11vnc as a replacement for Xvnc? (i.e. not for a real
   display, but for a virtual one I keep around).

   You can, but you would not be doing this for performance reasons (for
   virtual X sessions via VNC, Xvnc will give the fastest response). You
   may want to do this because Xvnc does not support an X server
   extension you desire, or you want to take advantage of one of x11vnc's
   unending number of options and features.

   One way to acheive this is to have a Xvfb(1) virtual framebuffer X
   server running in the background and have x11vnc attached to it.
   Another method, faster and more accurate is to use the "dummy" Device
   Driver in XFree86/Xorg (see below). One could view this desktop both
   remotely and also locally using vncviewer. Make sure vncviewer's
   "-encodings raw" is in effect for local viewing (compression seems to
   slow things down locally). For local viewing you set up a "bare"
   window manager that just starts up vncviewer and nothing else.

   Here is one way to start up Xvfb:
  xinit -- /usr/X11R6/bin/Xvfb :1 -screen 0 1024x768x16

   This starts up a 16bpp virtual display. To export it via VNC use
   "x11vnc -display :1 ...".

   One good thing about Xvfb is that the virtual framebuffer exists in
   main memory (rather than in the video hardware), and so x11vnc can
   "screen scrape" it efficiently (more than, say, 100X faster than
   normal video hardware).

   There are some annoyances WRT Xvfb though. The default keyboard
   mapping seems to be very poor. One should run x11vnc with
   [415]-add_keysyms option to have keysyms added automatically. Also, to
   add the Shift_R and Control_R modifiers something like this is needed:
#!/bin/sh
xmodmap -e "keycode any = Shift_R"
xmodmap -e "add Shift = Shift_L Shift_R"
xmodmap -e "keycode any = Control_R"
xmodmap -e "add Control = Control_L Control_R"

   Perhaps the Xvfb options -xkbdb or -xkbmap could be used to get a
   better default keyboard mapping.

   A user points out a faster and more accurate method is to use the
   "dummy" Device Driver of XFree86/Xorg instead of Xvfb. He uses this to
   create a persistent and resizable desktop accessible from anywhere. In
   the Device Section of the config file set Driver "dummy". You may also
   need to set VideoRam NNN to be large enough to hold the framebuffer.
   The framebuffer is kept in main memory like Xvfb except that the
   server code is closely correlated with the real XFree86/Xorg Xserver
   unlike Xvfb.

   The main drawback to this method (besides requiring extra
   configuration and possibly root permission) is that it also does the
   Linux Virtual Console/Terminal (VC/VT) [416]switching even though it
   does not need to (since it doesn't use a real framebuffer). There are
   some "dual headed" (actually multi-headed/multi-user) patches to the X
   server that turn off the VT usage in the X server. Update: As of
   Jul/2005 we have an LD_PRELOAD script [417]Xdummy that allows you to
   use a stock (i.e. unpatched) Xorg or XFree86 server with the "dummy"
   driver and not have any VT switching problems! Currently Xdummy needs
   to be run as root, but with some luck that may be relaxed in the
   future.

   The standard way to start the "dummy" driver would be:
startx -- :1 -config /etc/X11/xorg.conf.dummy

   where the file /etc/X11/xorg.conf.dummy has its Device Section
   modified as described above. To use the LD_PRELOAD wrapper script:
startx -- /path/to/Xdummy :1

   An xdm(1) example is also provided.

   In general, one can use these sorts of schemes to use x11vnc to export
   other virtual X sessions, say Xnest or even Xvnc itself (useful for
   testing x11vnc).


   Q-56: How can I use x11vnc on "headless" machines? Why might I want
   to?

   An interesting application of x11vnc is to let it export displays of
   "headless" machines. For example, you may have some lab or server
   machines with no keyboard, mouse, or monitor, but each one still has a
   video card. One can use x11vnc to provide a simple "desktop service"
   from these server machines.

   An X server can be started on the headless machine (sometimes this
   requires configuring the X server to not fail if it cannot detect a
   keyboard or mouse, see the next paragraph). Then you can export that X
   display via x11vnc (e.g. see [418]this FAQ) and access it from
   anywhere on the network via a VNC viewer.

   Some tips on getting X servers to start on machines without keyboard
   or mouse: For XFree86/Xorg the Option "AllowMouseOpenFail" "true"
   "ServerFlags" config file option is useful. On Solaris Xsun the
   +nkeyboard and +nmouse options are useful (put them in the server
   command line args in /etc/dt/config/Xservers). See Xserver(1) for more
   info.

   Although this usage may sound strange it can be quite useful for a GUI
   (or other) testing or QA setups: the engineers do not need to walk to
   lab machines running different hardware, OS's, versions, etc (or have
   many different machines in their office). They just connect to the
   various test machines over the network via VNC. The advantage to
   testing this way instead of using Xvnc or even Xvfb is that the test
   is done using the real X server, fonts, video hardware, etc. that will
   be used in the field.

   One can imagine a single server machine crammed with as many video
   cards as it can hold to provide multiple simultaneous access or
   testing on different kinds of video hardware.

   [Resource Usage and Performance]

   Q-57: I have lots of memory, but why does x11vnc fail with    shmget:
   No space left on device    or    Minor opcode of failed request: 1
   (X_ShmAttach)?

   It is not a matter of free memory, but rather free shared memory (shm)
   slots, also known as shm segments. This often occurs on a public
   Solaris machine using the default of only 100 slots. You (or the owner
   or root) can clean them out with ipcrm(1). x11vnc tries hard to
   release its slots, but it, and other programs, are not always able to
   (e.g. if kill -9'd).

   Sometimes x11vnc will notice the problem with shm segments and tries
   to get by with fewer, only giving a warning like this:
  19/03/2004 10:10:58 shmat(tile_row) failed.
  shmat: Too many open files
  19/03/2004 10:10:58 error creating tile-row shm for len=4
  19/03/2004 10:10:58 reverting to single_copytile mode

   Here is a shell script [419]shm_clear to list and prompt for removal
   of your unattached shm segments (attached ones are skipped). I use it
   while debugging x11vnc (I use "shm_clear -y" to assume "yes" for each
   prompt). If x11vnc is regularly not cleaning up its shm segments,
   please contact me so we can work to improve the situation.

   Longer term, on Solaris you can put something like this in
   /etc/system:
  set shmsys:shminfo_shmmax = 0x2000000
  set shmsys:shminfo_shmmni = 0x1000

   to sweep the problem under the rug (4096 slots). On Linux, examine
   /proc/sys/kernel/shmmni; you can modify the value by writing to that
   file.

   Things are even more tight on Solaris 8 and earlier, there is a
   default maximum number of shm segments per process of 6. The error is
   the X server (not x11vnc) being unable to attach to the segments, and
   looks something like this:
  30/04/2004 14:04:26 Got connection from client 192.168.1.23
  30/04/2004 14:04:26   other clients:
  X Error of failed request:  BadAccess (attempt to access private resource den
ied)
     Major opcode of failed request:  131 (MIT-SHM)
     Minor opcode of failed request:  1 (X_ShmAttach)
     Serial number of failed request:  14
     Current serial number in output stream:  17

   This tight limit on Solaris 8 can be increased via:
  set shmsys:shminfo_shmseg = 100

   in /etc/system. See the next paragraph for more workarounds.

   To minimize the number of shm segments used by x11vnc try using the
   [420]-onetile option (corresponds to only 3 shm segments used, and
   adding -fs 1.0 knocks it down to 2). If you are having much trouble
   with shm segments, consider disabling shm completely via the
   [421]-noshm option. Performance will be somewhat degraded but when
   done over local machine sockets it should be acceptable (see an
   [422]earlier question discussing -noshm).


   Q-58: How can I make x11vnc use less system resources?

   The [423]-nap and "[424]-wait n" (where n is the sleep between polls
   in milliseconds, the default is 30 or so) option are good places to
   start. Reducing the X server bits per pixel depth (e.g. to 16bpp or
   even 8bpp) will further decrease memory I/O and network I/O. The
   ShadowFB will make x11vnc's screen polling less severe. Using the
   [425]-onetile option will use less memory and use fewer shared memory
   slots (add [426]-fs 1.0 for one less slot).


   Q-59: How can I make x11vnc use MORE system resources?

   You can try [427]-threads and dial down the wait time (e.g. -wait 1)
   and possibly dial down [428]-defer as well. Note that if you try to
   increase the "frame rate" too much you can bog down the server end
   with the extra work it needs to do compressing the framebuffer data,
   etc.

   That said, it is possible to "stream" video via x11vnc if the video
   window is small enough. E.g. a 256x192 xawtv TV capture window (using
   the x11vnc [429]-id option) can be streamed over a LAN or wireless at
   a reasonable frame rate.


   Q-60: I use x11vnc over a slow link with high latency (e.g. dialup
   modem), is there anything I can do to speed things up?

   Some things you might want to experiment with (many of which will help
   performance on faster links as well):

     X server/session parameters:
     * Configure the X server bits per pixel to be 16bpp or even 8bpp.
       (reduces amount of data needed to be polled, compressed, and sent)
     * Use a smaller desktop size (e.g. 1024x768 instead of 1280x1024)
     * Make sure the desktop background is a solid color (the background
       is resent every time it is re-exposed). Consider using the
       [430]-solid [color] option to try to do this automatically.
     * Configure your window manager or desktop "theme" to not use fancy
       images, shading, and gradients for the window decorations, etc.
       Disable window animations, etc. Maybe your desktop has a "low
       bandwidth" theme you can easily switch into and out of. Also in
       Firefox disable eye-candy, e.g.: Edit -> Preferences -> Advanced
       -> Use Smooth Scrolling (deselect it).
     * Avoid small scrolls of large windows using the Arrow keys or
       scrollbar. Try to use PageUp/PageDown instead. (not so much of a
       problem in x11vnc 0.7.2 if [431]-scrollcopyrect is active and
       detecting scrolls for the application).
     * If the [432]-wireframe option is not available (earlier than
       x11vnc 0.7.2 or you have disabled it via -nowireframe) then
       Disable Opaque Moves and Resizes in the window manager/desktop.
     * However if -wireframe is active (on by default in x11vnc 0.7.2)
       then you should Enable Opaque Moves and Resizes in the window
       manager! This seems counter-intuitive, but because x11vnc detects
       the move/resize events early there is a huge speedup over a slow
       link when Opaque Moves and Resizes are enabled. (e.g. CopyRect
       encoding will be used).
     * Turn off Anti-aliased fonts on your system, web browser, terminal
       windows, etc. AA fonts do not compress as well as traditional
       fonts (sometimes 10X less).
     * On XFree86 turn on the Shadow Framebuffer to speed up reading.
       (Option "ShadowFB" "true" in the Device section of
       /etc/X11/XF86Config) This disables 2D acceleration on the physical
       display and so may not be worth it, but could be of use in some
       situations. If the link is very slow, this speedup may not be
       noticed.

     VNC viewer parameters:
     * Use a [433]TightVNC enabled viewer! (Actually, RealVNC 4.x viewer
       with ZRLE encoding is not too bad either; some claim it is
       faster).
     * Make sure the tight (or zrle) encoding is being used (look at
       vncviewer and x11vnc outputs)
     * Request 8 bits per pixel using -bgr233 (up to 4X speedup over
       depth 24 TrueColor (32bpp), but colors will be off)
     * RealVNC 4.x viewer has some extremely low color modes (only 64 and
       even 8 colors). The colors are poor, but it is usually noticeably
       faster than bgr233 (256 colors).
     * Try increasing the TightVNC -compresslevel (compresses more on
       server side before sending, but uses more CPU)
     * Try reducing the TightVNC -quality (increases JPEG compression,
       but is lossy with painting artifacts)
     * Try other VNC encodings via -encodings (tight is may be the
       fastest, but you should compare it to zrle and maybe some of the
       others)
     * On the machine where vncviewer is run, make sure Backing Store is
       enabled (XFree86/Xorg disables it by default causing re-exposures
       of vncviewer to be very slow) Option "backingstore" in config
       file.

     x11vnc parameters:
     * Make sure the [434]-wireframe option is active (it should be on by
       default) and you have Opaque Moves/Resizes Enabled in the window
       manager.
     * Make sure the [435]-scrollcopyrect option is active (it should be
       on by default). This detects scrolls in many (but not all)
       applications an applies the CopyRect encoding for a big speedup.
     * Specify [436]-speeds modem to force the wireframe and
       scrollcopyrect heuristic parameters (and any future ones) to those
       of a dialup modem connection (or supply the rd,bw,lat numerical
       values that characterize your link).
     * If wireframe and scrollcopyrect aren't working, try using the more
       drastic [437]-nodragging (no screen updates when dragging mouse,
       but sometimes you miss visual feedback)
     * Set [438]-fs 1.0 (disables fullscreen updates)
     * Try increasing [439]-wait or [440]-defer (reduces the maximum
       "frame rate", but won't help much for large screen changes)
     * Try the [441]-progressive pixelheight mode with the block
       pixelheight 100 or so (delays sending vertical blocks since they
       may change while viewer is receiving earlier ones)
     * If you just want to watch one (simple) window use [442]-id (cuts
       down extraneous polling and updates, but can be buggy or
       insufficient)
     * Set [443]-nosel (disables all clipboard selection exchange)
     * Use [444]-nocursor and [445]-nocursorpos (repainting the remote
       cursor position and shape takes resources and round trips)
     * On very slow links (e.g. <= 28.8) you may need to increase the
       [446]-readtimeout n setting if it sometimes takes more than 20sec
       to paint the full screen, etc.


   Q-61: Does x11vnc support the X DAMAGE Xserver extension to find
   modified regions of the screen quickly and efficiently?

   Yes, as of Mar/2005 x11vnc will use the X DAMAGE extension by default
   if it is available on the display. This requires libXdamage to be
   available in the build environment as well (recent Linux distros and
   Solaris 10 have it).

   The DAMAGE extension enables the X server to report changed regions of
   the screen back to x11vnc. So x11vnc doesn't have to guess where the
   changes are (by polling every pixel of the entire screen every 2-4
   seconds). The use of X DAMAGE dramatically reduces the load when the
   screen is not changing very much (i.e. most of the time). It also
   noticeably improves updates, especially for very small changed areas
   (e.g. clock ticking, cursor flashing, typing, etc).

   Note that the DAMAGE extension does not speed up the actual reading of
   pixels from the video card framebuffer memory, by, say, mirroring them
   in main memory. So reading the fb is still painfully [447]slow (e.g.
   5MB/sec), and so even using X DAMAGE when large changes occur on the
   screen the bulk of the time is still spent retrieving them. Not ideal,
   but use of the ShadowFB XFree86/Xorg option speeds up the reading
   considerably (at the cost of h/w acceleration).

   Unfortunately the current Xorg DAMAGE extension implementation can at
   times be overly conservative and report very large rectangles as
   "damaged" even though only a small portion of the pixels have actually
   been modified. This behavior is often the fault of the window manager
   (e.g. it redraws the entire, unseen, frame window underneath the
   application window when it gains focus), or the application itself
   (e.g. does large, unnecessary repaints).

   To work around this deficiency, x11vnc currently only trusts small
   DAMAGE rectangles to contain real damage. The larger rectangles are
   only used as hints to focus the traditional scanline polling (i.e. if
   a scanline doesn't intersect a recent DAMAGE rectangle, the scan is
   skipped). You can use the "[448]-xd_area A" option to adjust the size
   of the trusted DAMAGE rectangles. The default is 20000 pixels (e.g. a
   140x140 square, etc). Use "-xd_area 0" to disable the cutoff and trust
   all DAMAGE rectangles.

   The option "[449]-xd_mem f" may also be of use in tuning the
   algorithm. To disable using DAMAGE entirely use "[450]-noxdamage".


   Q-62: When I drag windows around with the mouse or scroll up and down
   things really bog down (unless I do the drag in a single, quick
   motion). Is there anything to do to improve things?

   This problem is primarily due to [451]slow hardware read rates from
   video cards: as you scroll or move a large window around the screen
   changes are much too rapid for x11vnc to keep up them (it can usually
   only read the video card at about 5-10 MB/sec, so it can take a good
   fraction of a second to read the changes induce from moving a large
   window, if this to be done a number of times in succession the window
   or scroll appears to "lurch" forward). See the description in the
   [452]-pointer_mode option for more info. The next bottleneck is
   compressing all of these changes and sending them out to connected
   viewers, however the VNC protocol is pretty much self-adapting with
   respect to that (updates are only packaged and sent when viewers ask
   for them).

   As of Jan/2004 there are some improvements to libvncserver. The
   default should now be much better than before and dragging small
   windows around should no longer be a huge pain. If for some reason
   these changes make matters worse, you can go back to the old way via
   the "[453]-pointer_mode 1" option.

   Also added was the [454]-nodragging option that disables all screen
   updates while dragging with the mouse (i.e. mouse motion with a button
   held down). This gives the snappiest response, but might be undesired
   in some circumstances when you want to see the visual feedback while
   dragging (e.g. menu traversal or text selection).

   As of Dec/2004 the [455]-pointer_mode n option was introduced. n=1 is
   the original mode, n=2 an improvement, etc.. See the -pointer_mode n
   help for more info.

   Also, in some circumstances the [456]-threads option can improve
   response considerably. Be forewarned that if more than one vncviewer
   is connected at the same time then libvncserver may not be thread safe
   (try to get the viewers to use different VNC encodings, e.g. tight and
   ZRLE).

   As of Apr/2005 two new options (see the [457]wireframe FAQ and
   [458]scrollcopyrect FAQ below) provide schemes to sweep this problem
   under the rug for window moves or resizes and for some (but not all)
   window scrolls.


   Q-63: Why not do something like wireframe animations to avoid the
   windows "lurching" when being moved or resized?

   Nice idea for a hack! As of Apr/2005 x11vnc by default will apply
   heuristics to try to guess if a window is being (opaquely) moved or
   resized. If such a change is detected framebuffer polling and updates
   will be suspended and only an animated "wireframe" (a rectangle
   outline drawn where the moved/resized window would be) is shown. When
   the window move/resize stops, it returns to normal processing: you
   should only see the window appear in the new position. This spares you
   from interacting with a "lurching" window between all of the
   intermediate steps. BTW the lurching is due to [459]slow video card
   read rates (see [460]here too). A displacement, even a small one, of a
   large window requires a non-negligible amount of time, a good fraction
   of a second, to read in from the hardware framebuffer.

   Note that Opaque Moves/Resizes must be Enabled by your window manager
   for -wireframe to do any good.

   The mode is currently on by default because most people are inflicted
   with the problem. It can be disabled with the [461]-nowireframe option
   (aka -nowf). Why might one want to turn off the wireframing? Since
   x11vnc is merely guessing when windows are being moved/resized, it may
   guess poorly for your window-manager or desktop, or even for the way
   you move the pointer. If your window-manager or desktop already does
   its own wireframing then this mode is a waste of time and could do the
   wrong thing occasionally. There may be other reasons the new mode
   feels unnatural. If you have very expensive video hardware (SGI) or
   are using an in-RAM video framebuffer (SunRay, ShadowFB, Xvfb), the
   read rate from that framebuffer may be very fast (100's of MB/sec) and
   so you don't really see much lurching: opaque moves look smooth in
   x11vnc. Note: ShadowFB is often turned on when you are using the
   vesafb or fbdev XFree86 video driver instead of a native one so you
   might be using it already and not know.

   The heuristics used to guess window motion or resizing are simple, but
   are not fool proof: x11vnc is sometimes tricked and so you'll
   occasionally see the lurching opaque move and rarely something even
   worse.

   First it assumes that the move/resize will occur with a mouse button
   pressed, held down and dragged (of course this is only mostly true).
   Next it will only consider a window for wireframing if the mouse
   pointer is initially "close enough" to the edges of the window frame,
   e.g. you have grabbed the title bar or a resizer edge (this
   requirement can be disabled and it also not applied if a modifier key,
   e.g. Alt, is pressed). If these are true, it will wait an amount of
   time to see if the window starts moving or resizing. If it does, it
   starts drawing the wireframe "outline" of where the window would be.
   When the mouse button is released, or a timeout occurs, it goes back
   to the standard mode to allow the actual framebuffer changes to
   propagate to the viewers.

   These parameters can be tweaked:
     * Color/Shade of the wireframe.
     * Linewidth of the outline frame.
     * Cutoff size of windows to not apply wireframing to.
     * Cutoffs for closeness to Top, Bottom, Left, and Right edges of
       window.
     * Modifier keys to enable interior window grabbing.
     * Maximum time to wait for dragging pointer events.
     * Maximum time to wait for the window to start moving/resizing.
     * Maximum time to show a wireframe animation.
     * Minimum time between sending wireframe outlines.

   See the [462]"-wireframe tweaks" option for more details. On a slow
   link, e.g. dialup modem, the parameters may be automatically adjusted
   for better response.


   CopyRect encoding:  In addition to the above there is the
   [463]"-wirecopyrect mode" option. It is also on by default. This
   instructs x11vnc to not only show the wireframe animation, but to also
   instruct all connected VNC viewers to locally translate the window
   image data from the original position to the new position on the
   screen when the animation is done. This speedup is the VNC CopyRect
   encoding: the framebuffer update doesn't need to send the actual new
   image data. This is nice in general, and very convenient over a slow
   link, but since it is based on heuristics you may need to disable it
   with the -nowirecopyrect option (aka -nowcr) if it works incorrectly
   or unnaturally for you.

   The -wirecopyrect modes are: "never" (same as -nowirecopyrect); "top",
   only apply the CopyRect if the window is appears to be on the top of
   the window stack and is not obstructed by other windows; and "always"
   to always try to apply the CopyRect (obstructed regions are usually
   clipped off and not translated).

   Note that some desktops (KDE and xfce) appear to mess with the window
   stacking in ways that are not yet clear. In these cases x11vnc works
   around the problem by applying the CopyRect even if obscuring windows'
   data is translated! Use -nowirecopyrect if this yields undesirable
   effects for your desktop.

   Also, the CopyRect encoding may give incorrect results under -scale
   (depending on the scale factor the CopyRect operation is often only
   approximate: the correctly scaled framebuffer will be slightly
   different from the translated one). x11vnc will try to push a
   "cleanup" update after the CopyRect if -scale is in effect. Use
   -nowirecopyrect if this or other painting errors are unacceptable.


   Q-64: Can x11vnc try to apply heuristics to detect when an window is
   scrolling its contents and use the CopyRect encoding for a speedup?

   Another nice idea for a hack! As of May/2005 x11vnc will by default
   apply heuristics to try to detect if the window that has the input
   focus is scrolling its contents (but only when x11vnc is feeding user
   input, keystroke or pointer, to the X server). So, when detected,
   scrolls induced by dragging on a scrollbar or by typing (e.g. Up or
   Down arrows, hitting Return in a terminal window, etc), will show up
   much more quickly than via the standard x11vnc screen polling update
   mechanism.

   There will be a speedup for both slow and fast links to viewers. For
   slow links the speedup is mostly due to the CopyRect encoding not
   requiring the image data to be transmitted over the network. For fast
   links the speedup is primarily due to x11vnc not having to read the
   scrolled framebuffer data from the X server (recall that reading from
   the hardware framebuffer is [464]slow).

   To do this x11vnc uses the RECORD X extension to snoop the X11
   protocol between the X client with the focus window and the X server.
   This extension is usually present on most X servers (but SuSE disables
   it for some reason). On XFree86/Xorg it can be enabled via Load
   "record" in the Module section of the config file if it isn't already.

   Currently the RECORD extension is used as little as possible so as to
   not slow down regular use. Only simple heuristics are applied to
   detect XCopyArea and XConfigureWindow calls from the application.
   These catch a lot of scrolls, e.g. in mozilla/firefox and in terminal
   windows like gnome-terminal and xterm. Unfortunately the toolkits KDE
   applications use make scroll detection less effective (only rarely are
   they detected: i.e. Konqueror and Konsole don't work). An interesting
   project, that may be the direction x11vnc takes, is to record all of
   the X11 protocol from all clients and try to "tee" the stream into a
   modified Xvfb watching for CopyRect and other VNC speedups. A
   potential issue is the RECORD stream is delayed from actual view on
   the X server display: if one falls too far behind it could become a
   mess...

   The initial implementation of [465]-scrollcopyrect option is useful in
   that it detects many scrolls and thus gives a much nicer working
   environment (especially when combined with the [466]-wireframe
   [467]-wirecopyrect [468]options, which are also on by default; and if
   you are willing to enable the ShadowFB things are very fast). The fact
   that there aren't long delays or lurches during scrolling is the
   primary improvement.

   But there are some drawbacks:
     * Not all scrolls are detected. Some apps scroll windows in ways
       that cannot currently be detected, and other times x11vnc "misses"
       the scroll due to timeouts, etc. Sometimes it is more distracting
       that a speedup occasionally doesn't work as opposed to being
       consistently slow!
     * For rapid scrolling (i.e. sequence of many scrolls over a short
       period) there can be painting errors (tearing, bunching up, etc.)
       during the scroll. These will repair themselves after the scroll
       is over, but when they are severe it can be distracting. Try to
       think of the approximate window contents as a quicker and more
       useful "animation" compared to the slower polling scheme...
     * Scrolling inside shells in terminal windows (gnome-terminal,
       xterm), can lead to odd painting errors. This is because x11vnc
       did not have time to detect a screen change just before the scroll
       (most common is the terminal undraws the block cursor before
       scrolling the text up: in the viewer you temporarily see multiple
       block cursors). Another issue is with things like more(1): scroll
       detection for 5-6 lines happens nicely, but then it can't keep up
       and so there is a long pause for the standard polling method to
       deliver the remaining updates.
     * More rarely sometimes painting errors are not repaired after the
       scroll is over. This may be a bug in x11vnc or libvncserver, or it
       may be an inescapable fact of the CopyRect encoding and the delay
       between RECORD callbacks and what is actually on the X display.
       One can tap the Alt_L key (Left "Alt" key) 3 times in a row to
       signal x11vnc to refresh the screen to all viewers. Your
       VNC-viewer may have its own screen refresh hot-key or button. See
       also: [469]-fixscreen
     * Some applications, notably OpenOffice, do XCopyArea scrolls in
       weird ways that assume ancestor window clipping is taking place.
       See the [470]-scr_skip option for ways to tweak this on a
       per-application basis.
     * Selecting text while dragging the mouse may be slower, especially
       if the Button-down event happens near the window's edge. This is
       because the scrollcopyrect scheme is watching for scrolls via
       RECORD and has to wait for a timeout to occur before it does the
       update.
     * For reasons not yet understood the RECORD extension can stop
       responding (and hence scrolls are missed). As a workaround x11vnc
       attempts to reset the RECORD connection every 60 seconds or so.
       Another workaround is to type 4 Super_L (Left Super/Windows-Flag
       key) in a row to reset RECORD. Work is in progress to try to fix
       this bug.
     * Sometimes you need to "retrain" x11vnc for a certain window
       because it fails to detect scrolls in it. Sometimes clicking
       inside the application window or selecting some text in it to
       force the focus helps.
     * When using the [471]-scale option there will be a quick CopyRect
       scroll, but it needs to be followed by a slower "cleanup" update.
       This is because for a fixed finite screen resolution (e.g. 75 dpi)
       scaling and copyrect-ing are not exactly independent. Scaling
       involves a blending of nearby pixels and if you translate a pixel
       the neighbor pixel weighting may be different. So you have to wait
       a bit for the cleanup update to finish. On slow links x11vnc may
       automatically decide to not detect scrolls when -scale is in
       effect. In general it will also try to defer the cleanup update if
       possible.

   If you find the -scrollcopyrect behavior too approximate or
   distracting you can go back to the standard polling-only update method
   with the [472]-noscrollcopyrect (or -noscr for short). If you find
   some extremely bad and repeatable behavior for -scrollcopyrect please
   report a bug.

   Alternatively, as with -wireframe, there are many tuning parameters to
   try to improve the situation. You can also access these parameters
   inside the gui under "Tuning". These parameters can be tweaked:
     * The minimum pixel area of a rectangle to be watched for scrolls.
     * A list if application names to skip scroll detection.
     * Which keystrokes should trigger scroll detection.
     * Which applications should have a "terminal" tweak applied to them.
     * When repeating keys (e.g. Up arrow) should be discarded to
       preserve a scroll.
     * Cutoffs for closeness to Top, Bottom, Left, and Right edges of
       window for mouse induced scrolls.
     * Set timeout parameters for keystroke induced scrolls.
     * Set timeout parameters for mouse pointer induced scrolls.
     * Have the full screen be periodically refreshed to fix painting
       errors.



   [Mouse Cursor Shapes]

   Q-65: Why isn't the mouse cursor shape (the little icon shape where
   the mouse pointer is) correct as I move from window to window?

   On X servers supporting XFIXES or Solaris/IRIX Overlay extensions it
   is possible for x11vnc to do this correctly. See a few paragraphs down
   for the answer.

   Historically, the X11 mouse cursor shape (i.e. little picture: an
   arrow, X, I-beam, resizer, etc) is one of the few WRITE-only objects
   in X11. That is, an application can tell the X server what the cursor
   shape should be when the pointer is in a given window, but a program
   (like x11vnc) unfortunately cannot read this information. I believe
   this is because the cursor shape is often downloaded to the graphics
   hardware (video card), but I could be mistaken.

   A simple kludge is provided by the "[473]-cursor X" option that
   changes the cursor when the mouse is on the root background (or any
   window has the same cursor as the root background). Note that desktops
   like GNOME or KDE often cover up the root background, so this won't
   work for those cases. Also see the "[474]-cursor some" option for
   additional kludges.

   Note that as of Aug/2004 on Solaris using the SUN_OVL overlay
   extension and IRIX, x11vnc can show the correct mouse cursor when the
   [475]-overlay option is supplied. See [476]this FAQ for more info.

   Also as of Dec/2004 XFIXES X extension support has been added to allow
   exact extraction of the mouse cursor shape. XFIXES fixes the problem
   of the cursor-shape being write-only: x11vnc can now query the X
   server for the current shape and send it back to the connected
   viewers. XFIXES is available on recent Linux Xorg based distros and
   [477]Solaris 10.

   The only XFIXES issue is the handling of alpha channel transparency in
   cursors. If a cursor has any translucency then in general it must be
   approximated to opaque RGB values for use in VNC. There are some
   situations where the cursor transparency can also handled exactly:
   when the VNC Viewer requires the cursor shape be drawn into the VNC
   framebuffer or if you apply a patch to your VNC Viewer to extract
   hidden alpha channel data under 32bpp. [478]Details can be found here.


   Q-66: When using XFIXES cursorshape mode, some of the cursors look
   really bad with extra black borders around the cursor and other cruft.
   How can I improve their appearance?

   This happens for cursors with transparency ("alpha channel"); regular
   X cursors (bitmaps) should be correct. Unfortunately x11vnc 0.7 was
   released with a very poor algorithm for approximating the
   transparency, which led to the ugly black borders.

   The problem is as follows: XFIXES allows x11vnc to retrieve the
   current X server cursor shape, including the alpha channel for
   transparency. For traditional bitmap cursors the alpha value will be 0
   for completely transparent pixels and 255 for completely opaque
   pixels; whereas for modern, eye-candy cursors an alpha value between 0
   and 255 means to blend in the background colors to that degree with
   the cursor colors. The pixel color blending formula is something like
   this: Red = Red_cursor * a + Red_background * (1 - a), (where here 0
   =< a =< 1), with similar for Green and Blue. The VNC protocol does not
   currently support an alpha channel in cursors: it only supports
   regular X bitmap cursors and Rich Cursors that have RGB (Red, Green,
   Blue) color data, but no "A" = alpha data. So in general x11vnc has to
   approximate a cursor with transparency to create a Rich Cursor. This
   is easier said than done: some cursor themes have cursors with
   complicated drop shadows and other forms of translucency.

   Anyway, for the x11vnc 0.7.1 release the algorithm for approximating
   transparency is much improved and hopefully gives decent cursor shapes
   for most cursor themes and you don't have to worry about it.

   In case it still looks bad for your cursor theme, there are (of
   course!) some tunable parameters. The "[479]-alphacut n" option lets
   you set the threshold "n" (between 0 and 255): cursor pixels with
   alpha values below n will be considered completely transparent while
   values equal to or above n will be completely opaque. The default is
   240. The "[480]-alphafrac f" option tries to correct individual
   cursors that did not fare well with the default -alphacut value: if a
   cursor has less than fraction f (between 0.0 and 1.0) of its pixels
   selected by the default -alphacut, the threshold is lowered until f of
   its pixels are selected. The default fraction is 0.33.

   Finally, there is an option [481]-alpharemove that is useful for
   themes where many cursors are light colored (e.g. "whiteglass").
   XFIXES returns the cursor data with the RGB values pre-multiplied by
   the alpha value. If the white cursors look too grey, specify
   -alpharemove to brighten them by having x11vnc divide out the alpha
   value.

   One user played with these parameters and reported back:
 Of the cursor themes present on my system:

   gentoo and gentoo-blue:   alphacut:192 - noalpharemove

   gentoo-silver:            alphacut:127 and alpharemove

   whiteglass and redglass (presumably also handhelds, which is based
   heavily on redglass) look fine with the apparent default of alphacut:255.


   Q-67: In XFIXES mode, are there any hacks to handle cursor
   transparency ("alpha channel") exactly?

   As of Jan/2005 libvncserver has been modified to allow an alpha
   channel (i.e. RGBA data) for Rich Cursors. So x11vnc can now send the
   alpha channel data to libvncserver. However, this data will only be
   used for VNC clients that do not support the CursorShapeUpdates VNC
   extension (or have disabled it). It can be disabled for all clients
   with the [482]-nocursorshape x11vnc option. In this case the cursor is
   drawn, correctly blended with the background, into the VNC framebuffer
   before being sent out to the client. So the alpha blending is done on
   the x11vnc side. Use the [483]-noalphablend option to disable this
   behavior (always approximate transparent cursors with opaque RGB
   values).

   The CursorShapeUpdates VNC extension complicates matters because the
   cursor shape is sent to the VNC viewers supporting it, and the viewers
   draw the cursor locally. This improves response over slow links. Alpha
   channel data for these locally drawn cursors is not supported by the
   VNC protocol.

   However, in the libvncserver CVS there is a patch to the TightVNC
   viewer to make this work for CursorShapeUpdates under some
   circumstances. This hack is outside of the VNC protocol. It requires
   the screens on both sides to be depth 24 at 32bpp (it uses the extra 8
   bits to secretly hide the cursor alpha channel data). Not only does it
   require depth 24 at 32bpp, but it also currently requires the client
   and server to be of the same endianness (otherwise the hidden alpha
   data gets reset to zero by a libvncserver translation function; we can
   fix this at some point if there is interest). The patch is for the
   TightVNC 1.3dev5 Unix vncviewer and it enables the TightVNC viewer to
   do the cursor alpha blending locally. The patch code should give an
   example on how to change the Windows TightVNC viewer to achieve the
   same thing (send me the patch if you get that working).

   [Mouse Pointer]

   Q-68: Why does the mouse arrow just stay in one corner in my
   vncviewer, whereas my cursor (that does move) is just a dot?

   This default takes advantage of a [484]tightvnc extension
   (CursorShapeUpdates) that allows specifying a cursor image shape for
   the local VNC viewer. You may disable it with the [485]-nocursor
   option to x11vnc if your viewer does not have this extension.

   Note: as of Aug/2004 this should be fixed: the default for
   non-tightvnc viewers (or ones that do not support CursorShapeUpdates)
   will be to draw the moving cursor into the x11vnc framebuffer. This
   can also be disabled via -nocursor.


   Q-69: Can I take advantage of the TightVNC extension to the VNC
   protocol where Cursor Positions Updates are sent back to all connected
   clients (i.e. passive viewers can see the mouse cursor being moved
   around by another viewer)?

   Use the [486]-cursorpos option when starting x11vnc. A VNC viewer must
   support the Cursor Positions Updates for the user to see the mouse
   motions (the TightVNC viewers support this). As of Aug/2004 -cursorpos
   is the default. See also [487]-nocursorpos and [488]-nocursorshape.


   Q-70: Is it possible to swap the mouse buttons (e.g. left-handed
   operation), or arbitrarily remap them? How about mapping button clicks
   to keystrokes, e.g. to partially emulate Mouse wheel scrolling?

   You can remap the mouse buttons via something like: [489]-buttonmap
   13-31 (or perhaps 12-21). Also, note that xmodmap(1) lets you directly
   adjust the X server's button mappings, but in some circumstances it
   might be more desirable to have x11vnc do it.

   One user had an X server with only one mouse button(!) and was able to
   map all of the VNC client mouse buttons to it via: -buttonmap 123-111.

   Note that the [490]-debug_pointer option prints out much info for
   every mouse/pointer event and is handy in solving problems.

   To map mouse button clicks to keystrokes you can use the alternate
   format where the keystrokes are enclosed between colons like this
   :<KeySym>: in place of the mouse button digit. For a sequence of
   keysyms separate them with "+" signs. Look in the include file
   <X11/keysymdef.h>, or use xev(1), or -debug_keyboard to fine the
   keysym names. Button clicks can also be included in the sequence via
   the fake keysyms Button1, etc.

   As an example, suppose the VNC viewer machine has a mouse wheel (these
   generate button 4 and 5 events), but the machine that x11vnc is run on
   only has the 3 regular buttons. In normal operation x11vnc will
   discard the button 4 and 5 events. However, either of the following
   button maps could possibly be of use emulating the mouse wheel events
   in this case:
  -buttonmap 12345-123:Prior::Next:
  -buttonmap 12345-123:Up+Up+Up::Down+Down+Down:

   Exactly what keystroke "scrolling" events they should be bound to
   depends on one's taste. If this method is too approximate, one could
   consider not using [491]-buttonmap but rather configuring the X server
   to think it has a mouse with 5 buttons even though the physical mouse
   does not. (e.g. 'Option "ZAxisMapping" "4 5"').

   Note that when a keysym-mapped mouse button is clicked down this
   immediately generates the key-press and key-release events (for each
   keysym in turn if the mapping has a sequence of keysyms). When the
   mouse button goes back up nothing is generated.

   If you include modifier keys like Shift_L instead of key-press
   immediately followed by key-release the state of the modifier key is
   toggled (however the initial state of the modifier key is ignored). So
   to map the right button to type my name 'Karl Runge' I could use this:
  -buttonmap 3-:Shift_L+k+Shift_L+a+r+l+space+Shift_L+r+Shift_L+u+n+g+e:

   (yes, this is getting a little silly).

   BTW, Coming the other way around, if the machine you are sitting at
   does not have a mouse wheel, but the remote machine does (or at least
   has 5 buttons configured), this key remapping can be useful:
  -remap Super_R-Button4,Menu-Button5

   you just tap those two keys to get the mouse wheel scrolls (this is
   more useful than the Up and Down arrow keys because a mouse wheel
   "click" usually gives a multi-line scroll).
   [Keyboard Issues]

   Q-71: How can I get my AltGr and Shift modifiers to work between
   keyboards for different languages?

   The option [492]-modtweak should help here. It is a mode that monitors
   the state of the Shift and AltGr Modifiers and tries to deduce the
   correct keycode to send, possibly by sending fake modifier key presses
   and releases in addition to the actual keystroke.

   Update:  As of Jul/2004 -modtweak is now the default (use -nomodtweak
   to get the old behavior). This was done because it was noticed on
   newer XFree86 setups even on bland "us" keyboards like "pc104 us"
   XFree86 included a "ghost" key with both "<" and ">" it. This key does
   not exist on the keyboard (see [493]this FAQ for more info). Without
   -modtweak there was then an ambiguity in the reverse map keysym =>
   keycode, making it so the "<" symbol could not be typed.

   Also see the [494]FAQ about the -xkb option for a more powerful method
   of modifier tweaking for use on X servers with the XKEYBOARD
   extension.

   When trying to resolve keyboard mapping problems, note that the
   [495]-debug_keyboard option prints out much info for every keystroke
   and so can be useful debugging things.


   Q-72: When I try to type a "<" (i.e. less than) instead I get ">"
   (i.e. greater than)! Strangely, typing ">" works OK!!

   Does your keyboard have a single key with both "<" and ">" on it? Even
   if it doesn't, your X server may think your keyboard has such a key
   (e.g. pc105 in the XF86Config file when it should be something else,
   say pc104).

   Short Cut: Try the [496]-xkb or [497]-sloppy_keys options and see if
   that helps the situation. The discussion below is a bit outdated (e.g.
   [498]-modtweak is now the default) but is useful reference for various
   tricks and so is kept.


   The problem here is that on the Xserver where x11vnc is run there are
   two keycodes that correspond to the "<" keysym. Run something like
   this to see:

  xmodmap -pk | egrep -i 'KeyCode|less|greater'
  There are 4 KeySyms per KeyCode; KeyCodes range from 8 to 255.
      KeyCode     Keysym (Keysym) ...
       59         0x002c (comma)  0x003c (less)
       60         0x002e (period) 0x003e (greater)
       94         0x003c (less)   0x003e (greater)

   That keycode 94 is the special key with both "<" and ">". When x11vnc
   receives the "<" keysym over the wire from the remote VNC client, it
   unfortunately maps it to keycode 94 instead of 59, and sends 94 to the
   X server. Since Shift is down (i.e. you are Shifting the comma key),
   the X server interprets this as Shifted-94, which is ">".

   A workaround in the X server configuration is to "deaden" that special
   key:

  xmodmap -e "keycode 94 = "

   However, one user said he had to do this:

  xmodmap -e "keycode 94 = 0x002c 0x003c"

   (If the numerical values are different for your setup, substitute the
   ones that correspond to your display. The above xmodmap scheme can
   often be used to work around other ambiguous keysym to keycode
   mappings).

   Alternatively, here are some x11vnc options to try to work around the
   problem:
   -modtweak

   and
   -remap less-comma

   These are convenient in that they do not modify the actual X server
   settings. The former ([499]-modtweak) is a mode that monitors the
   state of the Shift and AltGr modifiers and tries to deduce the correct
   keycode sequence to send. Since Jul/2004 -modtweak is now the default.
   The latter ([500]-remap less-comma) is an immediate remapping of the
   keysym less to the keysym comma when it comes in from a client (so
   when Shift is down the comma press will yield "<").

   See also the [501]FAQ about the -xkb option as a possible workaround
   using the XKEYBOARD extension.

   Note that the [502]-debug_keyboard option prints out much info for
   every keystroke to aid debugging keyboard problems.


   Q-73: When I try to type a "<" (i.e. less than) instead I get "<,"
   (i.e. an extra comma).

   This is likely because you press "Shift" then "<" but then released
   the Shift key before releasing the "<". Because of a [503]keymapping
   ambiguity the last event "< up" is interpreted as "," because that key
   unshifted is the comma.

   This should not happen in [504]-xkb mode, because it works hard to
   resolve the ambiguities. If you do not want to use -xkb, try the
   option [505]-sloppy_keys to attempt a similar type of algorithm.


   Q-74: I'm using an "international" keyboard (e.g. German "de", or
   Danish "dk") and the -modtweak mode works well if the VNC viewer is
   run on a Unix/Linux machine with a similar keyboard.   But if I run
   the VNC viewer on Unix/Linux with a different keyboard (e.g. "us") or
   Windows with any keyboard, I can't type some keys like:   "@", "$",
   "<", ">", etc. How can I fix this?

   The problem with Windows is it does not seem to handle AltGr well. It
   seems to fake it up by sending Control_L+Alt_R to applications. The
   Windows VNC viewer sends those two down keystrokes out on the wire to
   the VNC server, but when the user types the next key to get, e.g., "@"
   the Windows VNC viewer sends events bringing the up the
   Control_L+Alt_R keys, and then sends the "@" keysym by itself.

   The Unix/Linux VNC viewer on a "us" keyboard does a similar thing
   since "@" is the Shift of the "2" key. The keysyms Shift and "@" are
   sent to the VNC server.

   In both cases no AltGr is sent to the VNC server, but we know AltGr is
   needed on the physical international keyboard to type a "@".

   This all worked fine with x11vnc running with the [506]-modtweak
   option (it figures out how to adjust the Modifier keys (Shift or
   AltGr) to get the "@"). However it fails under recent versions of
   XFree86 (and the X.org fork). These run the XKEYBOARD extension by
   default and make heavy use of it to handle international keyboards.

   To make a long story short, on these newer XFree86 setups the
   traditional X keymap lookup x11vnc uses is no longer accurate. x11vnc
   can't find the keysym "@" anywhere in the keymapping! (even though it
   is in the XKEYBOARD extended keymapping).

   How to Solve: As of Jul/2004 x11vnc has two changes:
     * -modtweak (tweak Modifier keys) is now the default (use
       -nomodtweak to go back to the old way)
     * there is a new option -xkb to use the XKEYBOARD extension API to
       do the Modifier key tweaking.

   The [507]-xkb option seems to fix all of the missing keys: "@", "<",
   ">", etc.: it is recommended that you try it if you have this sort of
   problem. Let us know if there are any remaining problems (see the next
   paragraph for some known problems). If you specify the -debug_keyboard
   (aka -dk) option twice you will get a huge amount of keystroke
   debugging output (send it along with any problems you report).

   Update: as of Jun/2005 x11vnc will try to automatically enable
   [508]-xkb if it appears that would be beneficial (e.g. if it sees any
   of "@", "<", ">", "[" and similar keys are mapped in a way that needs
   the -xkb to access them). To disable this automatic check use -noxkb.

   Known problems:
     * One user had to disable a "ghost" Mode_switch key that was causing
       problems under -xkb. His physical AltGr key was bound to
       ISO_Level3_Shift (which seems to be the XKEYBOARD way of doing
       things), while there was a ghost key Mode_switch (which seems to
       be obsolete) in the mapping as well. Both of these keysyms were
       bound to Mod5 and x11vnc was unfortunately choosing Mode_switch.
       From the x11vnc -xkb -dk -dk output it was noted that Mode_switch
       was attached to keycode 93 (no physical key generates this
       keycode) while ISO_Level3_Shift was attached to keycode 113. The
       keycode skipping option was used to disable the ghost key:
       [509]-skip_keycodes 93
     * In implementing -xkb we noticed that some characters were still
       not getting through, e.g. "~" and "^". This is not really an
       XKEYBOARD problem. What was happening was the VNC viewer was
       sending the keysyms asciitilde and asciicircum to x11vnc, but on
       the X server with the international keyboard those keysyms were
       not mapped to any keys. So x11vnc had to skip them.
       The way these characters are typically entered on international
       keyboards is by "dead" (aka "mute") keys. E.g. to enter "~" at the
       physical display the keysym dead_tilde is pressed and released
       (this usually involves holding AltGr down while another key is
       pressed) and then space is pressed. (this can also be used get
       characters with the "~" symbol on top, e.g. "" by typing "a"
       instead of space).
       What to do? In general the VNC protocol has not really solved this
       problem: what should be done if the VNC viewer sends a keysym not
       recognized by the VNC server side? Workarounds can possibly be
       created using the [510]-remap x11vnc option:
  -remap asciitilde-dead_tilde,asciicircum-dead_circumflex
       etc. Use -remap filename if the list is long. Please send us your
       workarounds for this problem on your keyboard. Perhaps we can have
       x11vnc adjust automatically at some point. Also see the
       [511]-add_keysyms option in the next paragraph.
       Update: for convenience "[512]-remap DEAD" does many of these
       mappings at once.
     * To complement the above workaround using the [513]-remap, an
       option [514]-add_keysyms was added. This option instructs x11vnc
       to bind any unknown Keysyms coming in from VNC viewers to unused
       Keycodes in the X server. This modifies the global state of the X
       server. When x11vnc exits it removes the extra keymappings it
       created. Note that the -remap mappings are applied first, right
       when the Keysym is received from a VNC viewer, and only after that
       would -add_keysyms, or anything else, come into play.
       Update: -add_keysyms is now on by default. Use -noadd_keysyms to
       disable.


   Q-75: When typing I sometimes get double, triple, or more of my
   keystrokes repeated. I'm sure I only typed them once, what can I do?

   This may be due to an interplay between your X server's key autorepeat
   delay and the extra time delays caused by x11vnc processing.

   Short answer: disable key autorepeating by running the command "xset r
   off" on the Xserver where x11vnc is run (restore via "xset r on") or
   use the new (Jul/2004) [515]-norepeat x11vnc option. You will still
   have autorepeating because that is taken care of on your VNC viewer
   side.

   Update: as of Dec/2004 -norepeat is now the default. Use -repeat to
   disable it.

   Details: suppose you press a key DOWN and it generates changes in
   large regions of the screen. The CPU and I/O work x11vnc does for the
   large screen change could be longer than your X server's key
   autorepeat delay. x11vnc may not get to processing the key UP event
   until after the screen work is completed. The X server believes the
   key has been held down all this time, and applies its autorepeat
   rules.

   Even without inducing changes in large regions of the screen, this
   problem could arise when accessing x11vnc via a dialup modem or
   otherwise high latency link (e.g. > 250 ms latency).

   Look at the output of "xset q" for the "auto repeat delay" setting. Is
   it low (e.g. < 300 ms)? If you turn off autorepeat completely: "xset r
   off", does the problem go away?

   The workaround is to manually apply "xset r off" and "xset r on" as
   needed, or to use the [516]-norepeat (which has since Dec/2004 been
   made the default). Note that with X server autorepeat turned off the
   VNC viewer side of the connection will (nearly always) do its own
   autorepeating so there is no big loss here, unless someone is also
   working at the physical display and misses his autorepeating.


   Q-76: The x11vnc -norepeat mode is in effect, but I still get repeated
   keystrokes!!

   Are you using x11vnc to log in to an X session? (as described in
   [517]this FAQ) If so, x11vnc is starting before your session and it
   disables autorepeat when you connect, but then after you log in your
   session startup (GNOME, KDE, ...) could be resetting the autorepeat to
   be on. Or it could be something inside your desktop trying to be
   helpful that decides to turn it back on.

   x11vnc in -norepeat mode will by default reset autorepeat to off 2
   times (to help get thru the session startup problem), but it will not
   continue to battle with things turning autorepeat back on. It will
   also turn autorepeat off whenever it goes from a state of zero clients
   to one client. You can adjust the number of resets via "-norepeat N",
   or use "-norepeat -1" to have it keep resetting it whenever autorepeat
   gets turned back on when clients are connected.

   In general you can manually turn autorepeating off by typing "xset r
   off", or a using desktop utility/menu, or "x11vnc -R norepeat". If
   something in your desktop is automatically turning it back on you
   should figure out how to disable that somehow.


   Q-77: The machine where I run x11vnc has an AltGr key, but the local
   machine where I run the VNC viewer does not. Is there a way I can map
   a local unused key to send an AltGr? How about a Compose key as well?

   Something like "[518]-remap Super_R-Mode_switch" x11vnc option may
   work. Note that Super_R is the "Right Windoze(tm) Flaggie" key; you
   may want to choose another. The -debug_keyboard option comes in handy
   in finding keysym names (so does xev(1)).

   For Compose how about "-remap Menu-Multi_key" (note that Multi_key is
   the official name for Compose). To do both at the same time: "-remap
   Super_R-Mode_switch,Menu-Multi_key" or use "-remap filename" to
   specify remappings from a file.


   Q-78: I have a Sun machine I run x11vnc on. Its Sun keyboard has just
   one Alt key labelled "Alt" and two Meta keys labelled with little
   diamonds. The machine where I run the VNC viewer only has Alt keys.
   How can I send a Meta keypress? (e.g. emacs needs this)

   Here are a couple ideas. The first one is to simply use xmodmap(1) to
   adjust the Sun X server. Perhaps xmodmap -e "keysym Alt_L = Meta_L
   Alt_L" will do the trick. (there are other ways to do it, one user
   used: xmodmap -e "keycode 26 = Meta_L" for his setup).

   Since xmodmap(1) modifies the X server mappings you may not want to do
   this (because it affects local work on that machine). Something like
   the [519]-remap Alt_L-Meta_L to x11vnc may be sufficient for ones
   needs, and does not modify the X server environment. Note that you
   cannot send Alt_L in this case, maybe -remap Super_L-Meta_L would be a
   better choice if the Super_L key is typically unused in Unix.


   Q-79: Can I map a keystroke to a mouse button click on the remote
   machine?

   This can be done directly in some X servers using AccessX and
   Pointer_EnableKeys, but is a bit awkward. It may be more convenient to
   have x11vnc do the remapping. This can be done via the [520]-remap
   option using the fake "keysyms" Button1, Button2, etc. as the "to"
   keys (i.e. the ones after the "-")

   As an example, consider a laptop where the VNC viewer is run that has
   a touchpad with only two buttons. It is difficult to do a middle
   button "paste" because (using XFree86/Xorg Emulate3Buttons) you have
   to click both buttons on the touch pad at the same time. This
   remapping:
  [521]-remap Super_R-Button2

   maps the Super_R "flag" key press to the Button2 click, thereby making
   X pasting a bit easier.

   Note that once the key goes down, the button down and button up events
   are generated immediately on the x11vnc side. When the key is released
   (i.e. goes up) no events are generated.

   Q-80: How can I get Caps_Lock to work between my VNC viewer and
   x11vnc?

   This is a little tricky because it is possible to get the Caps_Lock
   state out of sync between your viewer-side machine and the x11vnc-side
   X server. For best results, we recommend not ever letting the
   Caps_Lock keypresses be processed by x11vnc. That way when you press
   Caps_Lock in the viewer your local machine goes into the Caps_Lock on
   state and sends keysym "A" say when you press "a". x11vnc will then
   fake things up so that Shift is held down to generate "A". The
   [522]-skip_lockkeys option should help to accomplish this. For finer
   grain control use something like: "[523]-remap Caps_Lock-None".

   Also try the [524]-nomodtweak and [525]-capslock options.

   [Screen Related Issues and Features]

   Q-81: The remote display is larger (in number of pixels) than the
   local display I am running the vncviewer on. I don't like the
   vncviewer scrollbars, what I can do?

   vncviewer has a option (usually accessible via F8 key or -fullscreen
   option) for vncviewer to run in full screen, where it will
   automatically scroll when the mouse is near the edge of the current
   view. For quick scrolling, also make sure Backing Store is enabled on
   the machine vncviewer is run on. (XFree86/Xorg disables it by default
   for some reason, add Option "backingstore" to XF86Config on the
   vncviewer side).

   BTW, contact me if you are having problems with vncviewer in
   fullscreen mode with your window manager (i.e. no keyboard response).
   I have a workaround for vncviewer using XGrabServer().

   There may also be scaling viewers out there (e.g. TightVNC or UltraVNC
   on Windows) that automatically shrink or expand the remote framebuffer
   to fit the local display. Especially for hand-held devices. See also
   [526]this FAQ on x11vnc scaling.


   Q-82: Does x11vnc support server-side framebuffer scaling? (E.g. to
   make the desktop smaller).

   As of Jun/2004 x11vnc provides basic server-side scaling. It is a
   global scaling of the desktop, not a per-client setting. To enable it
   use the "[527]-scale fraction" option. "fraction" can either be a
   floating point number (e.g. -scale 0.5) or the alternative m/n
   fraction notation (e.g. -scale 3/4). Note that if fraction is greater
   than one the display is magnified.

   Extra resources (CPU, memory I/O, and memory) are required to do the
   scaling. If the machine is slow where x11vnc is run with scaling
   enabled, the interactive response can be unacceptable. OTOH, if run
   with scaling on a fast machine the performance degradation is usually
   not a big issue or even noticeable.

   Also, if you just want a quick, rough "thumbnail" of the display you
   can append ":nb" to the fraction to turn on "no blending" mode. E.g.:
   "-scale 1/3:nb" Fonts will be difficult to read, but the larger
   features will be recognizable. BTW, "no blending" mode is forced on
   when scaling 8bpp PseudoColor displays (because blending an indexed
   colormap is a bad idea and leads to random colors, use :fb to force it
   on).

   One can also use the ":nb" with an integer scale factor (say "-scale
   2:nb") to use x11vnc as a screen magnifier for vision impaired
   [528]applications. Since with integer scale factors the framebuffers
   become huge and scaling operations time consuming, be sure to use
   ":nb" for the fastest response.

   In general for a scaled display if you are using a TightVNC viewer you
   may want to turn off jpeg encoding (e.g. vncviewer -nojpeg host:0).
   There appears to be a noise enhancement effect, especially for regions
   containing font/text: the scaling can introduce some pixel artifacts
   that evidently causes the tight encoding algorithm to incorrectly
   detect the regions as image data and thereby introduce additional
   pixel artifacts due to the lossiness of the jpeg compression
   algorithm. Experiment to see if -nojpeg vncviewer option improves the
   readability of text when using -scale to shrink the display size. Also
   note that scaling may actually slow down the transfer of text regions
   because after being scaled they do not compress as well. (this can
   often be a significant slowdown, e.g. 10X).

   Another issue is that it appears VNC viewers require the screen width
   to be a multiple of 4. When scaling x11vnc will round the width to the
   nearest multiple of 4. To disable this use the ":n4" sub option (like
   ":nb" in the previous paragraph; to specify both use a comma:
   ":nb,n4", etc.)

   If one desires per-client scaling for something like 1:1 from a
   workstation and 1:2 from a smaller device (e.g. handheld), currently
   the only option is to run two (or more) x11vnc processes with
   different scalings listening on separate ports ([529]-rfbport option,
   etc.).

   Update: As of May/2006 x11vnc also supports the UltraVNC server-side
   scaling. This is a per-client scaling by factors 1/2, 1/3, ... and so
   may be useful for PDA's ("-scale 1/2", etc. will give similar results
   except that it applies to all clients). You may need to supply
   "-rfbversion 3.6" for this to be recognized by UltraVNC viewers.

   BTW, whenever you run two or more x11vnc's on the same X display and
   use the [530]GUI, then to avoid all of the x11vnc's simultaneously
   answering the gui you will need to use something like [531]"-connect
   file1 -gui ..." with different connect files for each x11vnc you want
   to control via the gui (or remote-control). The "-connect file1" usage
   gives separate communication channels between a x11vnc proces and the
   gui process. Otherwise they all share the same X property channels:
   VNC_CONNECT and X11VNC_REMOTE.

   Update: As of Mar/2005 x11vnc now scales the mouse cursor with the
   same scale factor as the screen. If you don't want that, use the
   [532]"-scale_cursor frac" option to set the cursor scaling to a
   different factor (e.g. use "-scale_cursor 1" to keep the cursor at its
   natural unscaled size).


   Q-83: Does x11vnc work with Xinerama? (i.e. multiple monitors joined
   together to form one big, single screen).

   Yes, it should generally work because it simply polls the big
   effective screen.

   If the viewing-end monitor is not as big as the remote Xinerama
   display, then the vncviewer scrollbars, etc, will have to be used to
   pan across the large area. However one user started two x11vnc's, one
   with "-clip 1280x1024+0+0" and the other with "-clip 1280x1024+1280+0"
   to split the big screen into two and used two VNC viewers to access
   them.

   There are a couple potential issues with Xinerama however. If the
   screen is not rectangular (e.g. 1280x1024 and 1024x768 monitors joined
   together), then there will be "non-existent" areas on the screen. The
   X server will return "garbage" image data for these areas and so they
   may be distracting to the viewer. The [533]-blackout x11vnc option
   allows you to blacken-out rectangles by manually specifying their
   WxH+X+Y geometries. If your system has the libXinerama library, the
   [534]-xinerama x11vnc option can be used to have it automatically
   determine the rectangles to be blackened out. (Note on 8bpp
   PseudoColor displays the fill color may not be black). Update:
   [535]-xinerama is now on by default.

   Some users have reported that the mouse does not behave properly for
   their Xinerama display: i.e. the mouse cannot be moved to all regions
   of the large display. If this happens try using the [536]-xwarppointer
   option. This instructs x11vnc to fake mouse pointer motions using the
   XWarpPointer function instead of the XTestFakeMotionEvent XTEST
   function. (This may be due to a bug in the X server for XTEST when
   Xinerama is enabled).


   Q-84: Can I use x11vnc on a multi-headed display that is not Xinerama
   (i.e. separate screens :0.0, :0.1, ... for each monitor)?

   You can, but it is a little bit awkward: you must start separate
   x11vnc processes for each screen, and on the viewing end start up
   separate VNC viewer processes connecting to them. e.g. on the remote
   end:
  x11vnc -display :0.0 -bg -q -rfbport 5900
  x11vnc -display :0.1 -bg -q -rfbport 5901

   (this could be automated in the display manager Xsetup for example)
   and then on the local machine where you are sitting:
  vncviewer somehost:0 &
  vncviewer somehost:1 &

   Note: if you are running on Solaris 8 or earlier you can easily hit up
   against the maximum of 6 shm segments per process (for Xsun in this
   case) from running multiple x11vnc processes. You should modify
   /etc/system as mentioned in another [537]FAQ to increase the limit. It
   is probably also a good idea to run with the [538]-onetile option in
   this case (to limit each x11vnc to 3 shm segments), or even
   [539]-noshm to use no shm segments.


   Q-85: Can x11vnc show only a portion of the display? (E.g. for a
   special purpose rfb application).

   As of Mar/2005 x11vnc has the "[540]-clip WxH+X+Y" option to select a
   rectangle of width W, height H and offset (X, Y). Thus the VNC screen
   will be the clipped sub-region of the display and be only WxH in size.
   One user used -clip to split up a large [541]Xinerama screen into two
   more managable smaller screens.

   This also works to view a sub-region of a single application window if
   the [542]-id or [543]-sid options are used. The offset is measured
   from the upper left corner of the selected window.


   Q-86: Does x11vnc support the XRANDR (X Resize, Rotate and Reflection)
   extension? Whenever I rotate or resize the screen x11vnc just seems to
   crash.

   As of Dec/2004 x11vnc supports XRANDR. You enable it with the
   [544]-xrandr option to make x11vnc monitor XRANDR events and also trap
   X server errors if the screen change occurred in the middle of an X
   call like XGetImage. Once it traps the screen change it will create a
   new framebuffer using the new screen.

   If the connected vnc viewers support the NewFBSize VNC extension
   (Windows TightVNC viewer and RealVNC 4.0 windows and Unix viewers do)
   then the viewer will automatically resize. Otherwise, the new
   framebuffer is fit as best as possible into the original viewer size
   (portions of the screen may be clipped, unused, etc). For these
   viewers you can try the [545]-padgeom option to make the region big
   enough to hold all resizes and rotations.

   If you specify "-xrandr newfbsize" then vnc viewers that do not
   support NewFBSize will be disconnected before the resize. If you
   specify "-xrandr exit" then all will be disconnected and x11vnc will
   terminate.


   Q-87: Why is the view in my VNC viewer completely black? Or why is
   everything flashing around randomly?

   See the next FAQ for a possible explanation.


   Q-88: I use Linux Virtual Consoles (VC's) to implement 'Fast User
   Switching' between users' sessions (e.g. Betty is on Ctrl-Alt-F7,
   Bobby is on Ctrl-Alt-F8, and Sid is on Ctrl-Alt-F1: they use those
   keystrokes to switch between their sessions).   How come the view in a
   VNC viewer connecting to x11vnc is either completely black or
   otherwise all messed up unless the X session x11vnc is attached to is
   in the active VC?

   This seems to have to do with how applications (the X server processes
   in this case) must "play nicely" if they are not on the active VC
   (sometimes called VT for virtual terminal). That is, they should not
   read from the keyboard or mouse or manage the video display unless
   they have the active VC. Given that it appears the XGetImage() call
   must ultimately retrieve the framebuffer data from the video hardware
   itself, it would make sense x11vnc's polling wouldn't work unless the
   X session had active control of the VC.

   There does not seem to be an easy way to work around this. Even xwd(1)
   doesn't work in this case (try it). Something would need to be done at
   a lower level, say in the XFree86 X server. Also, using the XFree86
   Shadow Framebuffer (a copy of the video framebuffer is kept in main
   memory) does not appear to fix the problem.

   If no one is sitting at the workstation and you just want to remotely
   switch the VC over to the one associated with your X session (so
   x11vnc can poll it correctly), one can use the chvt(1) command, e.g.
   "chvt 7" for VC #7.


   Q-89: Can I use x11vnc to view my VMWare session remotely?

   Yes, since VMWare is an X application you can view it via x11vnc in
   the normal way.

   Note that VMWare has several viewing modes:
     * Normal X application window  (with window manager frame)
     * Quick-Switch mode  (with no window manager frame)
     * Fullscreen mode

   The way VMWare does Fullscreen mode on Linux is to display the Guest
   desktop in a separate Virtual Console (e.g. VC 8) (see [546]this FAQ
   on VC's for background). Unfortunately, this Fullscreen VC is not an X
   server. So x11vnc cannot access it (however, [547]see this for a
   possible partial workaround). x11vnc works fine with "Normal X
   application window" and "Quick-Switch mode" because these use X.

   Update: It appears the in VMWare 5.x the Fullscreen mode is X, so
   x11vnc access does work.

   One user reports he left his machine with VMWare in the Fullscreen
   mode, and even though his X session wasn't in the active VC, he could
   still connect x11vnc to the X session and pass the keystrokes Ctrl-Alt
   (typing "blind") to the VMWare X app. This induced VMWare to switch
   out of Fullscreen into Normal X mode and he could continue working in
   the Guest desktop remotely.


   Sometimes it is convenient (for performance, etc.) to start VMWare in
   its own X session using startx(1). This can be used to have a minimal
   window manger (e.g. twm or even no window manager), to improve
   response. One can also cut the display depth (e.g. to 16bpp) in this
   2nd X session to improve video performance. This 2nd X session
   emulates Fullscreen mode to some degree and can be viewed via x11vnc
   as long as the VMWare X session [548]is in the active VC.

   Also note that with a little bit of playing with "xwininfo -all
   -children" output one can extract the (non-toplevel) windowid of the
   of the Guest desktop only when VMWare is running as a normal X
   application. Then one can export just the guest desktop (i.e. without
   the VMWare menu buttons) by use of the [549]-id windowid option. The
   caveats are the X session VMWare is in must be in the active VC and
   the window must be fully visible, so this mode is not terribly
   convenient, but could be useful in some circumstances (e.g. running
   VMWare on a very powerful server machine in a server room that happens
   to have a video card, (but need not have a monitor, Keyboard or
   mouse)).


   Q-90: Can non-X devices (e.g. a raw framebuffer) be viewed (and even
   controlled) with VNC via x11vnc?

   As of Apr/2005 there is rudimentary support for this. Two options were
   added: "-rawfb string" (to indicate the raw framembuffer and its
   parameters) and "-pipeinput cmd" (to provide an external program that
   will inject or otherwise process mouse and keystroke input).

   This non-X mode for x11vnc is experimental because it is so removed in
   scope from the intended usage of the tool. Incomplete attempt is made
   to make all of the other options consistent with non-X framebuffer
   polling. So all of the X-related options (e.g. -add_keysyms, -xkb) are
   just ignored or in the worst case will cause a crash. Be careful
   applying such an option via the command line or remote control.

   The format for the -rawfb string is:
    -rawfb <type>:<object>@<W>x<H>x<bpp>[:<R>/<G>/<B>][+<offset>]

   Some examples:
    -rawfb shm:210337933@800x600x32:ff/ff00/ff0000

    -rawfb map:/dev/fb0@1024x768x16

    -rawfb map:/tmp/Xvfb_screen0@640x480x8+3232

    -rawfb file:/tmp/my.pnm@250x200x24+37

    -rawfb file:/dev/urandom@128x128x8

    -rawfb snap:/dev/video0@320x240x24 -24to32

   So the type can be "shm" for shared memory objects, and "map" or
   "file" for file objects. "map" uses mmap(2) to map the file into
   memory and is preferred over "file" (that uses the slower lseek(2)
   access method). Only use file if map isn't working. BTW, "mmap" is an
   alias for "map" and if you do not supply a type and the file exists,
   map is assumed. The "snap:" setting applies the [550]-snapfb option
   with "file:" type reading (this is useful for exporting webcams or TV
   tuner video; see [551]the next FAQ for more info).

   Also, if the string is of the form "setup:cmd" then cmd is run and the
   first line of its output retrieved and used as the rawfb string. This
   allows initializing the device, determining WxHxB, etc.

   The object will be the numerical shared memory id for the case of shm.
   The idea here is some other program has created this shared memory
   segment and periodically updates it with new framebuffer data. x11vnc
   polls the area for changes. See shmat(2) and ipcs(8) for more info.
   The ipcs command will list current shared memory segments on the
   system. Sometimes you can snoop on a program's framebuffer it did not
   expect you would be polling.

   The object will be the path to the regular or character special file
   for the cases of map and file. The idea here is that in the case of a
   regular file some other program is writing/updating framebuffer image
   data to it. In the case of a character special (e.g. /dev/fb0) it is
   the kernel that is "updating" the framebuffer data.

   In most cases x11vnc needs to be told the width, height, and number of
   bits per pixel (bpp) of the framebuffer. This is the @WxHxB field. For
   the case of the Linux framebuffer device, /dev/fb0, the fbset(8) may
   be of use (but may not always be accurate for what is currently
   viewable). In general some guessing may be required, especially for
   the bpp.

   Based on the bpp x11vnc will try to guess the red, green, and blue
   masks (these indicate which bits correspond to each color). It if gets
   it wrong you can specify them manually via the optional ":R/G/B"
   field. E.g. ":0xff0000/0x00ff00/0x0000ff" (this is the default for
   32bpp).

   Finally, the framebuffer may not begin at the beginning of the memory
   object, so use the optional "+offset" parameter to indicate where the
   framebuffer information starts. So as an example, the Xvfb virtual
   framebuffer has options -shmem and -fbdir for exporting its virtual
   screen to either shm or a mapped file. The format of these is XWD and
   so the initial header should be skipped. BTW, since XWD is not
   strictly RGB the view will only be approximate. Of course for the case
   of Xvfb x11vnc can poll it much better via the [552]X API, but you get
   the idea.

   By default in -rawfb mode x11vnc will actually close any X display it
   happened to open. This is basically to shake out bugs (e.g it will
   crash rather than mysteriously interacting with the X display). If you
   want x11vnc to keep the X display open while polling the raw
   framebuffer prefix a "+" sign at the beginning of the string (e.g.
   +file:/dev/urandom@64x64x8) This could be convenient for keeping the
   remote control channel active (it uses X properties). The "-connect
   /path/to/file" mechanism could also be used for remote control to
   avoid the X property channel. Rare usage, but if you also supply
   -noviewonly in this "+" mode then the mouse and keyboard input are
   still sent to the X display, presumably for doing something strange
   with /dev/fb...


   All of the above was just for viewing the raw framebuffer. That may be
   enough for certain applications of this feature (e.g. suppose a
   [553]video camera mapped its framebuffer into memory). To handle the
   pointer and keyboard input from the viewer users the "-pipeinput cmd"
   option was added to indicate a helper program to process the user
   input. The input is streamed to it and looks something like this:
   Pointer 1 205 257 0 None
   Pointer 1 198 253 0 None
   Pointer 1 198 253 1 ButtonPress-1
   Pointer 1 198 253 0 ButtonRelease-1
   Pointer 1 198 252 0 None
   Keysym 1 1 119 w KeyPress
   Keysym 1 0 119 w KeyRelease
   Keysym 1 1 65288 BackSpace KeyPress
   Keysym 1 0 65288 BackSpace KeyRelease
   Keysym 1 1 112 p KeyPress
   Keysym 1 0 112 p KeyRelease

   Run "-pipeinput tee:/bin/cat" to get a description of the format. Note
   that the -pipeinput option is independent of -rawfb mode and so may
   have some other interesting uses. BTW, the "tee:" prefix means x11vnc
   will both process the user input and pipe it to the command. The
   default is to just pipe it to the -pipeinput command.

   Note the -pipeinput helper program could actually control the raw
   framebuffer. In the libvncserver CVS a simple example program
   x11vnc/misc/slide.pl is provided that demonstrates a simple jpeg
   "slideshow" application.

   The -pipeinput program is run with these environment variables set:
   X11VNC_PID, X11VNC_PROG, X11VNC_CMDLINE, X11VNC_RAWFB_STR to aid its
   knowing what is up.

   Another example provided in libvncserver CVS is a script to inject
   keystrokes into the Linux console (e.g. the virtual consoles:
   /dev/tty1, /dev/tty2, etc) in x11vnc/misc/vcinject.pl. It is based on
   the vncterm/LinuxVNC.c program also in the libvncserver CVS. So to
   view and interact with VC #2 (assuming it is the [554]active VC) one
   can run something like:
  x11vnc -rawfb map:/dev/fb0@1024x768x16 -pipeinput './vcinject.pl 2'

   This assumes your Linux framebuffer device (/dev/fb0) is properly
   configured. See fbset(8) and other documentation. Try
   "file:/dev/fb0@WxHxB" as a last resort.

   Starting with x11vnc 0.8.1, the above vc injection is built in, as
   well as WxHxB determination. Just use something like:
  x11vnc -rawfb cons

   This will try to guess the active virtual console (via /dev/tty0) and
   also the /dev/fb0 WxHxB and rgb masks automatically. Use, e.g.,
   "-rawfb cons3" to force the VT number. Here is the -help output for
   this mode:

     If the rawfb string begins with "cons" the framebuffer device
     /dev/fb0 is opened (this requires the appropriate kernel modules)
     and so is /dev/tty0. The latter is used to inject keystrokes (not
     all are supported, but the basic ones are). You will need to be
     root to inject keystrokes. /dev/tty0 refers to the active VT, to
     indicate one explicitly, use "cons2", etc. using the VT number.
     Note you can change VT remotely using the chvt(1) command.
     Sometimes switching out and back corrects the framebuffer. To skip
     injecting entirely use "consx".

     The strings "console", or "/dev/fb0" can be used instead of "cons".
     The latter can be used to specify a different framebuffer device,
     e.g. /dev/fb1. If the name is something nonstandard, use
     "cons:/dev/foofb"

     If you do not want x11vnc to guess the framebuffer's WxHxB and
     masks automatically, specify them with a @WxHxB at the end of the
     string.

   The above is just an example of what can be done. If you really want
   to view and interact with the Linux console it is better to use the
   more accurate and faster LinuxVNC program. The only advantage x11vnc
   -rawfb might have is that it can presumably allow interaction with a
   non-text application, e.g. one based on svgalib. For example the
   [555]VMWare Fullscreen mode is actually viewable under -rawfb. But
   this isn't much use until one figures out how to inject keystrokes and
   mouse events...

   The -rawfb and -pipeinput features are intended to help one creatively
   "get out of a jam" (say on a legacy or embedded device) where X is
   absent or doesn't work properly. Feedback and bug reports are welcome.
   For more control and less overhead use libvncserver in your own C
   program that passes the framebuffer to libvncserver.


   Q-91: Can I export via VNC a Webcam or TV tuner framebuffer using
   x11vnc?

   Yes, this is possible to some degree with the [556]-rawfb option.
   There is no X11 involved: snapshots from the video capture device are
   used for the screen image data. See the [557]previous FAQ on -rawfb
   for background. For best results, use x11vnc version 0.8.1 or later.

   Roughly, one would do something like this:
  x11vnc -rawfb snap:/dev/video@320x240x32

   This requires that the system allows simple read(2) access to the
   video device. This is true for video4Linux on Linux kernel 2.6 and
   later (it won't work for 2.4, you'll need a separate program to
   snapshot to a file that you point -rawfb to; ask me if it is not clear
   what to do).

   The "snap:" enforces [558]-snapfb mode which appears to be necessary.
   The read pointer for video capture devices cannot be repositioned
   (which would be needed for scanline polling), but you can read a full
   frame of data from the device.

   On Linux, if the Video4Linux API is present or the v4l-info(1) program
   (related to xawtv) exists in in PATH, then x11vnc can be instructed to
   try it to determine the -rawfb WxHxB parameters for you automatically.
   In this case one would just type:
  x11vnc -rawfb video

   or "-rawfb video1" for the 2nd video device, etc.

   x11vnc has also been extended to use the Video4Linux API over v4l-info
   if it is available at build time. This enables setting parameters
   (e.g. size and brightness) via x11vnc. See the description below.
   Without Video4Linux you will need to initialize the settings of the
   video device using something like xawtv or spcaview (and then hope the
   settings persist until x11vnc reopens the device).

   Many video4linux drivers tend to set the framebuffer to be 24bpp (as
   opposed to 32bpp). Since this can cause problems with VNC viewers,
   etc, the [559]-24to32 option will be automatically imposed when in
   24bpp.

   Note that by its very nature, video capture involves rapid change in
   the framebuffer. This is especially true for cameras where slight
   wavering in brightness is always happening. This can lead to much
   network bandwidth consumption for the VNC traffic and also local CPU
   and I/O resource usage. You may want to experiment with "dialing down"
   the framerate via the [560]-wait, [561]-slow_fb, or [562]-defer
   options. Decreasing the window size and bpp also helps.


   Setting Camera/Tuner parameters via x11vnc:

   There is also some support for setting parameters of the capture
   device. This is done via "-rawfb video:<settings>". This could be
   useful for unattended startup at boottime, etc. Here is the -help
   description:

     A more sophisticated video device scheme allows initializing the
     device's settings using:

           -rawfb video:<settings>

     The prefix could also be, as above, e.g. "video1:" to specify the
     device file. The v4l API must be available for this to work.
     Otherwise, you will need to try to initialize the device with an
     external program, e.g. xawtv, spcaview, and hope they persist when
     x11vnc re-opens the device.

     <settings> is a comma separated list of key=value pairs. The
     device's brightness, color, contrast, and hue can be set to
     percentages, e.g. br=80,co=50,cn=44,hu=60.

     The device filename can be set too if needed (if it does not start
     with "video"), e.g. fn=/dev/qcam.

     The width, height and bpp of the framebuffer can be set via, e.g.,
     w=160,h=120,bpp=16.

     Related to the bpp above, the pixel format can be set via the
     fmt=XXX, where XXX can be one of: GREY, HI240, RGB555, RGB565,
     RGB24, and RGB32 (with bpp 8, 8, 16, 16, 24, and 32 respectively).
     See http://www.linuxtv.org for more info (V4L api).

     For TV/rf tuner cards one can set the tuning mode via tun=XXX where
     XXX can be one of PAL, NTSC, SECAM, or AUTO.

     One can switch the input channel by the inp=XXX setting, where XXX
     is the name of the input channel (Television, Composite1, S-Video,
     etc). Use the name that is in the information about the device that
     is printed at startup.

     For input channels with tuners (e.g. Television) one can change
     which station is selected by the sta=XXX setting. XXX is the
     station number. Currently only the ntsc-cable-us (US cable)
     channels are built into x11vnc. See the -freqtab option below to
     supply one from xawtv. If XXX is greater than 500, then it is
     interpreted as a raw frequency in KHz.

     Example:

     -rawfb video:br=80,w=320,h=240,fmt=RGB32,tun=NTSC,sta=47

     one might need to add inp=Television too for the input channel to
     be TV if the card doesn't come up by default in that one.

     Note that not all video capture devices will support all of the
     above settings.

     See the -pipeinput VID option below for a way to control the
     settings through the VNC Viewer via keystrokes.

     As above, if you specify a "@WxHxB..." after the <settings> string
     they are used verbatim: the device is not queried for the current
     values. Otherwise the device will be queried.

   Also, if you supply the "-pipeinput VID" option you can control the
   settings to some degree via keystroke mappings, e.g. B to increase the
   brightness or Up arrow to change the TV station:

     For "-pipeinput VID" and you are using the -rawfb for a video
     capture device, then an internal list of keyboard mappings is used
     to set parameters of the video. The mappings are:

         "B" and "b" adjust the brightness up and down.
         "H" and "h" adjust the hue.
         "C" and "c" adjust the colour.
         "N" and "n" adjust the contrast.
         "S" and "s" adjust the size of the capture screen.
         "I" and "i" cycle through input channels.
         Up and Down arrows adjust the station (if a tuner)
         F1, F2, ..., F6 will switch the video capture pixel
         format to HI240, RGB565, RGB24, RGB32, RGB555, and
         GREY respectively. See -rawfb video for details.

   See also the [563]-freqtab option to supply your own xawtv channel to
   frequency mappings for your country (only ntsc-cable-us is built into
   x11vnc).


   Q-92: I am using x11vnc where my local machine has "popup/hidden
   taskbars" (e.g. GNOME or MacOS X) and the remote display where x11vnc
   runs also has "popup/hidden taskbars" (e.g. GNOME). When I move the
   mouse to the edge of the screen where the popups happen, the taskbars
   interfere and fight with each other in strange ways. What can I do?

   Is there a way to temporarily disable one or both of these magic
   desktop taskbars?

   One x11vnc user suggests: it should be straightforward to right mouse
   click on the task bar panel, and uncheck "enable auto-hide" from the
   panel properties dialog box. This will make the panel always visible.

   [Misc: Clipboard, File Transfer, Sound, Beeps, Thanks, etc.]

   Q-93: Does the Clipboard/Selection get transferred between the
   vncviewer and the X display?

   As of Jan/2004 x11vnc supports the "CutText" part of the rfb protocol.
   Furthermore, x11vnc is able to hold the PRIMARY selection (Xvnc does
   not seem to do this). If you don't want the Clipboard/Selection
   exchanged use the [564]-nosel option. If you don't want the PRIMARY
   selection to be polled for changes use the [565]-noprimary option. You
   can also fine-tune it a bit with the [566]-seldir dir option.

   You may need to watch out for desktop utilities such as KDE's
   "Klipper" that do odd things with the selection, clipboard, and
   cutbuffers.


   Q-94: Can I transfer files back and forth with x11vnc?

   As of Oct/2005 and May/2006 x11vnc enables, respectively, the TightVNC
   and UltraVNC file transfer implementations that were added to
   libvncserver. This currently works with TightVNC and UltraVNC viewers
   (and Windows viewers only support filetransfer it appears).

   TightVNC file transfer is on by default, if you want to disable it use
   the [567]-nofilexfer option. UltraVNC file transfer is currently off
   by default, to enable it use something like "-rfbversion 3.6
   -permitfiletransfer"
   options (UltraVNC incorrectly uses the RFB protocol version to
   determine if features are available, so x11vnc has to pretend to be
   version 3.6).


   Q-95: How can I hear the sound (audio) from the remote applications on
   the desktop I am viewing via x11vnc?

   You will have to use an external network audio mechanism for this.
   Audio is not part of the VNC protocol.

   We show a simple unix to unix esd method here (artsd should be
   possible too, and perhaps even one or both of these have been ported
   to Windows so you can redirect the sound there).

   First you will need a tunnel to redirect the audio from the remote
   machine to the one you sitting at. We use an ssh tunnel:
  sitting-here> ssh -C -R 16001:localhost:16001 far-away.east

   Or one could combine this with the VNC tunnel at the same time, e.g.:
  sitting-here> ssh -C -R 16001:localhost:16001 -L 5900:localhost:5900 far-away
.east 'x11vnc -localhost -display :0'

   Port 16001 is the default ESD uses. So when an application on the
   remote desktop makes a sound it will connect to this tunnel and be
   redirected to port 16001 on the local machine (sitting-here in this
   example). The -C option is an attempt to compress the audio a little
   bit.

   So we next need a local (sitting-here) esd daemon running that will
   receive those requests and play them on the local sound device:
  sitting-here> esd -promiscuous -port 16001 -tcp

   See the esd(1) man page for the meaning of the options (the above are
   not very secure).

   To test this sound tunnel, we use the esdplay program to play a simple
   .wav file:
  far-away> esdplay -s localhost:16001 im_so_happy.wav

   If you hear the sound (Captain Kirk in this example), that means you
   are in great shape.

   To run individual audio applications you can use the esddsp(1)
   command:
  far-away> esddsp -s localhost:16001 xmms

   Then you could try playing some sounds inside xmms. You could also set
   the environment variable ESPEAKER=localhost:16001 to not need to
   supply the -s option all the time. (for reasons not clear, sometimes
   esddsp can figure it out on its own). All the script esddsp does is to
   set ESPEAKER and LD_PRELOAD for you so that when the application opens
   the sound device (usually /dev/dsp) its interactions with the device
   will be intercepted and sent to the esd daemon running on sitting-here
   (that in turn writes them to the real, local /dev/dsp.

   Redirecting All sound:

   It does not seem to be possible to switch all of the sound of the
   remote machine from its sound device to the above esd+ssh tunnel
   without some preparation. But it can be done reasonably well if you
   prepare (i.e. restart) the desktop with this in mind.

   Here is one way to redirect all sound. The idea is we run the entire
   desktop with sound directed to localhost:16001. When we are sitting at
   far-away.east we run "esd -promiscuous -port 16001 -tcp" on
   far-away.east (to be able to hear the sound). However, when we are
   sitting at sitting-here.west we kill the esd process and run that same
   esd command on sitting-here.west and start up the above ssh tunnel.
   This is a little awkward, but with some scripts one would probably
   kill and restart the esd processes automatically.

   So next we have to run the whole desktop pointing toward our esd. Here
   is a simple way to test. Log in to the machine via the "FailSafe"
   desktop. Then in the lone terminal type something like:
  esddsp -s localhost:16001 gnome-session
or:
  esddsp -s localhost:16001 startkde

   or whatever command starts your desktop. This causes the environment
   variables ESPEAKER and LD_PRELOAD to be set appropriately and every
   application (processes with the desktop as an ancestor) will use them.
   If this scheme works well you can make it less klunky by adding the
   command to your ~/.xsession, etc. file that starts your default
   desktop. Or you may be able to configure your desktop to use
   localhost:16001, or whatever is needed, via a gui configuration panel.
   Some Notes:
     * Not all audio applications are compatible with the esd and artsd
       mechanisms, but many are.
     * The audio is not compressed so you probably need a broadband or
       faster connection. Listening to music may not be very pleasant...
       (Although we found streaming music from across the US over cable
       modem worked OK, but took 200 KB/sec, to use less bandwidth
       consider something like "ssh far-away.east 'cat favorite.mp3' |
       mpg123 -b 4000 -")
     * Linux does not seem to have the concept of LD_PRELOAD_64 so if you
       run on a mixed 64- and 32-bit ABI system (e.g. AMD x86_64) some of
       the applications will fail to run because LD_PRELOAD will point to
       libraries of the wrong wordsize.

   Q-96: Why don't I hear the "Beeps" in my X session (e.g. when typing
   tput bel in an xterm)?

   As of Dec/2003 "Beep" XBell events are tracked by default. The X
   server must support the XKEYBOARD extension (this is not on by default
   in Solaris, see Xserver(1) for how to turn it on via +kb), and so you
   won't hear them if the extension is not present.

   If you don't want to hear the beeps use the [568]-nobell option. If
   you want to hear the audio from the remote applications, consider
   trying a [569]redirector such as esd.




    Contributions:

   Q-97: Thanks for your program and for your help! Can I make a
   donation?

   Please do (any amount is appreciated) and thank you for your support!
   Click on the PayPal button below for more info.

   [PayPal]

References

   1. http://www.karlrunge.com/x11vnc/index.html#faq
   2. http://www.karlrunge.com/x11vnc/index.html#downloading
   3. http://www.karlrunge.com/x11vnc/index.html#building
   4. http://www.karlrunge.com/x11vnc/index.html#beta-test
   5. http://www.karlrunge.com/x11vnc/index.html#faq-thanks
   6. http://www.karlrunge.com/x11vnc/index.html#faq-thanks
   7. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-int
   8. http://www.karlrunge.com/x11vnc/index.html#faq-userlogin
   9. http://www.karlrunge.com/x11vnc/index.html#faq-scaling
  10. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-viewers
  11. http://www.karlrunge.com/x11vnc/index.html#faq-filexfer
  12. http://www.karlrunge.com/x11vnc/index.html#faq-video
  13. http://www.karlrunge.com/x11vnc/index.html#faq
  14. http://www.karlrunge.com/x11vnc/disclaimer.html
  15. http://www.karlrunge.com/x11vnc/index.html#contact
  16. http://www.realvnc.com/
  17. http://www.tightvnc.com/
  18. http://www.ultravnc.com/
  19. http://www.redstonesoftware.com/vnc.html
  20. http://www.karlrunge.com/x11vnc/index.html#downloading
  21. http://www.tightvnc.com/download.html
  22. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
  23. http://www.karlrunge.com/x11vnc/index.html#faq-xperms
  24. http://www.karlrunge.com/x11vnc/index.html#faq-xperms
  25. http://www.karlrunge.com/x11vnc/index.html#faq-viewer-download
  26. http://www.sun.com/software/solaris/freeware/
  27. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-forever
  28. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-forever
  29. http://www.karlrunge.com/x11vnc/index.html#faq-service
  30. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
  31. http://www.karlrunge.com/x11vnc/index.html#vnc_password_file
  32. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
  33. http://www.karlrunge.com/x11vnc/index.html#vnc_password_file
  34. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
  35. http://www.karlrunge.com/x11vnc/index.html#tightvnc_via
  36. http://www.karlrunge.com/x11vnc/chainingssh.html
  37. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-bg
  38. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
  39. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
  40. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
  41. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
  42. http://www.karlrunge.com/x11vnc/index.html#faq-passwdfile
  43. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwdfile
  44. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
  45. http://www.karlrunge.com/x11vnc/index.html#faq-allow-opt
  46. http://www.karlrunge.com/x11vnc/index.html#faq-tcp_wrappers
  47. http://www.stunnel.org/
  48. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
  49. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-int
  50. http://sourceforge.net/projects/libvncserver/
  51. http://sourceforge.net/project/showfiles.php?group_id=32584&package_id=119006&release_id=422738
  52. http://sourceforge.net/project/shownotes.php?release_id=422738&group_id=32584
  53. http://www.karlrunge.com/x11vnc/x11vnc-0.8.2.tar.gz
  54. http://www.karlrunge.com/x11vnc/index.html#faq-binaries
  55. http://www.tightvnc.com/download.html
  56. http://www.realvnc.com/download-free.html
  57. http://sourceforge.net/projects/cotvnc/
  58. http://www.ultravnc.com/
  59. http://www.karlrunge.com/x11vnc/rx11vnc
  60. http://www.karlrunge.com/x11vnc/rx11vnc.pl
  61. http://www.sunfreeware.com/
  62. http://www.karlrunge.com/x11vnc/bins
  63. http://www.karlrunge.com/x11vnc/index.html#solarisbuilding
  64. http://www.karlrunge.com/x11vnc/miscbuild.html
  65. ftp://ftp.uu.net/graphics/jpeg/
  66. http://www.gzip.org/zlib/
  67. http://www.sunfreeware.com/
  68. http://www.karlrunge.com/x11vnc/index.html#faq-solaris251build
  69. http://www.karlrunge.com/x11vnc/x11vnc-0.8.2.tar.gz
  70. http://www.karlrunge.com/x11vnc/bins
  71. mailto:x11vnc-beta@karlrunge.com
  72. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rawfb
  73. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rawfb
  74. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-24to32
  75. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-usepw
  76. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noclipboard
  77. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nosetclipboard
  78. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-capslock
  79. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-skip_lockkeys
  80. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-fbpm
  81. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xinerama
  82. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
  83. http://www.openssl.org/
  84. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-stunnel
  85. http://www.stunnel.org/
  86. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslverify
  87. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-https
  88. http://www.karlrunge.com/x11vnc/index.html#ssl_vncviewer
  89. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-unixpw
  90. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-unixpw_nis
  91. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
  92. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
  93. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-stunnel
  94. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-display_WAIT
  95. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-display
  96. http://www.karlrunge.com/x11vnc/index.html#faq-userlogin
  97. http://www.karlrunge.com/x11vnc/prevrels.html
  98. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-solid
  99. http://www.tightvnc.com/
 100. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbport
 101. http://www.karlrunge.com/x11vnc/x11vnc_opts.html
 102. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
 103. http://www.karlrunge.com/x11vnc/recurse_x11vnc.jpg
 104. http://wwws.sun.com/sunray/index.html
 105. http://www.karlrunge.com/x11vnc/sunray.html
 106. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scrollcopyrect
 107. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 108. http://www.karlrunge.com/x11vnc/index.html#faq-xvfb
 109. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-cursor
 110. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 111. http://www.karlrunge.com/x11vnc/index.html#faq-sound
 112. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scrollcopyrect
 113. mailto:xvml@karlrunge.com
 114. http://www.karlrunge.com/x11vnc/index.html#faq-thanks
 115. http://www.karlrunge.com/x11vnc/index.html#faq-xperms
 116. http://www.karlrunge.com/x11vnc/index.html#faq-build
 117. http://www.karlrunge.com/x11vnc/index.html#faq-missing-xtest
 118. http://www.karlrunge.com/x11vnc/index.html#faq-solaris251build
 119. http://www.karlrunge.com/x11vnc/index.html#faq-binaries
 120. http://www.karlrunge.com/x11vnc/index.html#faq-viewer-download
 121. http://www.karlrunge.com/x11vnc/index.html#faq-cmdline-opts
 122. http://www.karlrunge.com/x11vnc/index.html#faq-config-file
 123. http://www.karlrunge.com/x11vnc/index.html#faq-gui-tray
 124. http://www.karlrunge.com/x11vnc/index.html#faq-quiet-bg
 125. http://www.karlrunge.com/x11vnc/index.html#faq-sigpipe
 126. http://www.karlrunge.com/x11vnc/index.html#faq-build-customizations
 127. http://www.karlrunge.com/x11vnc/index.html#faq-win2vnc
 128. http://www.karlrunge.com/x11vnc/index.html#faq-win2vnc-8bpp
 129. http://www.karlrunge.com/x11vnc/index.html#faq-8bpp
 130. http://www.karlrunge.com/x11vnc/index.html#faq-overlays
 131. http://www.karlrunge.com/x11vnc/index.html#faq-windowid
 132. http://www.karlrunge.com/x11vnc/index.html#faq-transients-id
 133. http://www.karlrunge.com/x11vnc/index.html#faq-24bpp
 134. http://www.karlrunge.com/x11vnc/index.html#faq-noshm
 135. http://www.karlrunge.com/x11vnc/index.html#faq-xterminal-xauth
 136. http://www.karlrunge.com/x11vnc/index.html#faq-sunrays
 137. http://www.karlrunge.com/x11vnc/index.html#faq-stop-bg
 138. http://www.karlrunge.com/x11vnc/index.html#faq-remote_control
 139. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
 140. http://www.karlrunge.com/x11vnc/index.html#faq-passwd-noecho
 141. http://www.karlrunge.com/x11vnc/index.html#faq-passwdfile
 142. http://www.karlrunge.com/x11vnc/index.html#faq-multipasswd
 143. http://www.karlrunge.com/x11vnc/index.html#faq-unix-passwords
 144. http://www.karlrunge.com/x11vnc/index.html#faq-forever-shared
 145. http://www.karlrunge.com/x11vnc/index.html#faq-allow-opt
 146. http://www.karlrunge.com/x11vnc/index.html#faq-tcp_wrappers
 147. http://www.karlrunge.com/x11vnc/index.html#faq-listen-interface
 148. http://www.karlrunge.com/x11vnc/index.html#faq-listen-localhost
 149. http://www.karlrunge.com/x11vnc/index.html#faq-input-opt
 150. http://www.karlrunge.com/x11vnc/index.html#faq-accept-opt
 151. http://www.karlrunge.com/x11vnc/index.html#faq-users-opt
 152. http://www.karlrunge.com/x11vnc/index.html#faq-blockdpy
 153. http://www.karlrunge.com/x11vnc/index.html#faq-gone-lock
 154. http://www.karlrunge.com/x11vnc/index.html#faq-ssh-unix
 155. http://www.karlrunge.com/x11vnc/index.html#faq-ssh-putty
 156. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-ext
 157. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-int
 158. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-viewers
 159. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-java-viewer-proxy
 160. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-portal
 161. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-ca
 162. http://www.karlrunge.com/x11vnc/index.html#faq-service
 163. http://www.karlrunge.com/x11vnc/index.html#faq-display-manager
 164. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
 165. http://www.karlrunge.com/x11vnc/index.html#faq-userlogin
 166. http://www.karlrunge.com/x11vnc/index.html#faq-loop
 167. http://www.karlrunge.com/x11vnc/index.html#faq-java-http
 168. http://www.karlrunge.com/x11vnc/index.html#faq-reverse-connect
 169. http://www.karlrunge.com/x11vnc/index.html#faq-xvfb
 170. http://www.karlrunge.com/x11vnc/index.html#faq-headless
 171. http://www.karlrunge.com/x11vnc/index.html#faq-solshm
 172. http://www.karlrunge.com/x11vnc/index.html#faq-less-resource
 173. http://www.karlrunge.com/x11vnc/index.html#faq-more-resource
 174. http://www.karlrunge.com/x11vnc/index.html#faq-slow-link
 175. http://www.karlrunge.com/x11vnc/index.html#faq-xdamage
 176. http://www.karlrunge.com/x11vnc/index.html#faq-pointer-mode
 177. http://www.karlrunge.com/x11vnc/index.html#faq-wireframe
 178. http://www.karlrunge.com/x11vnc/index.html#faq-scrollcopyrect
 179. http://www.karlrunge.com/x11vnc/index.html#faq-cursor-shape
 180. http://www.karlrunge.com/x11vnc/index.html#faq-xfixes-alpha
 181. http://www.karlrunge.com/x11vnc/index.html#faq-xfixes-alpha-hacks
 182. http://www.karlrunge.com/x11vnc/index.html#faq-cursor-arrow
 183. http://www.karlrunge.com/x11vnc/index.html#faq-cursor-positions
 184. http://www.karlrunge.com/x11vnc/index.html#faq-buttonmap-opt
 185. http://www.karlrunge.com/x11vnc/index.html#faq-altgr
 186. http://www.karlrunge.com/x11vnc/index.html#faq-greaterless
 187. http://www.karlrunge.com/x11vnc/index.html#faq-greaterless-sloppy
 188. http://www.karlrunge.com/x11vnc/index.html#faq-xkbmodtweak
 189. http://www.karlrunge.com/x11vnc/index.html#faq-repeated-keys
 190. http://www.karlrunge.com/x11vnc/index.html#faq-repeated-keys-still
 191. http://www.karlrunge.com/x11vnc/index.html#faq-remap-opt
 192. http://www.karlrunge.com/x11vnc/index.html#faq-sun-alt-meta
 193. http://www.karlrunge.com/x11vnc/index.html#faq-remap-button-click
 194. http://www.karlrunge.com/x11vnc/index.html#faq-remap-capslock
 195. http://www.karlrunge.com/x11vnc/index.html#faq-scrollbars
 196. http://www.karlrunge.com/x11vnc/index.html#faq-scaling
 197. http://www.karlrunge.com/x11vnc/index.html#faq-xinerama
 198. http://www.karlrunge.com/x11vnc/index.html#faq-multi-screen
 199. http://www.karlrunge.com/x11vnc/index.html#faq-clip-screen
 200. http://www.karlrunge.com/x11vnc/index.html#faq-xrandr
 201. http://www.karlrunge.com/x11vnc/index.html#faq-black-screen
 202. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 203. http://www.karlrunge.com/x11vnc/index.html#faq-vmware
 204. http://www.karlrunge.com/x11vnc/index.html#faq-rawfb
 205. http://www.karlrunge.com/x11vnc/index.html#faq-video
 206. http://www.karlrunge.com/x11vnc/index.html#faq-hidden-taskbars
 207. http://www.karlrunge.com/x11vnc/index.html#faq-clipboard
 208. http://www.karlrunge.com/x11vnc/index.html#faq-filexfer
 209. http://www.karlrunge.com/x11vnc/index.html#faq-sound
 210. http://www.karlrunge.com/x11vnc/index.html#faq-beeps
 211. http://www.karlrunge.com/x11vnc/index.html#faq-thanks
 212. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-display
 213. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
 214. http://www.karlrunge.com/x11vnc/index.html#faq-display-manager
 215. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-users
 216. http://www.karlrunge.com/x11vnc/index.html#solarisbuilding
 217. http://www.karlrunge.com/x11vnc/x11vnc_sunos4.html
 218. http://www.karlrunge.com/x11vnc/index.html#building
 219. http://www.karlrunge.com/x11vnc/index.html#faq-build
 220. http://packages.debian.org/x11vnc
 221. http://www.linuxpackages.net/search_view.php?by=name&name=x11vnc
 222. http://dag.wieers.com/packages/x11vnc/
 223. http://dries.ulyssis.org/rpm/packages/x11vnc/info.html
 224. http://linux01.gwdg.de/~pbleser/rpm-navigation.php?cat=Network/x11vnc/
 225. http://www.sunfreeware.com/
 226. http://www.freebsd.org/cgi/ports.cgi?query=x11vnc&stype=all
 227. http://www.freshports.org/net/x11vnc
 228. http://www.openbsd.org/3.9_packages/i386/x11vnc-0.6.2.tgz-long.html
 229. http://pkgsrc.se/x11/x11vnc
 230. http://mike.saunby.net/770/x11vnc/
 231. http://www.pdaxrom.org/ipk_feed.php?menuid=11&showfeed=unstable#x11vnc
 232. http://www.focv.com/ipkg/
 233. http://www.karlrunge.com/x11vnc/bins
 234. http://www.tightvnc.com/download.html
 235. http://www.realvnc.com/download-free.html
 236. http://sourceforge.net/projects/cotvnc/
 237. http://www.ultravnc.com/
 238. http://www.karlrunge.com/x11vnc/x11vnc_opts.html
 239. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gui
 240. http://www.karlrunge.com/x11vnc/index.html#faq-gui-tray
 241. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-q
 242. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-bg
 243. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-o
 244. http://www.karlrunge.com/x11vnc/index.html#solarisbuilding
 245. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nofb
 246. http://fredrik.hubbe.net/x2vnc.html
 247. http://www.hubbe.net/~hubbe/win2vnc.html
 248. http://www.deboer.gmxhome.de/
 249. http://sourceforge.net/projects/win2vnc/
 250. http://fredrik.hubbe.net/x2vnc.html
 251. http://freshmeat.net/projects/x2x/
 252. http://ftp.digital.com/pub/Digital/SRC/x2x/
 253. http://zapek.com/software/zvnc/
 254. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-visual
 255. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-flashcmap
 256. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-8to24
 257. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-notruecolor
 258. http://www.karlrunge.com/x11vnc/index.html#faq-8bpp
 259. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 260. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-8to24
 261. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 262. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-8to24
 263. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-flashcmap
 264. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-fixscreen
 265. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-8to24
 266. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 267. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-8to24
 268. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 269. http://www.karlrunge.com/x11vnc/index.html#faq-overlays
 270. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 271. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sid
 272. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-24to32
 273. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-display
 274. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noshm
 275. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-flipbyteorder
 276. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
 277. http://www.karlrunge.com/x11vnc/index.html#xauth_pain
 278. http://www.karlrunge.com/x11vnc/index.html#faq-noshm
 279. http://wwws.sun.com/sunray/index.html
 280. http://www.karlrunge.com/x11vnc/sunray.html
 281. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remote
 282. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-query
 283. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-forever
 284. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-bg
 285. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-clear_mods
 286. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-clear_keys
 287. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remote
 288. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-query
 289. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gui
 290. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-storepasswd
 291. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
 292. http://www.karlrunge.com/x11vnc/index.html#faq-passwdfile
 293. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-usepw
 294. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-viewpasswd
 295. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwd
 296. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwdfile
 297. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
 298. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwdfile
 299. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-unixpw
 300. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-unixpw_nis
 301. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 302. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-stunnel
 303. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 304. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 305. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel
 306. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-accept
 307. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-forever
 308. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-shared
 309. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 310. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
 311. http://www.karlrunge.com/x11vnc/index.html#faq-passwdfile
 312. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-allow
 313. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 314. http://www.karlrunge.com/x11vnc/index.html#faq-tcp_wrappers
 315. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
 316. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-listen
 317. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-allow
 318. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 319. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-allow
 320. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 321. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-listen
 322. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-allow
 323. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 324. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-input
 325. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-accept
 326. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-viewonly
 327. ftp://ftp.x.org/
 328. http://www.karlrunge.com/x11vnc/dtVncPopup
 329. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gone
 330. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-users
 331. http://www.karlrunge.com/x11vnc/blockdpy.c
 332. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-accept
 333. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gone
 334. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gone
 335. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-afteraccept
 336. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 337. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 338. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 339. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
 340. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwdfile
 341. http://www.karlrunge.com/x11vnc/index.html#gateway_double_ssh
 342. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 343. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
 344. http://www.stunnel.org/
 345. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
 346. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-stunnel
 347. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslverify
 348. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-int
 349. http://www.stunnel.org/
 350. http://www.karlrunge.com/x11vnc/ssl.html
 351. http://www.karlrunge.com/x11vnc/index.html#ssl_vncviewer
 352. http://www.karlrunge.com/x11vnc/ssl.html
 353. http://www.securityfocus.com/infocus/1677
 354. http://www.karlrunge.com/x11vnc/ssl.html
 355. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-inetd
 356. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-viewers
 357. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-httpdir
 358. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-http
 359. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
 360. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-https
 361. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-stunnel
 362. http://www.karlrunge.com/x11vnc/index.html#ssl_vncviewer
 363. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-ext
 364. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
 365. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-stunnel
 366. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-viewers
 367. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
 368. http://www.openssl.org/
 369. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-stunnel
 370. http://www.stunnel.org/
 371. http://www.karlrunge.com/x11vnc/ssl.html
 372. http://www.karlrunge.com/x11vnc/index.html#ssl_vncviewer
 373. http://www.karlrunge.com/x11vnc/ssl.html
 374. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-viewers
 375. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-httpdir
 376. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-http
 377. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-https
 378. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-portal
 379. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-https
 380. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-ext
 381. http://www.karlrunge.com/x11vnc/ssl_vncviewer
 382. http://www.karlrunge.com/x11vnc/ssl-portal.html
 383. http://www.karlrunge.com/x11vnc/ssl.html
 384. http://www.karlrunge.com/x11vnc/index.html#ssl_vncviewer
 385. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-viewers
 386. http://www.karlrunge.com/x11vnc/ssl-portal.html
 387. http://www.karlrunge.com/x11vnc/ssl.html
 388. http://www.karlrunge.com/x11vnc/index.html#display-manager-continuously
 389. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
 390. http://www.karlrunge.com/x11vnc/index.html#faq-userlogin
 391. http://www.karlrunge.com/x11vnc/index.html#x11vnc_loop
 392. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
 393. http://www.karlrunge.com/x11vnc/index.html#dtlogin_solaris
 394. http://www.jirka.org/gdm-documentation/x241.html
 395. http://www.karlrunge.com/x11vnc/x11vnc_loop
 396. http://www.karlrunge.com/x11vnc/index.html#faq-xterminal-xauth
 397. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-inetd
 398. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-q
 399. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
 400. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
 401. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-unixpw
 402. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-display_WAIT
 403. http://www.karlrunge.com/x11vnc/index.html#stunnel-inetd
 404. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-display_WAIT
 405. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-unixpw
 406. http://www.karlrunge.com/x11vnc/index.html#faq-unix-passwords
 407. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-users
 408. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-int
 409. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-loop
 410. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-httpdir
 411. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-http
 412. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
 413. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remote
 414. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-vncconnect
 415. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-add_keysyms
 416. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 417. http://www.karlrunge.com/x11vnc/Xdummy
 418. http://www.karlrunge.com/x11vnc/index.html#display-manager-continuously
 419. http://www.karlrunge.com/x11vnc/shm_clear
 420. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-onetile
 421. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noshm
 422. http://www.karlrunge.com/x11vnc/index.html#faq-noshm
 423. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nap
 424. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wait
 425. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-onetile
 426. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-fs
 427. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-threads
 428. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-defer
 429. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 430. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-solid
 431. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scrollcopyrect
 432. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 433. http://www.tightvnc.com/
 434. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 435. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scrollcopyrect
 436. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-speeds
 437. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nodragging
 438. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-fs
 439. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wait
 440. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-defer
 441. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-progressive
 442. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 443. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nosel
 444. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursor
 445. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursorpos
 446. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-readtimeout
 447. http://www.karlrunge.com/x11vnc/index.html#fb_read_slow
 448. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xd_area
 449. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xd_mem
 450. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noxdamage
 451. http://www.karlrunge.com/x11vnc/index.html#fb_read_slow
 452. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-pointer_mode
 453. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-pointer_mode
 454. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nodragging
 455. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-pointer_mode
 456. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-threads
 457. http://www.karlrunge.com/x11vnc/index.html#faq-wireframe
 458. http://www.karlrunge.com/x11vnc/index.html#faq-scrollcopyrect
 459. http://www.karlrunge.com/x11vnc/index.html#faq-pointer-mode
 460. http://www.karlrunge.com/x11vnc/index.html#fb_read_slow
 461. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 462. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 463. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 464. http://www.karlrunge.com/x11vnc/index.html#fb_read_slow
 465. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scrollcopyrect
 466. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 467. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wirecopyrect
 468. http://www.karlrunge.com/x11vnc/index.html#faq-wireframe
 469. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-fixscreen
 470. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scr_skip
 471. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scale
 472. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scrollcopyrect
 473. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-cursor
 474. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-cursor
 475. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 476. http://www.karlrunge.com/x11vnc/index.html#the-overlay-mode
 477. http://www.karlrunge.com/x11vnc/index.html#solaris10-build
 478. http://www.karlrunge.com/x11vnc/index.html#faq-xfixes-alpha-hacks
 479. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-alphacut
 480. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-alphafrac
 481. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-alpharemove
 482. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursorshape
 483. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noalphablend
 484. http://www.tightvnc.com/
 485. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursor
 486. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-cursorpos
 487. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursorpos
 488. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursorshape
 489. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-buttonmap
 490. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-debug_pointer
 491. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-buttonmap
 492. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-modtweak
 493. http://www.karlrunge.com/x11vnc/index.html#faq-greaterless
 494. http://www.karlrunge.com/x11vnc/index.html#faq-xkbmodtweak
 495. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-debug_keyboard
 496. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xkb
 497. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sloppy_keys
 498. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-modtweak
 499. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-modtweak
 500. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 501. http://www.karlrunge.com/x11vnc/index.html#faq-xkbmodtweak
 502. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-debug_keyboard
 503. http://www.karlrunge.com/x11vnc/index.html#faq-greaterless
 504. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xkb
 505. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sloppy_keys
 506. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-modtweak
 507. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xkb
 508. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xkb
 509. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-skip_keycodes
 510. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 511. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-add_keysyms
 512. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 513. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 514. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-add_keysyms
 515. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-norepeat
 516. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-norepeat
 517. http://www.karlrunge.com/x11vnc/index.html#faq-display-manager
 518. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 519. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 520. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 521. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 522. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-skip_lockkeys
 523. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 524. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nomodtweak
 525. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-capslock
 526. http://www.karlrunge.com/x11vnc/index.html#faq-scaling
 527. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scale
 528. http://www.cus.cam.ac.uk/~ssb22/source/vnc-magnification.html
 529. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbport
 530. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gui
 531. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
 532. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scale_cursor
 533. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-blackout
 534. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xinerama
 535. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xinerama
 536. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xwarppointer
 537. http://www.karlrunge.com/x11vnc/index.html#faq-solshm
 538. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-onetile
 539. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noshm
 540. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-clip
 541. http://www.karlrunge.com/x11vnc/index.html#faq-xinerama
 542. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 543. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 544. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xrandr
 545. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-padgeom
 546. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 547. http://www.karlrunge.com/x11vnc/index.html#faq-rawfb
 548. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 549. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 550. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-snapfb
 551. http://www.karlrunge.com/x11vnc/index.html#faq-video
 552. http://www.karlrunge.com/x11vnc/index.html#faq-xvfb
 553. http://www.karlrunge.com/x11vnc/index.html#faq-video
 554. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 555. http://www.karlrunge.com/x11vnc/index.html#faq-vmware
 556. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rawfb
 557. http://www.karlrunge.com/x11vnc/index.html#faq-rawfb
 558. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-snapfb
 559. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-24to32
 560. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wait
 561. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-slow_fb
 562. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-defer
 563. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-freqtab
 564. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nosel
 565. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noprimary
 566. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-seldir
 567. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nofilexfer
 568. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nobell
 569. http://www.karlrunge.com/x11vnc/index.html#faq-sound
	
=======================================================================
http://www.karlrunge.com/x11vnc/chainingssh.html:


     _________________________________________________________________

   Chaining ssh's: Note that for use of a ssh gateway and -L redirection
   to an internal host (e.g. "-L 5900:otherhost:5900") the VNC traffic
   inside the firewall is not encrypted and you have to manually log into
   otherhost to start x11vnc. Kyle Amon shows a method where you chain
   two ssh's together that encrypts all network traffic and also
   automatically starts up x11vnc on the internal workstation:
#!/bin/sh
#
gateway="example.com"   # or "user@example.com"
host="labyrinth"        # or "user@hostname"
user="kyle"

# Need to sleep long enough for all of the passwords and x11vnc to start up.
# The </dev/null below makes the vncviewer prompt for passwd via popup window.
#
(sleep 10; vncviewer -encodings "copyrect tight zrle zlib hextile" \
    localhost:0 </dev/null >/dev/null) &

# Chain the vnc connection thru 2 ssh's, and connect x11vnc to user's display:
#
exec /usr/bin/ssh -t -L 5900:localhost:5900 $gateway \
     /usr/bin/ssh -t -L 5900:localhost:5900 $host \
     sudo /usr/bin/x11vnc -localhost -auth /home/$user/.Xauthority \
         -rfbauth .vnc/passwd -display :0

   Also note the use of sudo(1) to switch to root so that the different
   user's .Xauthority file can be accessed. See the visudo(8) manpage for
   details on how to set this up (remove the sudo if you do not want to
   do this). One can also chain together ssh's for reverse connections
   with vncviewers using the -listen option. For this case -R would
   replace the -L (and 5500 the 5900, see the #2 example script above).
   If the gateway machine's sshd is configured with GatewayPorts=no (the
   default) then the double chaining of "ssh -R ..." will be required for
   reverse connections to work.
	
=======================================================================
http://www.karlrunge.com/x11vnc/miscbuild.html:


     _________________________________________________________________

   Misc. Build problems:   We collect here rare build problems some users
   have reported and the corresponding workarounds. See also the [1]FAQ's
   on building.

   One user had a problem where the build script below was failing
   because his work environment had the ENV variable set to a script that
   was resetting his PATH so that gcc could no longer be found. Make sure
   you do not have any ENV or BASH_ENV in your environment doing things
   like that. Typing "unset ENV", etc. before configuring and building
   should clear it.

   One user had his bash shell compiled with --enable-xpg-echo-default
   that causes some strange behavior with things like echo "\\1 ..." the
   configure script executes. In particular instead of getting "\1" the
   non-printable character "^A" is produced, and causes failures at
   compile time like:
  ../rfb/rfbconfig.h:9:22: warning: extra tokens at end of #ifndef directive

   The workaround is to configure like this:
  env CONFIG_SHELL=/bin/sh /bin/sh ./configure

   i.e. avoid using the bash with the misbehavior. A bug has been filed
   against autoconf to guard against this.

   AIX: one user had to add the "X11.adt" package to AIX to get build
   header files like XShm.h, etc.

References

   1. http://www.karlrunge.com/x11vnc/miscbuild.html#faq-build
	
=======================================================================
http://www.karlrunge.com/x11vnc/sunray.html:


    Sun Ray Notes:

   You can run x11vnc on your (connected or disconnected) [1]SunRay
   session (Please remember to use settings like [2]-wait 200, [3]-sb 15,
   and not running a screensaver animation (blank instead) to avoid being
   a resource hog! x11vnc does induce a lot of memory I/O from polling
   the X server. It also helps to have a solid background color, e.g.
   [4]-solid).

   You have to know the name of the machine your SunRay session X server
   is running on (so you can ssh into it and start x11vnc). You also need
   to know the X11 DISPLAY number for the session: on a SunRay it could
   be a large number, e.g. :137, since there are many people with X
   sessions (Xsun processes) on the same machine. If you don't know it,
   you can get it by running who(1) in a shell on the SunRay server and
   looking for the dtlocal entry with your username (and if you don't
   even know which server machine has your session, you could login to
   all possible ones looking at the who output for your username...).

   I put some code in my ~/.dtprofile script that stores $DISPLAY in my
   ~/.sunray_current file at session startup and deletes it when the
   session ends to make it easy to get at the hostname and X11 display
   number info for my current X sessions.

   SunRay Gotcha #1:   Note that even though your SunRay X11 DISPLAY is
   something like :137, x11vnc still tries for port 5900 as its listening
   port if it can get it, in which case the VNC display (i.e. the
   information you supply to the VNC viewer) is something like
   sunray-server:0   (note the :0 corresponding to port 5900, it is not
   :137). If it cannot get 5900, it tries for 5901, and so on. You can
   also try to force the port (and thereby the VNC display) using the
   [5]-rfbport NNNN option.

   Especially on a busy Sun Ray server it is often difficult to find free
   ports for both VNC and the HTTP Java applet server to listen on. This
   script, [6]vnc_findports may be of use for doing this automatically.
   It suggests x11vnc command line options based on netstat output that
   lists the occupied ports. It is even more difficult to start
   vncserver/Xvnc on a busy Sun Ray because then 3 ports (HTTP, VNC, and
   X11), all separated by 100 are needed! This script, [7]findvncports
   may be helpful as well. Both scripts start at VNC display :10 and work
   their way up.

   SunRay Gotcha #2:   If you get an error like:
        shmget(tile) failed.
        shmget: No space left on device

   when starting up x11vnc that most likely means all the shared memory
   (shm) slots are filled up on your machine. The Solaris default is only
   100, and that can get filled up in a week or so on a SunRay server
   with lots of users. If the shm slot is orphaned (e.g. creator process
   dies) the slot is not reclaimed. You can view the shm slots with the
   "ipcs -mA" command. If there are about 100 then you've probably hit
   this problem. They can be cleaned out (by the owner or by root) using
   the ipcrm command. I wrote a script [8]shm_clear that finds the
   orphans and lists or removes them. Longer term, have your SunRay
   sysadmin add something like this to /etc/system:
        set shmsys:shminfo_shmmax = 0x2000000
        set shmsys:shminfo_shmmni = 0x1000

   SunRay Gotcha #3:   Some SunRay installations have implemented
   suspending certain applications when a SunRay session is in a
   disconnected state (e.g. Java Badge pulled out, utdetach, etc). This
   is a good thing because it limits hoggy or runaway apps from wasting
   the shared CPU resource. Think how much CPU and memory I/O is wasted
   by a bunch of Firefox windows running worthless Flash animations while
   your session is disconnected!

   So some sites have implemented scripts to suspend (e.g. kill -STOP)
   certain apps when your badge is removed from the SunRay terminal. When
   you reattach, it kill -CONT them. This causes problems for viewing the
   detached SunRay session via x11vnc: those suspended apps will not
   respond (their windows will be blank or otherwise inactive).

   What to do? Well, since you are going to be using the application you
   might as well unfreeze it rather than starting up a 2nd instance. Here
   is one way to do it using the kill -CONT mechanism:
   kill -CONT `ps -ealf | grep ' T ' | grep $LOGNAME | awk '{print $4}'`

   If you want to be a good citizen and re-freeze them before you exit
   x11vnc this script could be of use:
#!/bin/sh
#
# kill -STOP/-CONT script for x11vnc (or other) SunRay usage ("freezes"
# certain apps from hogging resources when disconnected).
#
# Put here a pattern that matches the apps that are frozen:
#
appmatch="java_vm|jre|netscape-bin|firefox-bin|realplay|acroread|mozilla-bin"

if [ "X$1" = "Xfreeze" ]; then
        pkill -STOP -U $LOGNAME "$appmatch"
elif [ "X$1" = "Xthaw" ]; then
        pkill -CONT -U $LOGNAME "$appmatch"

elif [ "$RFB_MODE" = "afteraccept" -a "$RFB_STATE" = "NORMAL" ]; then
        # a valid x11vnc login.
        if [ "$RFB_CLIENT_COUNT" = "1" ]; then
                # only one client present.
                pkill -CONT -U $LOGNAME "$appmatch"
        fi
elif [ "$RFB_MODE" = "gone" -a "$RFB_STATE" = "NORMAL" ]; then
        # a valid x11vnc login.
        if [ "$RFB_CLIENT_COUNT" = "0" ]; then
                # last client present has just left.
                pkill -STOP -U $LOGNAME "$appmatch"
        fi
fi
exit 0

   If you called the script "goodcitizen" you could type "goodcitizen
   thaw" to unfreeze them, and then "goodcitizen freeze" to refreeze
   them. One could also use these x11vnc options "-afteraccept
   goodcitizen -gone goodcitizen" to do it automatically.

   SunRay Gotcha #4:   Recent versions of the Sun Ray Server Software
   SRSS (seems to be version 3.0 or 3.1) have a "misfeature" that when
   the session is disconnected (i.e. badge/smartcard out) the screen
   locker (xscreensaver) will freeze the X server just when the "Enter
   Password" dialog box appears. So you cannot unlock the screen remotely
   via x11vnc!

   Here "freeze" means "stop other X clients from inserting keyboard and
   mouse input and from viewing the current contents of the screen". Or
   something like that; the upshot is x11vnc can't do its normal thing.

   There are several workarounds for this.

   1) The easiest one by far is to put these lines in your
   $HOME/.dtprofile file:
SUN_SUNRAY_UTXLOCK_PREF="/usr/openwin/bin/xlock -mode blank"
export SUN_SUNRAY_UTXLOCK_PREF

   One might argue that xlock isn't particularly "pretty". (Just IMHO,
   but if something like this not being pretty actually gets in the way
   of your work I think some introspection may be in order. :-)

   2) The problem has been traced to the pam_sunray.so PAM module.
   Evidently xscreensaver invokes this pam module and it communicates
   with utsessiond who in turn instructs the Xsun server to not process
   any synthetic mouse/keyboard input or to update the screen
   framebuffer. It is not clear if this is by design (security?) or
   something else.

   In any event, the problem can be avoided by commenting out the
   corresponding line in /etc/pam.conf:
#xscreensaver auth sufficient /opt/SUNWut/lib/pam_sunray.so syncondisplay

   Leave the other xscreensaver pam authentication lines unchanged. The
   dtsession-SunRay line may also need to be commented out to avoid the
   problem for CDE sessions. N.B. it is possible the application of a
   SSRS patch, etc, may re-enable that /etc/pam.conf line.

   3) A more drastic way is to kill the xscreensaver process from a shell
   prompt whenever you connect via x11vnc and the screen is in a locked
   state:
pkill -U $LOGNAME '^xscreensaver$'

   And then after you are in be sure to restart it by typing something
   like:
xscreensaver &

   You may want to avoid restarting it until you are about to disconnect
   your VNC viewer (since if it locks the screen while you are working
   you'll be stuck again).

   3') The above idea can be done a bit more cleanly by having x11vnc do
   it. Suppose we called the following script xss_killer:
#!/bin/sh
#
# xss_killer: kill xscreensaver after a valid x11vnc client logs in.
#             Restart xscreensaver and lock it when the last client
#             disconnects.

PATH=/usr/openwin/bin:/usr/bin:$PATH
export PATH

if [ "$RFB_MODE" = "afteraccept" -a "$RFB_STATE" = "NORMAL" ]; then
        # a valid x11vnc login.
        if [ "$RFB_CLIENT_COUNT" = "1" ]; then
                # only one client present.
                pkill -U $LOGNAME '^xscreensaver$'
                pkill -KILL -U $LOGNAME -f xscreensaver/hacks
        fi
elif [ "$RFB_MODE" = "gone" -a "$RFB_STATE" = "NORMAL" ]; then
        # a valid x11vnc login.
        if [ "$RFB_CLIENT_COUNT" = "0" ]; then
                # last client present has just left.
                xscreensaver -nosplash &
                sleep 1
                xscreensaver-command -lock &
        fi
fi

   Then we would run x11vnc with these options: "-afteraccept xss_killer
   -gone xss_killer". The [9]-afteraccept option (introduced in version
   0.8) is used to run a command after a vncviewer has successfully
   logged in (note that this is a VNC login, not a Unix login, so you may
   not want to do this if you are really paranoid...)

   Note if you use the above script and also plan to Ctrl-C (SIGINT)
   x11vnc you have to run the xscreensaver in a new process group to
   avoid killing it as well. One way to do this is via this kludge:
perl -e 'setpgrp(0,0); exec "xscreensaver -nosplash &"'

   in the above script.

   4) There appears to be a bug in pam_sunray.so in that it doesn't seem
   to honor the convention that, say, DISPLAY=unix:3 means to use Unix
   sockets to connect to display 3 on the local machine (this is a bit
   faster than TCP sockets). Rather, it thinks the display is a non-local
   one to a machine named "unix" (that usually does not resolve to an IP
   address).

   Amusingly, this can be used to bypass the pam_sunray.so blocking of
   Xsun that prevents one from unlocking the screen remotely via x11vnc.
   One could put something like this in $HOME/.dtprofile to kill any
   existing xscreensavers and then start up a fresh xscreensaver using
   DISPLAY=unix:N
# stop/kill any running xscreensavers (probably not running yet, but to be sure
)
xscreensaver-command -exit
pkill -U $LOGNAME '^xscreensaver$'
env DISPLAY=`echo $DISPLAY | sed -e 's/^.*:/unix:/'` xscreensaver &


   Note that all of the above workarounds side-step the pam_sunray.so PAM
   module in one way or another. You'll need to see if that is
   appropriate for your site's SunRay / smartcard usage. Also, these
   hacks may break other things and so you may want to test various
   scenarios carefully. E.g. check corner cases like XDMCP/dtremote,
   NSCM, etc.

References

   1. http://wwws.sun.com/sunray/index.html
   2. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wait
   3. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sb
   4. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-solid
   5. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbport
   6. http://www.karlrunge.com/x11vnc/vnc_findports
   7. http://www.karlrunge.com/x11vnc/findvncports
   8. http://www.karlrunge.com/x11vnc/shm_clear
   9. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-afteraccept
	
=======================================================================
http://www.karlrunge.com/x11vnc/ssl.html:


   Notes on x11vnc SSL Certificates and Key Management:

   The simplest scheme ("x11vnc -ssl") is where x11vnc generates a
   temporary, self-signed certificate each time (automatically using
   openssl(1)) and the VNC viewer client accepts the certificate without
   question (e.g. user clicks "Yes" in a dialog box. Perhaps the dialog
   allows them to view the certificate too). Also note stunnel's default
   is to quietly accept all certificates.

   The encryption this provides protects against all passive sniffing of
   the VNC traffic and passwords on the network and so it is quite good,
   but it does not prevent a Man-In-The-Middle attack: e.g. an attacker
   intercepts the VNC client stream and sends it his own Public key for
   SSL negotiation (pretending to be the server). Then it makes a
   connection to SSL x11vnc itself and forwards the data back and forth.
   He can see all the traffic and modify it as well.

   Most people don't seem to worry about Man-In-The-Middle attacks these
   days; they are more concerned about passive sniffing. Perhaps someday
   that will change if attack tools are created that make it simpler to
   perform the attack.

   If you are not worried about Man-In-The-Middle attacks you do not have
   to read the techniques described in the rest of this section.

   To prevent Man-In-The-Middle attacks, certificates must somehow be
   verified. This requires the VNC client side have some piece of
   information that can be used to verify the SSL x11vnc server.
   Alternatively, although rarely done, x11vnc could verify VNC Clients'
   certificates, see the [1]-sslverify option that is discussed briefly
   below.

   There are a number of ways to have the client authenticate x11vnc. The
   quickest way perhaps would be to copy (safely) the certificate x11vnc
   prints out:
26/03/2006 21:12:00 Creating a temporary, self-signed PEM certificate...
...
-----BEGIN CERTIFICATE-----
MIIC4TCCAkqgAwIBAgIJAMnwCaOjvEKaMA0GCSqGSIb3DQEBBAUAMIGmMQswCQYD
VQQGEwJBVTEOMAwGA1UEBxMFTGludXgxITAfBgNVBAsTGGFuZ2VsYS0xMTQzNDI1
NTIwLjQxMTE2OTEPMA0GA1UEChMGeDExdm5jMS4wLAYDVQQDEyV4MTF2bmMtU0VM
(more lines) ...
-----END CERTIFICATE-----

   to the client machine(s) and have the client's SSL machinery (e.g.
   stunnel, Web Browser, or Java plugin) import the certificate. That way
   when the connection to x11vnc is made the client can verify that is it
   the desired server on the other side of the SSL connection.

   So, for example suppose the user is using the SSL enabled Java VNC
   Viewer and has incorporated the x11vnc certificate into his Web
   browser on the viewing side. If he gets a dialog that the certificate
   is not verified he knows something is wrong. It may be a
   Man-In-The-Middle attack, but more likely x11vnc certificate has
   changed or expired or his browser was reinstalled and lost the
   certificate, etc, etc.

   As another example, if the user was using [2]stunnel with his VNC
   viewer (this is mentioned [3]in this FAQ), e.g. STUNNEL.EXE on
   Windows, then he would have to set the "CAfile = path-to-the-cert" and
   "verify = 2" options in the stunnel.conf file before starting up the
   tunnel. If a x11vnc certificate cannot be verified, stunnel will drop
   the connection (and print a failure message in its log file).

   A third example, using the VNC viewer on Unix with stunnel the wrapper
   script can be used this way: "[4]ssl_vncviewer -verify ./x11vnc.crt
   far-away.east:0" where ./x11vnc.crt is the copied certificate x11vnc
   printed out.

   Note that in principle the copying of the certificate to the client
   machine(s) itself could be altered in a Man-In-The-Middle attack! You
   can't win. It is unlikely the attacker could predict how you were
   going to send it unless you had, say, done it many times before the
   same way. SSH is a very good way to send it (but of course it too
   depends on public keys being sent unaltered between the two
   machines!). If you are really paranoid, I'm sure you'll figure out a
   really good way to transport the certificates. See the Certificate
   Authority scheme below for a way to make this easier (you just have to
   do it once).


   Saving SSL certificates and keys:

   Now, it would be very inconvenient to copy the new temporary
   certificate every time x11vnc is run in SSL mode. So for convenience
   there is the "SAVE" keyword to instruct x11vnc to save the certificate
   it creates:
  x11vnc -ssl SAVE -display :0 ...

   This way it will save the certificate and private key in these files:
  ~/.vnc/certs/server.crt
  ~/.vnc/certs/server.pem

   The ".crt" file contains only the certificate and should be copied to
   the VNC Viewer machine(s) that will be authenticating the x11vnc
   server. The ".pem" file contains both the certificate and the private
   key and should be kept secret. (If you don't like the default location
   ~/.vnc/certs, e.g. it is on an NFS share and you are worried about
   local network sniffing, use the [5]-ssldir dir option to point to a
   different directory.)

   So the next time you run "x11vnc -ssl SAVE ..." it will read the
   server.pem file directly instead of creating a new one.

   You can manage multiple SSL x11vnc server keys in this simple way by
   using:
  x11vnc -ssl SAVE-key2 -display :0 ...

   etc, where you put whatever name you choose for the key after "SAVE-".
   E.g. "-ssl SAVE-fred".

   Also, if you want to be prompted to possibly change the made up names,
   etc. that x11vnc creates (e.g. "x11vnc-SELF-SIGNED-CERT-7762" for the
   CommonName) for the certificates distinguished name (DN), then use
   "x11vnc -ssl SAVE_PROMPT ...", "x11vnc -ssl SAVE_PROMPT-fred ..." etc.
   when you create the key the first time.

   Tip: when prompting, if you choose the CommonName entry to be the full
   internet hostname of the machine the clients will be connecting to
   then that will avoid an annoying dialog box in their Web browsers that
   warn that the CommonName doesn't match the hostname.


   Passphrases for server keys:

   Well, since now with the "SAVE" keyword the certificate and key will
   be longer lived, one can next worry about somebody stealing the
   private key and pretending to be the x11vnc server! How to guard
   against this?

   The first is that the file is created with perms 600 (i.e. -rw-------)
   to make it harder for an untrusted user to copy the file. A better way
   is to also encrypt the private key with a passphrase. You are prompted
   whether you want to do this or not when the key is first created under
   "-ssl SAVE" mode ("Protect key with a passphrase? [y]/n"). It is
   suggested that you use a passphrase. The inconvenience is every time
   you run "x11vnc -ssl SAVE ..." you will need to supply the passphrase
   to access the private key:
  06/04/2006 11:39:11 using PEM /home/runge/.vnc/certs/server.pem  0.000s

  A passphrase is needed to unlock an OpenSSL private key (PEM file).
  Enter passphrase>

   before x11vnc can continue.


   Being your own Certificate Authority:

   A very sophisticated way that scales well if the number of users is
   large is to use a Certificate Authority (CA) whose public certificate
   is available to all of the VNC clients and whose private key has been
   used to digitally sign the x11vnc server certificate(s).

   The idea is as follows:
     * A special CA cert and key is generated.
     * Its private key is always protected by a good passphrase since it
       is only used for signing.
     * The CA cert is (safely) distributed to all machines where VNC
       clients will run.
     * One or more x11vnc server certs and keys are generated.
     * The x11vnc server cert is signed with the CA private key.
     * x11vnc is run using the server key. (e.g. "[6]-ssl SAVE")
     * VNC clients (viewers) can now authenticate the x11vnc server
       because they have the CA certificate.

   The advantage is the CA cert only needs to be distributed once to the
   various machines, that can be done even before x11vnc server certs are
   generated.

   As above, it is important the CA private key and the x11vnc server key
   are kept secret, otherwise someone could steal them and pretend to be
   the CA or the x11vnc server if they copied the key. It is recommended
   that the x11vnc server keys are also protected via a passphrase (see
   the previous section).

   Optionally, VNC viewer certs and keys could also be generated to
   enable the x11vnc server to authenticate each client. This is not
   normally done (usually a simple viewer password scheme is used), but
   this can be useful in some situations. These optional steps go like
   this:
     * One or more VNC client certs and keys are generated.
     * These VNC client certs are signed with the CA private key.
     * The VNC client certs+keys are safely distributed to the
       corresponding client machines.
     * x11vnc is told to verify clients by using the CA cert. (e.g.
       "[7]-sslverify CA")
     * When VNC clients (viewers) connect, they must authenticate
       themselves to x11vnc by using their client key.

   Again, it is a good idea if the client private keys are protected with
   a passphrase, otherwise if stolen they could be used to gain access to
   the x11vnc server. Once distributed to the client machines, there is
   no need to keep the client key on the CA machine that generated and
   signed it. You can keep the client certs if you like because they are
   public, and they could also be used let in only a subset of all the
   clients. (see [8]-sslverify)


   How to do the above CA steps with x11vnc:

   Some utility commands are provided to ease the cert+key creation,
   signing, and management: [9]-sslGenCA, [10]-sslGenCert,
   [11]-sslDelCert, [12]-sslEncKey, [13]-sslCertInfo. They basically run
   the openssl(1) command for you to manage the certs/keys. It is
   required that openssl(1) is installed on the machine and available in
   PATH. All commands can be pointed to an alternate toplevel certificate
   directory via the [14]-ssldir option if you don't want to use the
   default ~/.vnc/certs.

   1) To generate your Certificate Authority (CA) cert and key run this:
  x11vnc -sslGenCA

   Follow the prompts, you can modify any information strings you care
   to. You will also be required to encrypt the CA private key with a
   passphrase. This generates these files:
  ~/.vnc/certs/CA/cacert.pem             (the CA public certificate)
  ~/.vnc/certs/CA/private/cakey.pem      (the CA private key)

   If you want to use a different directory use [15]-ssldir It must
   supplied with all subsequent SSL utility options to point them to the
   correct directory.

   2) To generate a signed x11vnc server cert and key run this:
  x11vnc -sslGenCert server

   As with the CA generation, follow the prompts and you can modify any
   information strings you care to. This will create the files:
  ~/.vnc/certs/server.crt             (the server public certificate)
  ~/.vnc/certs/server.pem             (the server private key + public cert)

   It is recommended to protect the server private key with a passphrase
   (you will be prompted whether you want to). You will need to provide
   it whenever you start x11vnc using this key.

   3) Start up x11vnc using this server key:
  x11vnc -ssl SAVE -display :0 ...

   (SAVE corresponds to server.pem, see [16]-sslGenCert server somename
   info on creating additional server keys, server-somename.crt ...)

   4) Next, safely copy the CA certificate to the VNC viewer (client)
   machine(s). Perhaps:
  scp ~/.vnc/CA/cacert.pem clientmachine:.

   5) Then the tricky part, make it so the SSL VNC Viewer uses this
   certificate. There are a number of ways this might be done, it depends
   on what your client and/or SSL tunnel is. Some examples:

   For the SSL Java VNC viewer supplied with x11vnc in
   classes/ssl/VncViewer.jar or classes/ssl/SignedVncViewer.jar:
     * Import the cacert.pem cert into your Web Browser (e.g. Edit ->
       Preferences -> Privacy & Security -> Manage Certificates ->
       WebSites -> Import)
     * Or Import the cacert.pem cert into your Java Plugin (e.g. run
       ControlPanel, then Security -> Certificates -> Secure Site ->
       Import)

   When importing, one would give the browser/java-plugin the path to the
   copied cacert.pem file in some dialog. Note that the Web browser or
   Java plugin is used for the server authentication. If the user gets a
   "Site not verified" message while connecting he should investigate
   further.

   For the use of stunnel (e.g. on Windows) one would add this to the
   stunnel.conf:
  # stunnel.conf:
  client = yes
  options = ALL
  CAfile = /path/to/cacert.pem          # or maybe C:\path\to\cacert.pem
  [myvncssl]
  accept = 5901
  connect = far-away.east:5900

   (then point the VNC viewer to localhost:1).

   Here is an example for the Unix stunnel wrapper script
   [17]ssl_vncviewer:
  ssl_vncviewer -verify ./cacert.pem far-away.east:0


   Tricks for server keys:

   To create additional x11vnc server keys do something like this:
  x11vnc -sslGenCert server myotherkey

   and use it this way:
  x11vnc -ssl SAVE-myotherkey ...

   The files will be ~/.vnc/certs/server-myotherkey.{crt,pem}

   You can also create a self-signed server key:
  x11vnc -sslGenCert server self:third_key

   and use it this way:
  x11vnc -ssl SAVE-self:third_key ...

   This key is not signed by your CA. This can be handy to have a key set
   separate from your CA when you do not want to create a 2nd CA
   cert+key.


   Using external CA's:

   You don't have to use your own CA cert+key you can use a third
   party's. Perhaps you have a company-wide CA or you can even have your
   x11vnc certificate signed by a professional CA (e.g. www.thawte.com or
   www.verisign.com).

   The advantage to doing this is that the VNC client machines will
   already have the CA certificates installed and you don't have to
   install it on each machine.

   To generate an x11vnc server cert+key this way you should generate a
   "request" for a certicate signing something like this:
  x11vnc -sslGenCert server req:external

   This will create the request file:
  ~/.vnc/certs/server-req:external.req

   Which you should send to the external CA. When you get the signed
   certificate back from them, save it in the file:
  ~/.vnc/certs/server-req:external.crt

   and create the .pem this way:
  mv  ~/.vnc/certs/server-req:external.key    ~/.vnc/certs/server-req:external.
pem
  chmod 600 ~/.vnc/certs/server-req:external.pem
  cat ~/.vnc/certs/server-req:external.crt >> ~/.vnc/certs/server-req:external.
pem

   You also rename the two files (.crt and .pem) to have a shorter
   basename if you like.


   Using Client Keys for Authentication:

   You can optionally create certs+keys for your VNC client machines as
   well. After distributing them to the client machines you can have
   x11vnc verify the clients using SSL. Here is how to do this:

  x11vnc -sslGenCert client dilbert
  x11vnc -sslGenCert client wally
  x11vnc -sslGenCert client alice
  ...

   As usual, follow the prompts if you want to change any of the info
   field values. As always, it is a good idea to protect the private keys
   with a passphrase. These files are created:
  ~/.vnc/certs/clients/dilbert.crt
  ~/.vnc/certs/clients/dilbert.pem
  ...

   Note that these are kept in a clients subdirectory.

   Next, safely copy the .pem files to each corresponding client machine
   and incorporate them into the VNC viewer / SSL software (see the ideas
   mentioned above for the CA and server keys). The only difference is
   these certificates might be referred to as "My Certificates" or
   "Client Certificates". They are used for client authentication (which
   is relatively rare for SSL).

   After copying them you can delete the clients/*.pem files for extra
   safety because the private keys are not needed by the x11vnc server.
   You don't really need the clients/*.crt files either (because they
   have been signed by the CA). But they could come in handy if you
   wanted to let in just one client.

   Now start up x11vnc and instruct it to verify connecting clients via
   SSL and the CA cert:
  x11vnc -ssl SAVE -sslverify CA

   Finally, connect with your VNC viewer using the key. For the Java
   Applet viewer (TBD...). Here is an example for the Unix stunnel
   wrapper script [18]ssl_vncviewer: using client authentication (and the
   standard server authentication with the CA cert):
  ssl_vncviewer -mycert ./dilbert.pem -verify ./cacert.pem far-away.east:0

   It is also possible to use [19]-sslverify on a per-client key basis,
   and also using self-signed client keys (x11vnc -sslGenCert client
   self:dilbert)


   Additional utlities:

   You can get information about your keys via [20]-sslCertInfo. These
   lists all your keys:
  x11vnc -sslCertInfo list
  x11vnc -sslCertInfo ll

   (the latter is long format).

   These print long output, including the public certificate, for
   individual keys:
  x11vnc -sslCertInfo server
  x11vnc -sslCertInfo dilbert
  x11vnc -sslCertInfo all             (every key, very long)

   If you want to add a protecting passphrase to a key originally created
   without one:
  x11vnc -sslEncKey SAVE
  x11vnc -sslEncKey SAVE-fred

   To delete a cert+key:
  x11vnc -sslDelCert SAVE
  x11vnc -sslDelCert SAVE-fred
  x11vnc -sslDelCert wally

   (but rm(1) will be just as effective).


   More info:

   See also this [21]article for some some general info and examples
   using stunnel and openssl on Windows with VNC.

References

   1. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslverify
   2. http://www.stunnel.org/
   3. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-tunnel-ext
   4. http://www.karlrunge.com/x11vnc/ssl_vncviewer
   5. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssldir
   6. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssl
   7. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslverify
   8. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslverify
   9. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslGenCA
  10. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslGenCert
  11. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslDelCert
  12. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslEncKey
  13. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslCertInfo
  14. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssldir
  15. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssldir
  16. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-ssldir
  17. http://www.karlrunge.com/x11vnc/ssl_vncviewer
  18. http://www.karlrunge.com/x11vnc/ssl_vncviewer
  19. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslverify
  20. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslCertInfo
  21. http://www.securityfocus.com/infocus/1677
	
=======================================================================
http://www.karlrunge.com/x11vnc/ssl-portal.html:


   Using Apache as an SSL Gateway to x11vnc servers inside a firewall:

   Background:

   The standard way to allow access to x11vnc running on workstations
   inside a firewall is via SSH. The user somewhere out on the Internet
   logs in to the SSH gateway machine and uses port forwarding (e.g. ssh
   -L 5900:myworkstation:5900 user@gateway) to set up the encrypted
   channel that VNC is then tunneled through. Next he starts up the VNC
   viewer on the machine where he is sitting directed to the local tunnel
   port.

   The SSH scheme is nice because it is a common and well tested login
   technique for users connecting to machines inside their company or
   home firewall. It is a bit awkward, however, because SSH needs to be
   installed on the Viewer machine and the user usually has to rig up his
   own port redirection plumbing.

   With the SSL support in x11vnc and the SSL enabled Java VNC viewer
   applet, a convenient and secure alternative exists that uses the
   Apache webserver. The idea is that the company or home internet
   connection is already running apache as a web server (either SSL or
   non-SSL) and we add to it the ability to act as a gateway for SSL VNC
   connections. The only thing needed on the Viewer side is a Java
   enabled Web Browser. The stunnel VNC viewer wrapper script provided
   (ssl_vncviewer) can also take advantage of the method described here.
   The apache solution may be overkill for you (e.g. home system) see
   [1]below for some simpler setups.

   There are numerous ways to do this. We present the simplest one here.
   Important: these schemes allow incoming connections from anywhere on
   the Internet to specific ports on machines inside the firewall. Care
   must be taken to implement and test thoroughly. If one is paranoid one
   can (and should) add extra layers of protection. (e.g. extra
   passwords, packet filtering, SSL certificate verification, etc).

   The scheme described here sets up apache on the firewall/gateway as a
   regular Web proxy into the intranet and allows connections to a fixed
   port on a limited set of machines.

   Example:

   In this example suppose the gateway machine running apache is named
   "www.gateway.east" (e.g. it may also provide normal web service). We
   also choose the Internet-facing port for this VNC service to be port
   563. One could choose any port, including the default HTTP port 80.

   We choose 563 because it is the rarely used SNEWS port that is usually
   allowed by Web proxies for the CONNECT method. The idea is the user
   may be coming out of another firewall using a proxy (not the one we
   describe here, that is, the case when two proxies are involved; the
   "double proxy" problem) and using port 563 simplifies things because
   CONNECT's to it are usually allowed by default.

   We also assume all of the x11vnc servers on the internal machines are
   all listening on port 5915 ("-rfbport 5915") instead of the default
   5900. This is to limit any unintended proxy redirections to a lesser
   used port, and also to stay out of the way of normal VNC servers on
   the same machines. One could obviously implement a scheme that handles
   different ports, but we just discuss this simplest setup here.

   So we assume x11vnc has been started this way on all of the
   workstations to be granted VNC access:
  x11vnc -ssl -http -display :0 -forever -rfbauth ~/.vnc/passwd -rfbport 5915

   i.e. we force SSL VNC connections, port 5915, serve the Java VNC
   viewer applet, and require a VNC password (another option would be
   [2]-unixpw). The above command could also be run out of [3]inetd(8),
   that can also be used to autodetect the user's display and Xauthority
   data.


   These sections are added to the httpd.conf apache configuration file
   on www.gateway.east:
Listen 563

<VirtualHost localhost:563>
   # this is a "bounce" failure from the ProxyRemoteMatch below.
   ProxyRequests Off
</VirtualHost>

<VirtualHost *:563>
   # for convenience, a rewrite to avoid having ...?CONNECT=..&PORT=... in the
URL.
   RewriteEngine On
   RewriteRule /vnc/([^/]*)$            /vnc/$1/index.vnc?CONNECT=$1+5915&PORT=
563 [R,NE]
   RewriteRule /vnc/proxy/([^/]*)$      /vnc/$1/proxy.vnc?CONNECT=$1+5915&PORT=
563 [R,NE]

   # allow incoming proxy CONNECT requests to port 5915 *only*
   ProxyRequests On
   AllowCONNECT 5915

   # this will fetch the jar file from port 5815 via http (not https)
   # (list all allowed x11vnc servers here)
   ProxyPass /vnc/mach1/        http://mach1:5815/
   ProxyPass /vnc/mach2/        http://mach2:5815/
   ProxyPass /vnc/mach3/        http://mach3:5815/
   ProxyPass /vnc/mach4/        http://mach4:5815/
   # ...

   # force a reject for any CONNECT not to the known list of x11vnc servers:
   # (list all allowed x11vnc servers here)
   ProxyRemoteMatch ^(?!(http://|mach1:|mach2:|mach3:|mach4:))  http://localhos
t:563/

</VirtualHost>

   Note that the listing of allowed internal workstations (mach1, mach2,
   ...) is done in two places. The above setup requires mod_rewrite
   (optional) and mod_proxy (required) be enabled in the apache web
   server.

   The user at the Java enabled Web browser would simply enter this URL
   into the browser:
   http://www.gateway.east:563/vnc/mach2

   to connect to internal workstation mach2, etc. There will be a number
   of SSL certificate, etc, dialogs he will have to respond to in
   addition to any passwords he is required to provide (this depends on
   how you set up user authentication for x11vnc).

   If a second Web proxy is involved (i.e. the user's browser is inside
   another firewall that requires proxying) then use this URL:
   http://www.gateway.east:563/vnc/proxy/mach2

   See [4]this FAQ for more info on how this works.


   Let's go through the httpd.conf additions in detail.

   The VirtualHost localhost:563 section is used as a bounce if anyone
   tries to connect to a workstation machine not listed in httpd.conf.
   See ProxyRemoteMatch below.

   The RewriteRule's are for convenience only so that the URL entered
   into the Web browser does not need the various extra parameters, e.g.:
   http://www.gateway.east:563/vnc/mach2/index.vnc?CONNECT=mach2+5915&PORT=563

   (or otherwise make direct edits to index.vnc to set these parameters).

   Next, the "ProxyRequests On" and "AllowCONNECT 5915" enable the web
   server to forward proxy requests to port 5915 (and only this port)
   INSIDE the firewall. Test this carefully.

   The "ProxyPass /vnc/mach1/ ..." lines forward the initial page (e.g.
   index.vnc) and Java applet JAR file (e.g. VncViewer.jar) requests to
   port 5815 on the x11vnc server machines.

   Note that these index.vnc and VncViewer.jar downloads are not
   encrypted via SSL. The subsequent VNC connections are encrypted
   however. See below for how to have these initial downloads encrypted
   as well (if the apache web server has SSL, i.e. https, enabled and
   configured).

   Finally, the ProxyRemoteMatch redirects any request that is not a
   http: URL or a CONNECT to a valid machine (mach1, ... etc) to
   localhost:563 which has proxying disabled ("ProxyRequests Off") and so
   effectively drops the connection.


   Some Ideas for adding extra authentication, etc. for the paranoid:
     * VNC passwords: [5]-rfbauth, [6]-passwdfile, or [7]-usepw. Even
       adding a company-wide VNC password helps block unwanted access.
     * Unix passwords: [8]-unixpw
     * SSL Client certificates: [9]-sslverify
     * Apache AuthUserFile directive: .htaccess, etc.
     * Add proxy password authentication (requires Viewer changes?)
     * Run a separate instance of Apache that provides this VNC service
       so it can be brought up and down independently of the normal web
       server.



   Using non-Java viewers with this scheme:

   The [10]ssl_vncviewer stunnel wrapper script for VNC viewers has the
   -proxy option that can take advantage of this method. For the case of
   the "double proxy" situation (see below) supply both separated by a
   comma.
   ssl_vncviewer -proxy www.gateway.east:563 mach1:15
   ssl_vncviewer -proxy proxy1.foobar.com:8080,www.gateway.east:563 mach1:15


   Downloading the Java applet via HTTPS:

   To have the Java applet downloaded to the user's Web Browswer via an
   encrypted (and evidently safer) SSL connection the Apache webserver
   should be configured for SSL via [11]mod_ssl (this is probably not
   absolutely necessary; show us how you did it).

   It is actually possible to use the x11vnc [12]Key Management utility
   "[13]-sslGenCert" to generate your Apache/SSL .crt and .key files. (In
   brief, run something like "x11vnc -sslGenCert server self:apache" then
   copy the resulting self:apache.crt file to conf/ssl.crt/server.crt and
   extract the private key part from self:apache.pem and paste it into
   conf/ssl.key/server.key). Or you can use the standard methods
   described in the Apache mod_ssl documentation.

   In addition to the above sections in httpd.conf one should add the
   following to ssl.conf:
SSLProxyEngine  On

# for convenience, a rewrite to avoid having ...?CONNECT=... in URL.
RewriteEngine On
RewriteRule /vnc/([^/]*)$               /vnc/$1/index.vnc?CONNECT=$1+5915&PORT=
563 [R,NE]
RewriteRule /vnc/proxy/([^/]*)$         /vnc/$1/proxy.vnc?CONNECT=$1+5915&PORT=
563 [R,NE]

# these "vncs" are for https applet downloading:
RewriteRule /vncs/([^/]*)$             /vncs/$1/index.vnc?CONNECT=$1+5915&PORT=
563 [R,NE]
RewriteRule /vncs/proxy/([^/]*)$       /vncs/$1/proxy.vnc?CONNECT=$1+5915&PORT=
563 [R,NE]

# fetch the jar file from port 5815 via http or port 5915 via https
# inside the firewall
# (list all allowed x11vnc servers here)
ProxyPass /vnc/mach1/       http://mach1:5815/
ProxyPass /vnc/mach2/       http://mach2:5815/
ProxyPass /vnc/mach3/       http://mach3:5815/
ProxyPass /vnc/mach4/       http://mach4:5815/
ProxyPass /vncs/mach1/      https://mach1:5915/
ProxyPass /vncs/mach2/      https://mach2:5915/
ProxyPass /vncs/mach3/      https://mach3:5915/
ProxyPass /vncs/mach4/      https://mach4:5915/

   This is all in the "<VirtualHost _default_:443>" section of ssl.conf.

   The user could then point the Web Browser to:
   https://www.gateway.east/vnc/mach2

   or
   https://www.gateway.east/vnc/proxy/mach2

   for the "double proxy" case.

   Note that inside the firewall the Java applet download traffic is not
   encrypted (only over the Internet is SSL used) for these cases:
   https://www.gateway.east/vnc/mach2
   https://www.gateway.east/vnc/proxy/mach2

   However for the special "vncs" rules above:
   https://www.gateway.east/vncs/mach2

   the Java applet download is encrypted via SSL for both legs. Note that
   the two legs are two separate SSL sessions. So the data is uncrypted
   inside an apache process and reencrypted for the 2nd SSL session
   inside the same apache process (a very small gap one might overlook).

   In all of the above cases the VNC traffic from Viewer to x11vnc is
   encrypted end-to-end in a single SSL session, even for the "double
   proxy" case. This is the important part to have encrypted.

   Note that the Certificate dialogs the user has in his web browser will
   be for the Apache Certificate, while for the Java applet it will be
   the x11vnc certificate.

   Note also that you can have Apache serve up the Jar file VncViewer.jar
   instead of each x11vnc if you want to.


   INETD automation:

   The "single-port" (i.e. 5915) HTTPS applet download and VNC connection
   aspect shown here is convenient and also enables having x11vnc run out
   of inetd. That way x11vnc is run on demand instead of being run all
   the time (the user does not have to remember to start it). The first
   connections to inetd download index.vnc and the Jar file (via https)
   and the the last connection to inetd establishes the SSL VNC
   connection. Since x11vnc is restarted for each connection, this will
   be a bit slower than the normal process.

   For example, the /etc/inetd.conf line could be:
  5915 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc_ssl.sh

   where the script x11vnc_ssl.sh looks something like this:
#!/bin/sh

/usr/local/bin/x11vnc -inetd -oa /var/log/x11vnc-15.log \
        -ssl SAVE -http -unixpw -localhost \
        -display :0 -auth /home/THE_USER/.Xauthority

   where, as usual, the inetd launching needs to know which user is
   typically using the display on that machine. One could imagine giving
   different users different ports, 5915, 5916, etc. to distinguish (then
   the script would need to be passed the username). mod_rewrite could be
   used to automatically map username in the URL to his port number.

   A better way is to use the "-display WAIT:cmd=FINDDISPLAY" feature to
   autodetect the user and Xauthority data:
#!/bin/sh

/usr/local/bin/x11vnc -inetd -oa /var/log/x11vnc-15.log \
        -ssl SAVE -http -unixpw -localhost -users unixpw= \
        -display WAIT:cmd=FINDDISPLAY

   this way the user must supply his Unix username and password and then
   his display and Xauthority data on that machine will be located and
   returned to x11vnc to allow it to attach. If he doesn't have a display
   running on that machine or he fails to log in correctly, the
   connection will be dropped.

   To enable inetd operation for the non-HTTPS Java viewer download (port
   5815 in the above httpd.conf example) you will need to run x11vnc in
   HTTPONCE mode on port 5815: For example, the /etc/inetd.conf line
   could be:
  5815 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc \
       -inetd -oa /var/log/x11vnc-15.log -http_ssl -display WAIT:cmd=HTTPONCE

   where the long inetd.conf line has been split. Note how the
   [14]-http_ssl tries to automatically find the .../classes/ssl
   subdirectory.

   Also note the use of "-ssl SAVE" above. This way a saved server.pem is
   used for each inetd invocation (rather generating a new one each
   time). Note that it cannot have a protecting passphrase because inetd
   will not be able to supply it.


   Other Ideas:

   - The above schemes work, but they are a bit complicated with all of
   the rigging. There should be better ways to configure Apache to do
   these, but we have not found them (please let us know if you discover
   something nice). However, once this scheme has been set up and is
   working it is easy to maintain and add workstations, etc.

   - In general Apache is not required, but it makes things convenient.
   The firewall itself could do the port redirection via its firewall
   rules. Evidently different Internet-facing ports would be required for
   each workstation. This could be set up using iptables rules for
   example. If there were just one or two machines this would be the
   easiest method. For example:
  iptables -t nat -A PREROUTING -p tcp -d 24.35.46.57 --dport 5901 -j DNAT --to
-destination 192.168.1.2:5915
  iptables -t nat -A PREROUTING -p tcp -d 24.35.46.57 --dport 5902 -j DNAT --to
-destination 192.168.1.3:5915

   Where 24.35.46.57 is the internet IP address of the gateway. In this
   example 24.35.46.57:5901 is redirected to the internal machine
   192.168.1.2:5915 and 24.35.46.57:5902 is redirected to another
   internal machine 192.168.1.3:5915, both running x11vnc -ssl ... in SSL
   mode. For this example, the user would point the web browser to, e.g.:
  https://24.35.46.57:5901/?PORT=5901

   or using the stunnel wrapper script:
  ssl_vncviewer 24.35.46.57:1

   One can acheive similar things with dedicated firewall/routers (e.g.
   Linksys) using the device's web or other interface to configure the
   firewall.

   If the user may be coming out of a firewall using a proxy it may be
   better to redirect ports 443 and 563 (instead of 5901 and 5902) to the
   internal machines so that the user's proxy will allow CONNECTing to
   them.

   - The redirection could also be done at the application level using a
   TCP redirect program (e.g. ip_relay or fancier ones). Evidently more
   careful internal hostname checking, etc., could be performed by the
   special purpose application to add security.

   - One might imagine the ProxyPass could be done for the VNC traffic as
   well (for the ssl.conf case) to avoid the CONNECT proxying completely
   (which would be nice to avoid). Unfortunately we were not able to get
   this to work. Since HTTP is a request-response protocol (as opposed to
   a full bidirectional link required by VNC) this makes it difficult to
   do. It may be possible, but we haven't found out how yet.

References

   1. http://www.karlrunge.com/x11vnc/ssl-portal.html#no-apache
   2. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-unixpw
   3. http://www.karlrunge.com/x11vnc/ssl-portal.html#inetd
   4. http://www.karlrunge.com/x11vnc/index.html#faq-ssl-java-viewer-proxy
   5. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
   6. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwdfile
   7. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-usepw
   8. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-unixpw
   9. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslverify
  10. http://www.karlrunge.com/x11vnc/index.html#ssl_vncviewer
  11. http://httpd.apache.org/docs/2.0/mod/mod_ssl.html
  12. http://www.karlrunge.com/x11vnc/ssl.html
  13. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sslGenCert
  14. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-http_ssl
	
=======================================================================
http://www.karlrunge.com/x11vnc/x11vnc_opts.html:


     _________________________________________________________________

x11vnc: a VNC server for real X displays

   Here are all of x11vnc command line options:
% x11vnc -opts      (see below for -help long descriptions)

x11vnc: allow VNC connections to real X11 displays. 0.8.2 lastmod: 2006-06-27

x11vnc options:
  -display disp            -auth file               -id windowid           
  -sid windowid            -clip WxH+X+Y            -flashcmap             
  -shiftcmap n             -notruecolor             -visual n              
  -overlay                 -overlay_nocursor        -8to24 [opts]          
  -24to32                  -scale fraction          -scale_cursor frac     
  -viewonly                -shared                  -once                  
  -forever                 -loop                    -timeout n             
  -inetd                   -nofilexfer              -http                  
  -http_ssl                -connect string          -vncconnect            
  -novncconnect            -allow host1[,host2..]   -localhost             
  -nolookup                -input string            -grabkbd               
  -grabptr                 -viewpasswd string       -passwdfile filename   
  -unixpw [list]           -unixpw_nis [list]       -display WAIT:...      
  -ssl [pem]               -ssldir [dir]            -sslverify [path]      
  -sslGenCA [dir]          -sslGenCert type name    -sslEncKey [pem]       
  -sslCertInfo [pem]       -sslDelCert [pem]        -stunnel [pem]         
  -stunnel3  [pem]         -https [port]            -usepw                 
  -storepasswd pass file   -nopw                    -accept string         
  -afteraccept string      -gone string             -users list            
  -noshm                   -flipbyteorder           -onetile               
  -solid [color]           -blackout string         -xinerama              
  -noxinerama              -xtrap                   -xrandr [mode]         
  -padgeom WxH             -o logfile               -flag file             
  -rc filename             -norc                    -env VAR=VALUE         
  -h, -help                -?, -opts                -V, -version           
  -dbg                     -q                       -bg                    
  -modtweak                -nomodtweak              -xkb                   
  -noxkb                   -capslock                -skip_lockkeys         
  -skip_keycodes string    -sloppy_keys             -skip_dups             
  -noskip_dups             -add_keysyms             -noadd_keysyms         
  -clear_mods              -clear_keys              -remap string          
  -norepeat                -repeat                  -nofb                  
  -nobell                  -nosel                   -noprimary             
  -nosetprimary            -noclipboard             -nosetclipboard        
  -seldir string           -cursor [mode]           -nocursor              
  -arrow n                 -noxfixes                -alphacut n            
  -alphafrac fraction      -alpharemove             -noalphablend          
  -nocursorshape           -cursorpos               -nocursorpos           
  -xwarppointer            -buttonmap string        -nodragging            
  -wireframe [str]         -nowireframe             -wirecopyrect mode     
  -nowirecopyrect          -debug_wireframe         -scrollcopyrect mode   
  -noscrollcopyrect        -scr_area n              -scr_skip list         
  -scr_inc list            -scr_keys list           -scr_term list         
  -scr_keyrepeat lo-hi     -scr_parms string        -fixscreen string      
  -debug_scroll            -noxrecord               -grab_buster           
  -nograb_buster           -debug_grabs             -debug_sel             
  -pointer_mode n          -input_skip n            -speeds rd,bw,lat      
  -wmdt string             -debug_pointer           -debug_keyboard        
  -defer time              -wait time               -wait_ui factor        
  -nowait_bog              -slow_fb time            -readtimeout n         
  -nap                     -nonap                   -sb time               
  -nofbpm                  -fbpm                    -noxdamage             
  -xd_area A               -xd_mem f                -sigpipe string        
  -threads                 -nothreads               -fs f                  
  -gaps n                  -grow n                  -fuzz n                
  -debug_tiles             -snapfb                  -rawfb string          
  -freqtab file            -pipeinput cmd           -gui [gui-opts]        
  -remote command          -query variable          -QD variable           
  -sync                    -noremote                -yesremote             
  -unsafe                  -safer                   -privremote            
  -nocmds                  -allowedcmds list        -deny_all              


libvncserver options:
-rfbport port          TCP port for RFB protocol
-rfbwait time          max time in ms to wait for RFB client
-rfbauth passwd-file   use authentication on RFB protocol
                       (use 'storepasswd' to create a password file)
-rfbversion 3.x        Set the version of the RFB we choose to advertise
-permitfiletransfer    permit file transfer support
-passwd plain-password use authentication 
                       (use plain-password as password, USE AT YOUR RISK)
-deferupdate time      time in ms to defer updates (default 40)
-deferptrupdate time   time in ms to defer pointer updates (default none)
-desktop name          VNC desktop name (default "LibVNCServer")
-alwaysshared          always treat new clients as shared
-nevershared           never treat new clients as shared
-dontdisconnect        don't disconnect existing clients when a new non-shared
                       connection comes in (refuse new connection instead)
-httpdir dir-path      enable http server using dir-path home
-httpport portnum      use portnum for http connection
-enablehttpproxy       enable http proxy support
-progressive height    enable progressive updating for slow links
-listen ipaddr         listen for connections only on network interface with
                       addr ipaddr. '-listen localhost' and hostname work too.

libvncserver-tight-extension options:
-disablefiletransfer   disable file transfer
-ftproot string        set ftp root




% x11vnc -help

x11vnc: allow VNC connections to real X11 displays. 0.8.2 lastmod: 2006-06-27

(type "x11vnc -opts" to just list the options.)

Typical usage is:

   Run this command in a shell on the remote machine "far-host"
   with X session you wish to view:

       x11vnc -display :0

   Then run this in another window on the machine you are sitting at:

       vncviewer far-host:0

Once x11vnc establishes connections with the X11 server and starts listening
as a VNC server it will print out a string: PORT=XXXX where XXXX is typically
5900 (the default VNC server port).  One would next run something like
this on the local machine: "vncviewer hostname:N" where "hostname" is
the name of the machine running x11vnc and N is XXXX - 5900, i.e. usually
"vncviewer hostname:0".

By default x11vnc will not allow the screen to be shared and it will exit
as soon as the client disconnects.  See -shared and -forever below to override
these protections.  See the FAQ for details how to tunnel the VNC connection
through an encrypted channel such as ssh(1).  In brief:

       ssh -L 5900:localhost:5900 far-host 'x11vnc -localhost -display :0'

       vncviewer -encodings 'copyrect tight zrle hextile' localhost:0

Also, use of a VNC password (-rfbauth or -passwdfile) is strongly recommend.

For additional info see: http://www.karlrunge.com/x11vnc/
                    and  http://www.karlrunge.com/x11vnc/#faq


Rudimentary config file support: if the file $HOME/.x11vncrc exists then each
line in it is treated as a single command line option.  Disable with -norc.
For each option name, the leading character "-" is not required.  E.g. a
line that is either "forever" or "-forever" may be used and are equivalent.
Likewise "wait 100" or "-wait 100" are acceptable and equivalent lines.
The "#" character comments out to the end of the line in the usual way
(backslash it for a literal).  Leading and trailing whitespace is trimmed off.
Lines may be continued with a "\" as the last character of a line (it
becomes a space character).

Options:

-display disp          X11 server display to connect to, usually :0.  The X
                       server process must be running on same machine and
                       support MIT-SHM.  Equivalent to setting the DISPLAY
                       environment variable to "disp".  See the description
                       below of the "-display WAIT:..." extensions.
-auth file             Set the X authority file to be "file", equivalent to
                       setting the XAUTHORITY environment variable to "file"
                       before startup.  Same as -xauth file.  See Xsecurity(7),
                       xauth(1) man pages for more info.

-id windowid           Show the window corresponding to "windowid" not
                       the entire display.  New windows like popup menus,
                       transient toplevels, etc, may not be seen or may be
                       clipped.  Disabling SaveUnders or BackingStore in the
                       X server may help show them.  x11vnc may crash if the
                       window is initially partially obscured, changes size,
                       is iconified, etc.  Some steps are taken to avoid this
                       and the -xrandr mechanism is used to track resizes.  Use
                       xwininfo(1) to get the window id, or use "-id pick"
                       to have x11vnc run xwininfo(1) for you and extract
                       the id.  The -id option is useful for exporting very
                       simple applications (e.g. the current view on a webcam).
-sid windowid          As -id, but instead of using the window directly it
                       shifts a root view to it: this shows SaveUnders menus,
                       etc, although they will be clipped if they extend beyond
                       the window.
-clip WxH+X+Y          Only show the sub-region of the full display that
                       corresponds to the rectangle with size WxH and offset
                       +X+Y.  The VNC display has size WxH (i.e. smaller than
                       the full display).  This also works for -id/-sid mode
                       where the offset is relative to the upper left corner
                       of the selected window.

-flashcmap             In 8bpp indexed color, let the installed colormap flash
                       as the pointer moves from window to window (slow).
                       Also try the -8to24 option to avoid flash altogether.
-shiftcmap n           Rare problem, but some 8bpp displays use less than 256
                       colorcells (e.g. 16-color grayscale, perhaps the other
                       bits are used for double buffering) *and* also need to
                       shift the pixels values away from 0, .., ncells.  "n"
                       indicates the shift to be applied to the pixel values.
                       To see the pixel values set DEBUG_CMAP=1 to print out
                       a colormap histogram.  Example: -shiftcmap 240
-notruecolor           For 8bpp displays, force indexed color (i.e. a colormap)
                       even if it looks like 8bpp TrueColor (rare problem).
-visual n              Experimental option: probably does not do what you
                       think.  It simply *forces* the visual used for the
                       framebuffer; this may be a bad thing... (e.g. messes
                       up colors or cause a crash). It is useful for testing
                       and for some workarounds.  n may be a decimal number,
                       or 0x hex.  Run xdpyinfo(1) for the values.  One may
                       also use "TrueColor", etc. see <X11/X.h> for a list.
                       If the string ends in ":m" then for better or for
                       worse the visual depth is forced to be m.

-overlay               Handle multiple depth visuals on one screen, e.g. 8+24
                       and 24+8 overlay visuals (the 32 bits per pixel are
                       packed with 8 for PseudoColor and 24 for TrueColor).

                       Currently -overlay only works on Solaris via
                       XReadScreen(3X11) and IRIX using XReadDisplay(3).
                       On Solaris there is a problem with image "bleeding"
                       around transient popup menus (but not for the menu
                       itself): a workaround is to disable SaveUnders
                       by passing the "-su" argument to Xsun (in
                       /etc/dt/config/Xservers).

                       Use -overlay as a workaround for situations like these:
                       Some legacy applications require the default visual to
                       be 8bpp (8+24), or they will use 8bpp PseudoColor even
                       when the default visual is depth 24 TrueColor (24+8).
                       In these cases colors in some windows will be incorrect
                       in x11vnc unless -overlay is used.  Another use of
                       -overlay is to enable showing the exact mouse cursor
                       shape (details below).

                       Under -overlay, performance will be somewhat slower
                       due to the extra image transformations required.
                       For optimal performance do not use -overlay, but rather
                       configure the X server so that the default visual is
                       depth 24 TrueColor and try to have all apps use that
                       visual (e.g. some apps have -use24 or -visual options).
-overlay_nocursor      Sets -overlay, but does not try to draw the exact mouse
                       cursor shape using the overlay mechanism.

-8to24 [opts]          Try this option if -overlay is not supported on your
                       OS, and you have a legacy 8bpp app that you want to
                       view on a multi-depth display with default depth 24
                       (and is 32 bpp) OR have a default depth 8 display with
                       depth 24 overlay windows for some apps.  This option
                       may not work on all X servers and hardware (tested
                       on XFree86/Xorg mga driver and Xsun).  The "opts"
                       string is not required and is described below.

                       This mode enables a hack where x11vnc monitors windows
                       within 3 levels from the root window.  If it finds
                       any that are 8bpp it extracts the indexed color
                       pixel values using XGetImage() and then applies a
                       transformation using the colormap(s) to create TrueColor
                       RGB values that it in turn inserts into bits 1-24 of
                       the framebuffer.  This creates a depth 24 "view"
                       of the display that is then exported via VNC.

                       Conversely, for default depth 8 displays, the depth
                       24 regions are read by XGetImage() and everything is
                       transformed and inserted into a depth 24 TrueColor
                       framebuffer.

                       Note that even if there are *no* depth 24 visuals or
                       windows (i.e. pure 8bpp), this mode is potentially
                       an improvement over -flashcmap because it avoids the
                       flashing and shows each window in the correct color.

                       This method appear to work, but may still have bugs
                       and it does hog resources.  If there are multiple 8bpp
                       windows using different colormaps, one may have to
                       iconify all but one for the colors to be correct.

                       There may be painting errors for clipping and switching
                       between windows of depths 8 and 24.  Heuristics are
                       applied to try to minimize the painting errors.  One can
                       also press 3 Alt_L's in a row to refresh the screen
                       if the error does not repair itself.  Also the option
                       -fixscreen 8=3.0 or -fixscreen V=3.0 may be used to
                       periodically refresh the screen at the cost of bandwidth
                       (every 3 sec for this example).

                       The [opts] string can contain the following settings.
                       Multiple settings are separated by commas.

                       For for some X servers with default depth 24 a
                       speedup may be achieved via the option "nogetimage".
                       This enables a scheme were XGetImage() is not used
                       to retrieve the 8bpp data.  Instead, it assumes that
                       the 8bpp data is in bits 25-32 of the 32bit X pixels.
                       There is no reason the X server should put the data
                       there for our poll requests, but some do and so the
                       extra steps to retrieve it can be skipped.  Tested with
                       mga driver with XFree86/Xorg.  For the default depth
                       8 case this option is ignored.

                       To adjust how often XGetImage() is used to poll the
                       non-default visual regions for changes, use the option
                       "poll=t" where "t" is a floating point time.
                       (default: 0.05)

                       Setting the option "level2" will limit the search
                       for non-default visual windows to two levels from the
                       root window.  Do this on slow machines where you know
                       the window manager only imposes one extra window between
                       the app window and the root window.

                       Also for very slow machines use "cachewin=t"
                       where t is a floating point amount of time to cache
                       XGetWindowAttributes results.  E.g. cachewin=5.0.
                       This may lead to the windows being unnoticed for this
                       amount of time when deiconifying, painting errors, etc.

                       While testing on a very old SS20 these options gave
                       tolerable response: -8to24 poll=0.2,cachewin=5.0. For
                       this machine -overlay is supported and gives better
                       response.

                       Debugging for this mode can be enabled by setting
                       "dbg=1", "dbg=2", or "dbg=3".

-24to32                Very rare problem: if the framebuffer (X display
                       or -rawfb) is 24bpp instead of the usual 32bpp, then
                       dynamically transform the pixels to 32bpp.  This will be
                       slower, but can be used to work around problems where
                       VNC viewers cannot handle 24bpp (e.g. "main: setPF:
                       not 8, 16 or 32 bpp?").  See the FAQ for more info.

                       In the case of -rawfb mode, the pixels are directly
                       modified by inserting a 0 byte to pad them out to 32bpp.
                       For X displays, a kludge is done that is equivalent to
                       "-noshm -visual TrueColor:32".  (If better performance
                       is needed for the latter, feel free to ask).

-scale fraction        Scale the framebuffer by factor "fraction".  Values
                       less than 1 shrink the fb, larger ones expand it.  Note:
                       image may not be sharp and response may be slower.
                       If "fraction" contains a decimal point "." it
                       is taken as a floating point number, alternatively
                       the notation "m/n" may be used to denote fractions
                       exactly, e.g. -scale 2/3

                       Scaling Options: can be added after "fraction" via
                       ":", to supply multiple ":" options use commas.
                       If you just want a quick, rough scaling without
                       blending, append ":nb" to "fraction" (e.g. -scale
                       1/3:nb).  No blending is the default for 8bpp indexed
                       color, to force blending for this case use ":fb".

                       To disable -scrollcopyrect and -wirecopyrect under
                       -scale use ":nocr".  If you need to to enable them use
                       ":cr" or specify them explicitly on the command line.
                       If a slow link is detected, ":nocr" may be applied
                       automatically.  Default: :cr

                       More esoteric options: for compatibility with vncviewers
                       the scaled width is adjusted to be a multiple of 4:
                       to disable this use ":n4".  ":in" use interpolation
                       scheme even when shrinking, ":pad" pad scaled width
                       and height to be multiples of scaling denominator
                       (e.g. 3 for 2/3).

-scale_cursor frac     By default if -scale is supplied the cursor shape is
                       scaled by the same factor.  Depending on your usage,
                       you may want to scale the cursor independently of the
                       screen or not at all.  If you specify -scale_cursor
                       the cursor will be scaled by that factor.  When using
                       -scale mode to keep the cursor at its "natural" size
                       use "-scale_cursor 1".  Most of the ":" scaling
                       options apply here as well.

-viewonly              All VNC clients can only watch (default off).
-shared                VNC display is shared, i.e. more than one viewer can
                       connect at the same time (default off).
-once                  Exit after the first successfully connected viewer
                       disconnects, opposite of -forever. This is the Default.
-forever               Keep listening for more connections rather than exiting
                       as soon as the first client(s) disconnect. Same as -many
-loop                  Create an outer loop restarting the x11vnc process
                       whenever it terminates.  -bg and -inetd are ignored in
                       this mode.  Useful for continuing even if the X server
                       terminates and restarts (you will need permission to
                       reconnect of course).   Use, e.g., -loop100 to sleep
                       100 millisecs between restarts, etc.  Default is 2000ms
                       (i.e. 2 secs)  Use, e.g. -loop300,5 to sleep 300 ms
                       and only loop 5 times.
-timeout n             Exit unless a client connects within the first n seconds
                       after startup.
-inetd                 Launched by inetd(8): stdio instead of listening socket.
                       Note: if you are not redirecting stderr to a log file
                       (via shell 2> or -o option) you MUST also specify the -q
                       option, otherwise the stderr goes to the viewer which
                       will cause it to abort.  Specifying both -inetd and -q
                       and no -o will automatically close the stderr.

-nofilexfer            Disable the TightVNC file transfer extension.  (same as
                       -disablefiletransfer).  Note that when the -viewonly
                       option is supplied all file transfers are disabled.
                       Also clients that log in viewonly cannot transfer files.
                       However, if the remote control mechanism is used to
                       change the global or per-client viewonly state the
                       filetransfer permissions will NOT change.

-http                  Instead of using -httpdir (see below) to specify
                       where the Java vncviewer applet is, have x11vnc try
                       to *guess* where the directory is by looking relative
                       to the program location and in standard locations
                       (/usr/local/share/x11vnc/classes, etc).  Under -ssl or
                       -stunnel the ssl classes subdirectory is sought.
-http_ssl              As -http, but force lookup for ssl classes subdir.

-connect string        For use with "vncviewer -listen" reverse connections.
                       If "string" has the form "host" or "host:port"
                       the connection is made once at startup.  Use commas
                       for a list of host's and host:port's.

                       Note that unlike most vnc servers, x11vnc will require a
                       password for reverse as well as for forward connections.
                       (provided password auth has been enabled, -rfbauth, etc)
                       If you do not want to require a password for reverse
                       connections set X11VNC_REVERSE_CONNECTION_NO_AUTH=1 in
                       your environment before starting x11vnc.

                       If "string" contains "/" it is instead interpreted
                       as a file to periodically check for new hosts.
                       The first line is read and then the file is truncated.
                       Be careful for this usage mode if x11vnc is running as
                       root (e.g. via gdm(1), etc).

-vncconnect            Monitor the VNC_CONNECT X property set by the standard
-novncconnect          VNC program vncconnect(1).  When the property is
                       set to "host" or "host:port" establish a reverse
                       connection.  Using xprop(1) instead of vncconnect may
                       work (see the FAQ).  The -remote control mechanism uses
                       X11VNC_REMOTE channel, and this option disables/enables
                       it as well.  Default: -vncconnect

-allow host1[,host2..] Only allow client connections from hosts matching
                       the comma separated list of hostnames or IP addresses.
                       Can also be a numerical IP prefix, e.g. "192.168.100."
                       to match a simple subnet, for more control build
                       libvncserver with libwrap support (See the FAQ).  If the
                       list contains a "/" it instead is a interpreted as a
                       file containing addresses or prefixes that is re-read
                       each time a new client connects.  Lines can be commented
                       out with the "#" character in the usual way.
-localhost             Same as "-allow 127.0.0.1".

                       Note: if you want to restrict which network interface
                       x11vnc listens on, see the -listen option below.
                       E.g. "-listen localhost" or "-listen 192.168.3.21".
                       As a special case, the option "-localhost" implies
                       "-listen localhost".

                       For non-localhost -listen usage, if you use the remote
                       control mechanism (-R) to change the -listen interface
                       you may need to manually adjust the -allow list (and
                       vice versa) to avoid situations where no connections
                       (or too many) are allowed.

-nolookup              Do not use gethostbyname() or gethostbyaddr() to look up
                       host names or IP numbers.  Use this if name resolution
                       is incorrectly set up and leads to long pauses as name
                       lookups time out, etc.

-input string          Fine tuning of allowed user input.  If "string" does
                       not contain a comma "," the tuning applies only to
                       normal clients.  Otherwise the part before "," is for
                       normal clients and the part after for view-only clients.
                       "K" is for Keystroke input, "M" for Mouse-motion
                       input, "B" for Button-click input, and "C" is for
                       Clipboard input.  Their presence in the string enables
                       that type of input.  E.g. "-input M" means normal
                       users can only move the mouse and  "-input KMBC,M"
                       lets normal users do anything and enables view-only
                       users to move the mouse.  This option is ignored when
                       a global -viewonly is in effect (all input is discarded
                       in that case).

-grabkbd               When VNC viewers are connected, attempt to the grab the
                       keyboard so someone sitting at the physical display
                       is not able to enter keystrokes.  This method uses
                       XGrabKeyboard(3X11) and so it is not secure and does not
                       rule out the person at the physical display injecting
                       keystrokes by flooding the server with them, grabbing
                       the keyboard himself, etc.  Some degree of cooperation
                       from the person at the display is assumed.
-grabptr               As -grabkbd, but for the mouse pointer using
                       XGrabPointer(3X11).  Unfortunately due to the way the X
                       server works, the mouse can still be moved around by the
                       user at the physical display, but he will not be able to
                       change window focus with it.  Also some window managers
                       that call XGrabServer(3X11) for resizes, etc, will
                       act on the local user's input.  Again, some degree of
                       cooperation from the person at the display is assumed.

-viewpasswd string     Supply a 2nd password for view-only logins.  The -passwd
                       (full-access) password must also be supplied.

-passwdfile filename   Specify the libvncserver password via the first line
                       of the file "filename" (instead of via -passwd on
                       the command line where others might see it via ps(1)).
                       See below for how to supply multiple passwords.

                       If the filename is prefixed with "rm:" it will be
                       removed after being read.  Perhaps this is useful in
                       limiting the readability of the file.  In general,
                       the password file should not be readable by untrusted
                       users (BTW: neither should the VNC -rfbauth file:
                       it is NOT encrypted).

                       If the filename is prefixed with "read:" it will
                       periodically be checked for changes and reread.

                       Note that only the first 8 characters of a password
                       are used.

                       If multiple non-blank lines exist in the file they are
                       all taken as valid passwords.  Blank lines are ignored.
                       Password lines may be "commented out" (ignored) if
                       they begin with the charactor "#" or the line contains
                       the string "__SKIP__".  Lines may be annotated by use
                       of the "__COMM__" string: from it to the end of the
                       line is ignored.  An empty password may be specified
                       via the "__EMPTY__" string on a line by itself (note
                       your viewer might not accept empty passwords).

                       If the string "__BEGIN_VIEWONLY__" appears on a
                       line by itself, the remaining passwords are used for
                       viewonly access.  For compatibility, as a special case
                       if the file contains only two password lines the 2nd
                       one is automatically taken as the viewonly password.
                       Otherwise the "__BEGIN_VIEWONLY__" token must be
                       used to have viewonly passwords.  (tip: make the 3rd
                       and last line be "__BEGIN_VIEWONLY__" to have 2
                       full-access passwords)

-unixpw [list]         Use Unix username and password authentication.  x11vnc
                       uses the su(1) program to verify the user's password.
                       [list] is an optional comma separated list of allowed
                       Unix usernames.  See below for per-user options that
                       can be applied.

                       A familiar "login:" and "Password:" dialog is
                       presented to the user on a black screen inside the
                       vncviewer.  The connection is dropped if the user fails
                       to supply the correct password in 3 tries or does not
                       send one before a 25 second timeout.  Existing clients
                       are view-only during this period.

                       Since the detailed behavior of su(1) can vary from
                       OS to OS and for local configurations, test the mode
                       carefully on your systems before using it in production.
                       Test different combinations of valid/invalid usernames
                       and valid/invalid passwords to see if it behaves as
                       expected.  x11vnc will attempt to be conservative and
                       reject a login if anything abnormal occurs.

                       On FreeBSD and the other BSD's by default it is
                       impossible for the user running x11vnc to validate
                       his *own* password via su(1) (evidently commenting out
                       the pam_self.so entry in /etc/pam.d/su eliminates this
                       problem).  So the x11vnc login will always *fail* for
                       this case (even when the correct password is supplied).

                       A possible workaround for this would be to start
                       x11vnc as root with the "-users +nobody" option to
                       immediately switch to user nobody.  Another source of
                       problems are PAM modules that prompt for extra info,
                       e.g. password aging modules.  These logins will fail
                       as well even when the correct password is supplied.

                       **IMPORTANT**: to prevent the Unix password being sent
                       in *clear text* over the network, one of two schemes
                       will be enforced: 1) the -ssl builtin SSL mode, or 2)
                       require both -localhost and -stunnel be enabled.

                       Method 1) ensures the traffic is encrypted between
                       viewer and server.  A PEM file will be required, see the
                       discussion under -ssl below (under some circumstances
                       a temporary one can be automatically generated).

                       Method 2) requires the viewer connection to appear
                       to come from the same machine x11vnc is running on
                       (e.g. from a ssh -L port redirection).  And that the
                       -stunnel SSL mode be used for encryption over the
                       network.(see the description of -stunnel below).

                       Note: as a convenience, if you ssh(1) in and start
                       x11vnc it will check if the environment variable
                       SSH_CONNECTION is set and appears reasonable.  If it
                       does, then the -ssl or -stunnel requirement will be
                       dropped since it is assumed you are using ssh for the
                       encrypted tunnelling.  -localhost is still enforced.
                       Use -ssl or -stunnel to force SSL usage even if
                       SSH_CONNECTION is set.

                       To override the above restrictions you can set
                       environment variables before starting x11vnc:

                       Set UNIXPW_DISABLE_SSL=1 to disable requiring either
                       -ssl or -stunnel.  Evidently you will be using a
                       different method to encrypt the data between the
                       vncviewer and x11vnc: perhaps ssh(1) or an IPSEC VPN.

                       Note that use of -localhost with ssh(1) is roughly
                       the same as requiring a Unix user login (since a Unix
                       password or the user's public key authentication is
                       used by sshd on the machine where x11vnc runs and only
                       local connections from that machine are accepted)

                       Set UNIXPW_DISABLE_LOCALHOST=1 to disable the -localhost
                       requirement in Method 2).  One should never do this
                       (i.e. allow the Unix passwords to be sniffed on the
                       network).

                       Regarding reverse connections (e.g. -R connect:host
                       and -connect host), when the -localhost constraint is
                       in effect then reverse connections can only be used
                       to connect to the same machine x11vnc is running on
                       (default port 5500).  Please use a ssh or stunnel port
                       redirection to the viewer machine to tunnel the reverse
                       connection over an encrypted channel. Note that in -ssl
                       mode reverse connection are disabled (see below).

                       In -inetd mode the Method 1) will be enforced (not
                       Method 2).  With -ssl in effect reverse connections
                       are disabled.  If you override this via env. var, be
                       sure to also use encryption from the viewer to inetd.
                       Tip: you can also have your own stunnel spawn x11vnc
                       in -inetd mode (thereby bypassing inetd).  See the FAQ
                       for details.

                       The user names in the comma separated [list] can have
                       per-user options after a ":", e.g. "fred:opts"
                       where "opts" is a "+" separated list of
                       "viewonly", "fullaccess", "input=XXXX", or
                       "deny", e.g. "karl,fred:viewonly,boss:input=M".
                       For "input=" it is the K,M,B,C described under -input.

                       If a user in the list is "*" that means those
                       options apply to all users.  It also means all users
                       are allowed to log in after supplying a valid password.
                       Use "deny" to explicitly deny some users if you use
                       "*" to set a global option.

                       There are also some utilities for testing password
                       if [list] starts with the "%" character.  See the
                       quick_pw() function in the source for details.

-unixpw_nis [list]     As -unixpw above, however do not use su(1) but rather
                       use the traditional getpwnam(3) + crypt(3) method to
                       verify passwords instead.  This requires that the
                       encrypted passwords be readable.  Passwords stored
                       in /etc/shadow will be inaccessible unless x11vnc
                       is run as root.

                       This is called "NIS" mode simply because in most
                       NIS setups the user encrypted passwords are accessible
                       (e.g. "ypcat passwd").  NIS is not required for this
                       mode to work (only that getpwnam(3) return the encrypted
                       password is required), but it is unlikely it will work
                       for any other modern environment.  All of the -unixpw
                       options and contraints apply.

-display_WAIT :...      A special usage mode for the normal -display option.
                       Useful with -unixpw, but can be used independently
                       of it.  If the display string begins with WAIT: then
                       x11vnc waits until a VNC client connects before opening
                       the X display (or -rawfb device).

                       This could be useful for delaying opening the display
                       for certain usage modes (say if x11vnc is started at
                       boot time and no X server is running or users logged
                       in yet).

                       If the string is, e.g. WAIT:0.0 or WAIT:1, i.e. "WAIT"
                       in front of a normal X display, then that indicated
                       display is used.  A more interesting case is like this:

                            WAIT:cmd=/usr/local/bin/find_display

                       in which case the command after "cmd=" is run to
                       dynamically work out the DISPLAY and optionally the
                       XAUTHORITY data.  The first line of the command output
                       must be of the form DISPLAY=<xdisplay>.  Any remaining
                       output is taken as XAUTHORITY data.  It can be either
                       of the form XAUTHORITY=<file> or raw xauthority data for
                       the display (e.g. "xauth extract - $DISPLAY" output).

                       In the case of -unixpw, then the above command is run
                       as the user who just authenticated via the login and
                       password prompt.

                       Also in the case of -unixpw, the user logging in can
                       place a colon at the end of his username and supply
                       a few options: scale=, scale_cursor=, solid, id=,
                       clear_mods, clear_keys, repeat, or speeds= separated
                       by commas if there is more than one.  After the user
                       logs in successfully, these options will be applied to
                       the VNC screen.  For example,

                          login: fred:scale=3/4,repeat
                          Password: ...

                       for convenience m/n implies scale= e.g. fred:3/4
                       To disable this set the environment variable
                       X11VNC_NO_UNIXPW_OPTS=1.  To set any other options,
                       the user can use the gui (x11vnc -gui connect) or the
                       remote control method (x11vnc -R opt:val) during his
                       VNC session.

                       So the combination of -display WAIT:cmd=... and
                       -unixpw allows automatic pairing of an unix
                       authenticated VNC user with his desktop.  This could
                       be very useful on SunRays and also any system where
                       multiple users share a given machine.  The user does
                       not need to remember special ports or passwords set up
                       for his desktop and VNC.

                       A nice way to use WAIT:cmd=... is out of inetd(8)
                       (it automatically forks a new x11vnc for each user).
                       You can have the x11vnc inetd spawned process run as,
                       say, root or nobody.  When run as root (for either
                       inetd or display manager), you can also supply the
                       option "-users unixpw=" to have the x11vnc process
                       switch to the user as well.  Note: there will be a 2nd
                       SSL helper process that will not switch, but it is only
                       encoding and decoding the stream at that point.

                       As a special case, WAIT:cmd=FINDDISPLAY will run
                       a script that works on most Unixes to determine a
                       user's DISPLAY variable and xauthority data.  To have
                       this default script printed to stdout (e.g. for
                       customization) run with WAIT:cmd=FINDDISPLAY-print

                       As another special case, WAIT:cmd=HTTPONCE will allow
                       x11vnc to service one http request and then exit.
                       This is usually done in -inetd mode to run on, say,
                       port 5800 and allow the Java vncviewer to be downloaded
                       by client web browsers.  For example:

                        5815 stream tcp nowait root /usr/sbin/tcpd .../x11vnc \
                          -inetd -q -http_ssl -display WAIT:cmd=HTTPONCE

                       It is used in the Apache SSL-portal example (see FAQ).

                       Finally, one can insert a geometry between colons,
                       e.g. WAIT:1280x1024:... to set the size of the display
                       the VNC client first attaches to since some VNC viewers
                       will not automatically adjust to a new framebuffer size.

-ssl [pem]             Use the openssl library (www.openssl.org) to provide a
                       built-in encrypted SSL tunnel between VNC viewers and
                       x11vnc.  This requires libssl support to be compiled
                       into x11vnc at build time.  If x11vnc is not built
                       with libssl support it will exit immediately when -ssl
                       is prescribed.

                       [pem] is optional, use "-ssl /path/to/mycert.pem"
                       to specify a PEM certificate file to use to identify
                       and provide a key for this server.  See openssl(1) for
                       more info about PEMs and the -sslGenCert option below.

                       The connecting VNC viewer SSL tunnel can optionally
                       authenticate this server if they have the public
                       key part of the certificate (or a common certificate
                       authority, CA, is a more sophisicated way to verify
                       this server's cert, see -sslGenCA below).  This is
                       used to prevent man-in-the-middle attacks.  Otherwise,
                       if the VNC viewer accepts this server's key without
                       verification, at least the traffic is protected
                       from passive sniffing on the network (but NOT from
                       man-in-the-middle attacks).

                       If [pem] is not supplied and the openssl(1) utility
                       command exists in PATH, then a temporary, self-signed
                       certificate will be generated for this session (this
                       may take 5-30 seconds on slow machines).  If openssl(1)
                       cannot be used to generate a temporary certificate
                       x11vnc exits immediately.

                       If successful in using openssl(1) to generate a
                       temporary certificate, the public part of it will be
                       displayed to stderr (e.g. one could copy it to the
                       client-side to provide authentication of the server to
                       VNC viewers.)  See following paragraphs for how to save
                       keys to reuse when x11vnc is restarted.

                       Set the env. var. X11VNC_SHOW_TMP_PEM=1 to have x11vnc
                       print out the entire certificate, including the PRIVATE
                       KEY part, to stderr.  One could reuse this cert if saved
                       in a [pem] file.  Similarly, set X11VNC_KEEP_TMP_PEM=1
                       to not delete the temporary PEM file: the file name
                       will be printed to stderr (so one could move it to
                       a safe place for reuse).  You will be prompted for a
                       passphrase for the private key.

                       If [pem] is "SAVE" then the certificate will be saved
                       to the file ~/.vnc/certs/server.pem, or if that file
                       exists it will be used directly.  Similarly, if [pem]
                       is "SAVE_PROMPT" the server.pem certificate will be
                       made based on your answers to its prompts for info such
                       as OrganizationalName, CommonName, etc.

                       Use "SAVE-<string>" and "SAVE_PROMPT-<string>"
                       to refer to the file ~/.vnc/certs/server-<string>.pem
                       instead.  E.g. "SAVE-charlie" will store to the file
                       ~/.vnc/certs/server-charlie.pem

                       See -ssldir below to use a directory besides the
                       default ~/.vnc/certs

                       Example: x11vnc -ssl SAVE -display :0 ...

                       Reverse connections are disabled in -ssl mode because
                       there is no way to ensure that data channel will
                       be encrypted.  Set X11VNC_SSL_ALLOW_REVERSE=1 to
                       override this.

                       Your VNC viewer will also need to be able to connect
                       via SSL.  See the discussion below under -stunnel and
                       the FAQ (ssl_vncviewer script) for how this might be
                       achieved.  E.g. on Unix it is easy to write a shell
                       script that starts up stunnel and then vncviewer.
                       Also in the x11vnc source a SSL enabled Java VNC Viewer
                       applet is provided in the classes/ssl directory.

-ssldir [dir]          Use [dir] as an alternate ssl certificate and key
                       management toplevel directory.  The default is
                       ~/.vnc/certs

                       This directory is used to store server and other
                       certificates and keys and also other materials.  E.g. in
                       the simplest case, "-ssl SAVE" will store the x11vnc
                       server cert in [dir]/server.pem

                       Use of alternate directories via -ssldir allows you to
                       manage multiple VNC Certificate Authority (CA) keys.
                       Another use is if ~/.vnc/cert is on an NFS share you
                       might want your certificates and keys to be on a local
                       filesystem to prevent network snooping (for example
                       -ssldir /var/lib/x11vnc-certs).

                       -ssldir affects nearly all of the other -ssl* options,
                       e.g. -ssl SAVE, -sslGenCert, etc..

-sslverify [path]      For either of the -ssl or -stunnel modes, use [path]
                       to provide certificates to authenticate incoming VNC
                       *Client* connections (normally only the server is
                       authenticated in SSL.)  This can be used as a method
                       to replace standard password authentication of clients.

                       If [path] is a directory it contains the client (or CA)
                       certificates in separate files.  If [path] is a file,
                       it contains multiple certificates.  See special tokens
                       below.  These correspond to the "CApath = dir" and
                       "CAfile = file" stunnel options.  See the stunnel(8)
                       manpage for details.

                       Examples:
                              x11vnc -ssl -sslverify ~/my.pem
                              x11vnc -ssl -sslverify ~/my_pem_dir/

                       Note that if [path] is a directory, it must contain
                       the certs in separate files named like <HASH>.0, where
                       the value of <HASH> is found by running the command
                       "openssl x509 -hash -noout -in file.crt". Evidently
                       one uses <HASH>.1 if there is a collision...

                       The the key-management utility "-sslCertInfo HASHON"
                       and "-sslCertInfo HASHOFF" will create/delete these
                       hashes for you automatically (via symlink) in the HASH
                       subdirs it manages.  Then you can point -sslverify to
                       the HASH subdir.

                       Special tokens: in -ssl mode, if [path] is not a file or
                       a directory, it is taken as a comma separated list of
                       tokens that are interpreted as follows:

                       If a token is "CA" that means load the CA/cacert.pem
                       file from the ssl directory.  If a token is "clients"
                       then all the files clients/*.crt in the ssl directory
                       are loaded.  Otherwise the file clients/token.crt
                       is attempted to be loaded.  As a kludge, use a token
                       like ../server-foo to load a server cert if you find
                       that necessary.

                       Use -ssldir to use a directory different from the
                       ~/.vnc/certs default.

                       Note that if the "CA" cert is loaded you do not need
                       to load any of the certs that have been signed by it.
                       You will need to load any additional self-signed certs
                       however.

                       Examples:
                              x11vnc -ssl -sslverify CA
                              x11vnc -ssl -sslverify self:fred,self:jim
                              x11vnc -ssl -sslverify CA,clients

                       Usually "-sslverify CA" is the most effective.
                       See the -sslGenCA and -sslGenCert options below for
                       how to set up and manage the CA framework.



                       NOTE: the following utilities, -sslGenCA, -sslGenCert,
                       -sslEncKey, and -sslCertInfo are provided for
                       completeness, but for casual usage they are overkill.

                       They provide VNC Certificate Authority (CA) key creation
                       and server / client key generation and signing.  So they
                       provide a basic Public Key management framework for
                       VNC-ing with x11vnc. (note that they require openssl(1)
                       be installed on the system)

                       However, the simplest usage mode (where x11vnc
                       automatically generates its own, self-signed, temporary
                       key and the VNC viewers always accept it, e.g. accepting
                       via a dialog box) is probably safe enough for most
                       scenarios.  CA management is not needed.

                       To protect against Man-In-The-Middle attacks the
                       simplest mode can be improved by using "-ssl SAVE"
                       to have x11vnc create a longer term self-signed
                       certificate, and then (safely) copy the corresponding
                       public key cert to the desired client machines (care
                       must be taken the private key part is not stolen;
                       you will be prompted for a passphrase).

                       So keep in mind no CA key creation or management
                       (-sslGenCA and -sslGenCert) is needed for either of
                       the above two common usage modes.

                       One might want to use -sslGenCA and -sslGenCert
                       if you had a large number of VNC client and server
                       workstations.  That way the administrator could generate
                       a single CA key with -sslGenCA and distribute its
                       certificate part to all of the workstations.

                       Next, he could create signed VNC server keys
                       (-sslGenCert server ...) for each workstation or user
                       that then x11vnc would use to authenticate itself to
                       any VNC client that has the CA cert.

                       Optionally, the admin could also make it so the
                       VNC clients themselves are authenticated to x11vnc
                       (-sslGenCert client ...)  For this -sslverify would be
                       pointed to the CA cert (and/or self-signed certs).

                       x11vnc will be able to use all of these cert and
                       key files.  On the VNC client side, they will need to
                       be "imported" somehow.  Web browsers have "Manage
                       Certificates" actions as does the Java applet plugin
                       Control Panel.  stunnel can also use these files (see
                       the ssl_vncviewer example script in the FAQ.)

-sslGenCA [dir]        Generate your own Certificate Authority private key,
                       certificate, and other files in directory [dir].

                       If [dir] is not supplied, a -ssldir setting is used,
                       or otherwise ~/.vnc/certs is used.

                       This command also creates directories where server and
                       client certs and keys will be stored.  The openssl(1)
                       program must be installed on the system and available
                       in PATH.

                       After the CA files and directories are created the
                       command exits; the VNC server is not run.

                       You will be prompted for information to put into the CA
                       certificate.  The info does not have to be accurate just
                       as long as clients accept the cert for VNC connections.
                       You will also need to supply a passphrase of at least
                       4 characters for the CA private key.

                       Once you have generated the CA you can distribute
                       its certificate part, [dir]/CA/cacert.pem, to other
                       workstations where VNC viewers will be run.  One will
                       need to "import" this certicate in the applications,
                       e.g. Web browser, Java applet plugin, stunnel, etc.
                       Next, you can create and sign keys using the CA with
                       the -sslGenCert option below.

                       Examples:
                                x11vnc -sslGenCA
                                x11vnc -sslGenCA  ~/myCAdir
                                x11vnc -ssldir ~/myCAdir -sslGenCA

                       (the last two lines are equivalent)

-sslGenCert type name  Generate a VNC server or client certificate and private
                       key pair signed by the CA created previously with
                       -sslGenCA.  The openssl(1) program must be installed
                       on the system and available in PATH.

                       After the Certificate is generated the command exits;
                       the VNC server is not run.

                       The type of key to be generated is the string "type".
                       It is either "server" (i.e. for use by x11vnc) or
                       "client" (for a VNC viewer).  Note that typically
                       only "server" is used: the VNC clients authenticate
                       themselves by a non-public-key method (e.g. VNC or
                       unix password).  "type" is required.

                       An arbitrary default name you want to associate with
                       the key is supplied by the "name" string.  You can
                       change it at the various prompts when creating the key.
                       "name" is optional.

                       If name is left blank for clients keys then "nobody"
                       is used.  If left blank for server keys, then the
                       primary server key: "server.pem" is created (this
                       is the saved one referenced by "-ssl SAVE" when the
                       server is started)

                       If "name" begins with the string "self:" then
                       a self-signed certificate is created instead of one
                       signed by your CA key.

                       If "name" begins with the string "req:" then only a
                       key (.key) and a certificate signing *request* (.req)
                       are generated.  You can then send the .req file to
                       an external CA (even a professional one, e.g. Thawte)
                       and then combine the .key and the received cert into
                       the .pem file with the same basename.

                       The distinction between "server" and "client" is
                       simply the choice of output filenames and sub-directory.
                       This makes it so the -ssl SAVE-name option can easily
                       pick up the x11vnc PEM file this option generates.
                       And similarly makes it easy for the -sslverify option
                       to pick up your client certs.

                       There is nothing special about the filename or directory
                       location of either the "server" and "client" certs.
                       You can rename the files or move them to wherever
                       you like.

                       Precede this option with -ssldir [dir] to use a
                       directory other than the default ~/.vnc/certs You will
                       need to run -sslGenCA on that directory first before
                       doing any -sslGenCert key creation.

                       Note you cannot recreate a cert with exactly the same
                       distiguished name (DN) as an existing one.  To do so,
                       you will need to edit the [dir]/CA/index.txt file to
                       delete the line.

                       Similar to -sslGenCA, you will be prompted to fill
                       in some information that will be recorded in the
                       certificate when it is created.  Tip: if you know
                       the fully-quailified hostname other people will be
                       connecting to you can use that as the CommonName "CN"
                       to avoid some applications (e.g. web browsers and java
                       plugin) complaining it does not match the hostname.

                       You will also need to supply the CA private key
                       passphrase to unlock the private key created from
                       -sslGenCA.  This private key is used to sign the server
                       or client certicate.

                       The "server" certs can be used by x11vnc directly by
                       pointing to them via the -ssl [pem] option.  The default
                       file will be ~/.vnc/certs/server.pem.  This one would
                       be used by simply typing -ssl SAVE.  The pem file
                       contains both the certificate and the private key.
                       server.crt file contains the cert only.

                       The "client" cert + private key file will need
                       to be copied and imported into the VNC viewer
                       side applications (Web browser, Java plugin,
                       stunnel, etc.)  Once that is done you can delete the
                       "client" private key file on this machine since
                       it is only needed on the VNC viewer side.  The,
                       e.g. ~/.vnc/certs/clients/<name>.pem contains both
                       the cert and private key.  The <name>.crt contains the
                       certificate only.

                       NOTE: It is very important to know one should always
                       generate new keys with a passphrase.  Otherwise if an
                       untrusted user steals the key file he could use it to
                       masquerade as the x11vnc server (or VNC viewer client).
                       You will be prompted whether to encrypt the key with
                       a passphrase or not.  It is recommended that you do.
                       One inconvenience to a passphrase is that it must
                       be suppled every time x11vnc or the client app is
                       started up.

                       Examples:

                               x11vnc -sslGenCert server
                               x11vnc -ssl SAVE -display :0 ...

                       and then on viewer using ssl_vncviewer stunnel wrapper
                       (see the FAQ):
                               ssl_vncviewer -verify ./cacert.crt hostname:0

                       (this assumes the cacert.crt cert from -sslGenCA
                       was safely copied to the VNC viewer machine where
                       ssl_vncviewer is run)

                       Example using a name:

                               x11vnc -sslGenCert server charlie
                               x11vnc -ssl SAVE-charlie -display :0 ...

                       Example for a client certificate (rarely used):

                               x11vnc -sslGenCert client roger
                               scp ~/.vnc/certs/clients/roger.pem somehost:.
                               rm  ~/.vnc/certs/clients/roger.pem

                       x11vnc is then started with the the option -sslverify
                       ~/.vnc/certs/clients/roger.crt (or simply -sslverify
                       roger), and on the viewer user on somehost could do
                       for example:

                               ssl_vncviewer -mycert ./roger.pem hostname:0

-sslEncKey [pem]       Utility to encrypt an existing PEM file with a
                       passphrase you supply when prompted.  For that key to be
                       used (e.g. by x11vnc) the passphrase must be supplied
                       each time.

                       The "SAVE" notation described under -ssl applies as
                       well. (precede this option with -ssldir [dir] to refer
                       a directory besides the default ~/.vnc/certs)

                       The openssl(1) program must be installed on the system
                       and available in PATH.  After the Key file is encrypted
                       the command exits; the VNC server is not run.

                       Examples:
                               x11vnc -sslEncKey /path/to/foo.pem
                               x11vnc -sslEncKey SAVE
                               x11vnc -sslEncKey SAVE-charlie

-sslCertInfo [pem]     Prints out information about an existing PEM file.
                       In addition the public certificate is also printed.
                       The openssl(1) program must be in PATH. Basically the
                       command "openssl x509 -text" is run on the pem.

                       The "SAVE" notation described under -ssl applies
                       as well.

                       Using  "LIST" will give a list of all certs being
                       managed (in the ~/.vnc/certs dir, use -ssldir to refer
                       to another dir).  "ALL" will print out the info for
                       every managed key (this can be very long).  Giving a
                       client or server cert shortname will also try a lookup
                       (e.g. -sslCertInfo charlie).  Use "LISTL" or "LL"
                       for a long (ls -l style) listing.

                       Using "HASHON" will create subdirs [dir]/HASH and
                       [dir]/HASH with OpenSSL hash filenames (e.g. 0d5fbbf1.0)
                       symlinks pointing up to the corresponding *.crt file.
                       ([dir] is ~/.vnc/certs or one given by -ssldir.)
                       This is a useful way for other OpenSSL applications
                       (e.g. stunnel) to access all of the certs without
                       having to concatenate them.  x11vnc will not use them
                       unless you specifically reference them.  "HASHOFF"
                       removes these HASH subdirs.

                       The LIST, LISTL, LL, ALL, HASHON, HASHOFF words can
                       also be lowercase, e.g. "list".

-sslDelCert [pem]      Prompts you to delete all .crt .pem .key .req files
                       associated with [pem].  "SAVE" and lookups as in
                       -sslCertInfo apply as well.


-stunnel [pem]         Use the stunnel(8) (www.stunnel.org) to provide an
                       encrypted SSL tunnel between viewers and x11vnc.

                       This external tunnel method was implemented prior to the
                       integrated -ssl encryption described above.  It still
                       works well.  This requires stunnel to be installed
                       on the system and available via PATH (n.b. stunnel is
                       often installed in sbin directories).  Version 4.x of
                       stunnel is assumed (but see -stunnel3 below.)

                       [pem] is optional, use "-stunnel /path/to/stunnel.pem"
                       to specify a PEM certificate file to pass to stunnel.
                       Whether one is needed or not depends on your stunnel
                       configuration.  stunnel often generates one at install
                       time.  See the stunnel documentation for details.

                       stunnel is started up as a child process of x11vnc and
                       any SSL connections stunnel receives are decrypted and
                       sent to x11vnc over a local socket.  The strings
                       "The SSL VNC desktop is ..." and "SSLPORT=..."
                       are printed out at startup to indicate this.

                       The -localhost option is enforced by default
                       to avoid people routing around the SSL channel.
                       Set STUNNEL_DISABLE_LOCALHOST=1 before starting x11vnc
                       to disable the requirement.

                       Your VNC viewer will also need to be able to connect via
                       SSL.  Unfortunately not too many do this.  UltraVNC has
                       an encryption plugin but it does not seem to be SSL.

                       Also, in the x11vnc distribution, a patched TightVNC
                       Java applet is provided in classes/ssl that does SSL
                       connections (only).

                       It is also not too difficult to set up an stunnel or
                       other SSL tunnel on the viewer side.  A simple example
                       on Unix using stunnel 3.x is:

                         % stunnel -c -d localhost:5901 -r remotehost:5900
                         % vncviewer localhost:1

                       For Windows, stunnel has been ported to it and there
                       are probably other such tools available.  See the FAQ
                       for more examples.

-stunnel3  [pem]       Use version 3.x stunnel command line syntax instead of
                       version 4.x

-https [port]          Choose a separate HTTPS port (-ssl mode only).

                       In -ssl mode, it turns out you can use the
                       single VNC port (e.g. 5900) for both VNC and HTTPS
                       connections. (HTTPS is used to retrieve a SSL-aware
                       VncViewer.jar applet that is provided with x11vnc).
                       Since both use SSL the implementation was extended to
                       detect if HTTP traffic (i.e. GET) is taking place and
                       handle it accordingly.  The URL would be, e.g.:

                       https://mymachine.org:5900/

                       This is convenient for firewalls, etc, because only one
                       port needs to be allowed in.  However, this heuristic
                       adds a few seconds delay to each connection and can be
                       unreliable (especially if the user takes much time to
                       ponder the Certificate dialogs in his browser, Java VM,
                       or VNC Viewer applet.  That's right 3 separate "Are
                       you sure you want to connect" dialogs!)

                       So use the -https option to provide a separate, more
                       reliable HTTPS port that x11vnc will listen on.  If
                       [port] is not provided (or is 0), one is autoselected.
                       The URL to use is printed out at startup.

                       The SSL Java applet directory is specified via the
                       -httpdir option.  If not supplied it will try to guess
                       the directory as though the -http option was supplied.

-usepw                 If no other password method was supplied on the command
                       line, first look for ~/.vnc/passwd and if found use it
                       with -rfbauth; next, look for ~/.vnc/passwdfile and
                       use it with -passwdfile; otherwise, prompt the user
                       for a password to create ~/.vnc/passwd and use it with
                       the -rfbauth option.  If none of these succeed x11vnc
                       exits immediately.

-storepasswd pass file Store password "pass" as the VNC password in the
                       file "file".  Once the password is stored the
                       program exits.  Use the password via "-rfbauth file"

                       If called with no arguments, "x11vnc -storepasswd",
                       the user is prompted for a password and it is stored
                       in the file ~/.vnc/passwd.  Called with one argument,
                       that will be the file to store the prompted password in.

-nopw                  Disable the big warning message when you use x11vnc
                       without some sort of password.

-accept string         Run a command (possibly to prompt the user at the
                       X11 display) to decide whether an incoming client
                       should be allowed to connect or not.  "string" is
                       an external command run via system(3) or some special
                       cases described below.  Be sure to quote "string"
                       if it contains spaces, shell characters, etc.  If the
                       external command returns 0 the client is accepted,
                       otherwise the client is rejected.  See below for an
                       extension to accept a client view-only.

                       If x11vnc is running as root (say from inetd(8) or from
                       display managers xdm(1), gdm(1), etc), think about the
                       security implications carefully before supplying this
                       option (likewise for the -gone option).

                       Environment: The RFB_CLIENT_IP environment variable will
                       be set to the incoming client IP number and the port
                       in RFB_CLIENT_PORT (or -1 if unavailable).  Similarly,
                       RFB_SERVER_IP and RFB_SERVER_PORT (the x11vnc side
                       of the connection), are set to allow identification
                       of the tcp virtual circuit.  The x11vnc process
                       id will be in RFB_X11VNC_PID, a client id number in
                       RFB_CLIENT_ID, and the number of other connected clients
                       in RFB_CLIENT_COUNT.  RFB_MODE will be "accept".
                       RFB_STATE will be PROTOCOL_VERSION, SECURITY_TYPE,
                       AUTHENTICATION, INITIALISATION, NORMAL, or UNKNOWN
                       indicating up to which state the client has acheived.
                       RFB_LOGIN_VIEWONLY will be 0, 1, or -1 (unknown).
                       RFB_USERNAME, RFB_LOGIN_TIME, and RFB_CURRENT_TIME may
                       also be set.

                       If "string" is "popup" then a builtin popup window
                       is used.  The popup will time out after 120 seconds,
                       use "popup:N" to modify the timeout to N seconds
                       (use 0 for no timeout).

                       In the case of "popup" and when the -unixpw option
                       is specified, then a *second* window will be popped
                       up after the user successfully logs in via his UNIX
                       password.  This time the user will be identified as
                       UNIX:username@localhost, the "UNIX:" prefix indicates
                       which user the viewer logged as via -unixpw.  The first
                       popup is only for whether to allow him to even *try*
                       to login via unix password.

                       If "string" is "xmessage" then an xmessage(1)
                       invocation is used for the command.  xmessage must be
                       installed on the machine for this to work.

                       Both "popup" and "xmessage" will present an option
                       for accepting the client "View-Only" (the client
                       can only watch).  This option will not be presented if
                       -viewonly has been specified, in which case the entire
                       display is view only.

                       If the user supplied command is prefixed with something
                       like "yes:0,no:*,view:3 mycommand ..." then this
                       associates the numerical command return code with
                       the actions: accept, reject, and accept-view-only,
                       respectively.  Use "*" instead of a number to indicate
                       the default action (in case the command returns an
                       unexpected value).  E.g. "no:*" is a good choice.

                       Note that x11vnc blocks while the external command
                       or popup is running (other clients may see no updates
                       during this period).  So a person sitting a the physical
                       display is needed to respond to an popup prompt. (use
                       a 2nd x11vnc if you lock yourself out).

                       More -accept tricks: use "popupmouse" to only allow
                       mouse clicks in the builtin popup to be recognized.
                       Similarly use "popupkey" to only recognize
                       keystroke responses.  These are to help avoid the
                       user accidentally accepting a client by typing or
                       clicking. All 3 of the popup keywords can be followed
                       by +N+M to supply a position for the popup window.
                       The default is to center the popup window.
-afteraccept string    As -accept, except to run a user supplied command after
                       a client has been accepted and authenticated. RFB_MODE
                       will be set to "afteraccept" and the other RFB_*
                       variables are as in -accept.  Unlike -accept, the
                       command return code is not interpreted by x11vnc.
                       Example: -afteraccept 'killall xlock &'
-gone string           As -accept, except to run a user supplied command when
                       a client goes away (disconnects).  RFB_MODE will be
                       set to "gone" and the other RFB_* variables are as
                       in -accept.  The "popup" actions apply as well.
                       Unlike -accept, the command return code is not
                       interpreted by x11vnc.  Example: -gone 'xlock &'

-users list            If x11vnc is started as root (say from inetd(8) or from
                       display managers xdm(1), gdm(1), etc), then as soon
                       as possible after connections to the X display are
                       established try to switch to one of the users in the
                       comma separated "list".  If x11vnc is not running as
                       root this option is ignored.

                       Why use this option?  In general it is not needed since
                       x11vnc is already connected to the X display and can
                       perform its primary functions.  The option was added
                       to make some of the *external* utility commands x11vnc
                       occasionally runs work properly.  In particular under
                       GNOME and KDE to implement the "-solid color" feature
                       external commands (gconftool-2 and dcop) unfortunately
                       must be run as the user owning the desktop session.
                       Since this option switches userid it also affects the
                       userid used to run the processes for the -accept and
                       -gone options.  It also affects the ability to read
                       files for options such as -connect, -allow, and -remap.
                       Note that the -connect file is also sometimes written
                       to.

                       So be careful with this option since in some situations
                       its use can decrease security.

                       In general the switch to a user will only take place
                       if the display can still be successfully opened as that
                       user (this is primarily to try to guess the actual owner
                       of the session). Example: "-users fred,wilma,betty".
                       Note that a malicious user "barney" by quickly using
                       "xhost +" when logging in may possibly get the x11vnc
                       process to switch to user "fred".  What happens next?

                       Under display managers it may be a long time before
                       the switch succeeds (i.e. a user logs in).  To instead
                       make it switch immediately regardless if the display
                       can be reopened prefix the username with the "+"
                       character. E.g. "-users +bob" or "-users +nobody".

                       The latter (i.e. switching immediately to user
                       "nobody") is probably the only use of this option
                       that increases security.

                       In -unixpw mode, if "-users unixpw=" is supplied
                       then after a user authenticates himself via the
                       -unixpw mechanism, x11vnc will try to switch to that
                       user as though "-users +username" had been supplied.
                       If you want to limit which users this will be done for,
                       provide them as a comma separated list after "unixpw="

                       To immediately switch to a user *before* connections
                       to the X display are made or any files opened use the
                       "=" character: "-users =bob".  That user needs to
                       be able to open the X display and any files of course.

                       The special user "guess=" means to examine the utmpx
                       database (see who(1)) looking for a user attached to
                       the display number (from DISPLAY or -display option)
                       and try him/her.  To limit the list of guesses, use:
                       "-users guess=bob,betty".

                       Even more sinister is the special user "lurk="
                       that means to try to guess the DISPLAY from the utmpx
                       login database as well.  So it "lurks" waiting for
                       anyone to log into an X session and then connects to it.
                       Specify a list of users after the = to limit which users
                       will be tried.  To enable a different searching mode, if
                       the first user in the list is something like ":0" or
                       ":0-2" that indicates a range of DISPLAY numbers that
                       will be tried (regardless of whether they are in the
                       utmpx database) for all users that are logged in.  Also
                       see the "-display WAIT:..." functionality.  Examples:
                       "-users lurk=" and also "-users lurk=:0-1,bob,mary"

                       Be especially careful using the "guess=" and "lurk="
                       modes.  They are not recommended for use on machines
                       with untrustworthy local users.

-noshm                 Do not use the MIT-SHM extension for the polling.
                       Remote displays can be polled this way: be careful this
                       can use large amounts of network bandwidth.  This is
                       also of use if the local machine has a limited number
                       of shm segments and -onetile is not sufficient.
-flipbyteorder         Sometimes needed if remotely polled host has different
                       endianness.  Ignored unless -noshm is set.
-onetile               Do not use the new copy_tiles() framebuffer mechanism,
                       just use 1 shm tile for polling.  Limits shm segments
                       used to 3.

-solid [color]         To improve performance, when VNC clients are connected
                       try to change the desktop background to a solid color.
                       The [color] is optional: the default color is "cyan4".
                       For a different one specify the X color (rgb.txt name,
                       e.g. "darkblue" or numerical "#RRGGBB").

                       Currently this option only works on GNOME, KDE, CDE,
                       and classic X (i.e. with the background image on the
                       root window).  The "gconftool-2" and "dcop" external
                       commands are run for GNOME and KDE respectively.
                       Other desktops won't work, e.g. Xfce (send us the
                       corresponding commands if you find them).  If x11vnc is
                       running as root (inetd(8) or gdm(1)), the -users option
                       may be needed for GNOME and KDE.  If x11vnc guesses
                       your desktop incorrectly, you can force it by prefixing
                       color with "gnome:", "kde:", "cde:" or "root:".
-blackout string       Black out rectangles on the screen. "string" is a
                       comma separated list of WxH+X+Y type geometries for
                       each rectangle.  If one of the items on the list is the
                       string "noptr" the mouse pointer will not be allowed
                       to go into a blacked out region.
-xinerama              If your screen is composed of multiple monitors
-noxinerama            glued together via XINERAMA, and that screen is
                       not a rectangle this option will try to guess the
                       areas to black out (if your system has libXinerama).
                       default: -xinerama

                       In general, we have noticed on XINERAMA displays you
                       may need to use the "-xwarppointer" option if the mouse
                       pointer misbehaves.

-xtrap                 Use the DEC-XTRAP extension for keystroke and mouse
                       input insertion.  For use on legacy systems, e.g. X11R5,
                       running an incomplete or missing XTEST extension.
                       By default DEC-XTRAP will be used if XTEST server grab
                       control is missing, use -xtrap to do the keystroke and
                       mouse insertion via DEC-XTRAP as well.

-xrandr [mode]         If the display supports the XRANDR (X Resize, Rotate
                       and Reflection) extension, and you expect XRANDR events
                       to occur to the display while x11vnc is running, this
                       options indicates x11vnc should try to respond to
                       them (as opposed to simply crashing by assuming the
                       old screen size).  See the xrandr(1) manpage and run
                       'xrandr -q' for more info.  [mode] is optional and
                       described below.

                       Since watching for XRANDR events and trapping errors
                       increases polling overhead, only use this option if
                       XRANDR changes are expected.  For example on a rotatable
                       screen PDA or laptop, or using a XRANDR-aware Desktop
                       where you resize often.  It is best to be viewing with a
                       vncviewer that supports the NewFBSize encoding, since it
                       knows how to react to screen size changes.  Otherwise,
                       libvncserver tries to do so something reasonable for
                       viewers that cannot do this (portions of the screen
                       may be clipped, unused, etc).

                       "mode" defaults to "resize", which means create a
                       new, resized, framebuffer and hope all viewers can cope
                       with the change.  "newfbsize" means first disconnect
                       all viewers that do not support the NewFBSize VNC
                       encoding, and then resize the framebuffer.  "exit"
                       means disconnect all viewer clients, and then terminate
                       x11vnc.
-padgeom WxH           Whenever a new vncviewer connects, the framebuffer is
                       replaced with a fake, solid black one of geometry WxH.
                       Shortly afterwards the framebuffer is replaced with the
                       real one.  This is intended for use with vncviewers
                       that do not support NewFBSize and one wants to make
                       sure the initial viewer geometry will be big enough
                       to handle all subsequent resizes (e.g. under -xrandr,
                       -remote id:windowid, rescaling, etc.)

-o logfile             Write stderr messages to file "logfile" instead of
                       to the terminal.  Same as "-logfile file".  To append
                       to the file use "-oa file" or "-logappend file".
-flag file             Write the "PORT=NNNN" (e.g. PORT=5900) string to
                       "file" in addition to stdout.  This option could be
                       useful by wrapper script to detect when x11vnc is ready.

-rc filename           Use "filename" instead of $HOME/.x11vncrc for rc file.
-norc                  Do not process any .x11vncrc file for options.

-env VAR=VALUE         Set the environment variable 'VAR' to value 'VALUE'
                       at x11vnc startup.  This is a convenience utility to
                       avoid shell script wrappers, etc. to set the env. var.
                       You may specify as many of these as needed on the
                       command line.

-h, -help              Print this help text.
-?, -opts              Only list the x11vnc options.
-V, -version           Print program version and last modification date.

-dbg                   Instead of exiting after cleaning up, run a simple
                       "debug crash shell" when fatal errors are trapped.

-q                     Be quiet by printing less informational output to
                       stderr.  Same as -quiet.
-bg                    Go into the background after screen setup.  Messages to
                       stderr are lost unless -o logfile is used.  Something
                       like this could be useful in a script:
                         port=`ssh $host "x11vnc -display :0 -bg" | grep PORT`
                         port=`echo "$port" | sed -e 's/PORT=//'`
                         port=`expr $port - 5900`
                         vncviewer $host:$port

-modtweak              Option -modtweak automatically tries to adjust the AltGr
-nomodtweak            and Shift modifiers for differing language keyboards
                       between client and host.  Otherwise, only a single key
                       press/release of a Keycode is simulated (i.e. ignoring
                       the state of the modifiers: this usually works for
                       identical keyboards).  Also useful in resolving cases
                       where a Keysym is bound to multiple keys (e.g. "<" + ">"
                       and "," + "<" keys).  Default: -modtweak
-xkb                   When in modtweak mode, use the XKEYBOARD extension (if
-noxkb                 the X display supports it) to do the modifier tweaking.
                       This is powerful and should be tried if there are still
                       keymapping problems when using -modtweak by itself.
                       The default is to check whether some common keysyms,
                       e.g. !, @, [, are only accessible via -xkb mode and if
                       so then automatically enable the mode.  To disable this
                       automatic detection use -noxkb.

-capslock              When in -modtweak (the default) or -xkb mode,
                       if a keysym in the range A-Z comes in check the X
                       server to see if the Caps_Lock is set.  If it is do
                       not artificially press Shift to generate the keysym.
                       This will enable the CapsLock key to behave correctly
                       in some circumstances: namely *both* the VNC viewer
                       machine and the x11vnc X server are in the CapsLock
                       on state.  If one side has CapsLock on and the other
                       off and the keyboard is not behaving as you think it
                       should you should correct the CapsLock states (hint:
                       pressing CapsLock inside and outside of the viewer can
                       help toggle them both to the correct state).  However,
                       for best results do not use this option, but rather
                       *only* enable CapsLock on the VNC viewer side (i.e. by
                       pressing CapsLock outside of the viewer window, also
                       -skip_lockkeys below).  Also try -nomodtweak for a
                       possible workaround.

-skip_lockkeys         Have x11vnc ignore all Caps_Lock, Shift_Lock, Num_Lock,
                       Scroll_Lock keysyms received from viewers.  The idea is
                       you press Caps_Lock on the VNC Viewer side but that does
                       not change the lock state in the x11vnc-side X server.
                       Nevertheless your capitalized letters come in over
                       the wire and are applied correctly to the x11vnc-side
                       X server.  Note this mode probably won't do what you
                       want in -nomodtweak mode.  Also, a kludge for KP_n
                       digits is always done it this mode: they are mapped to
                       regular digit keysyms.  See also -capslock above.

-skip_keycodes string  Ignore the comma separated list of decimal keycodes.
                       Perhaps these are keycodes not on your keyboard but
                       your X server thinks exist.  Currently only applies
                       to -xkb mode.  Use this option to help x11vnc in the
                       reverse problem it tries to solve: Keysym -> Keycode(s)
                       when ambiguities exist (more than one Keycode per
                       Keysym).  Run 'xmodmap -pk' to see your keymapping.
                       Example: "-skip_keycodes 94,114"
-sloppy_keys           Experimental option that tries to correct some
                       "sloppy" key behavior.  E.g. if at the viewer you
                       press Shift+Key but then release the Shift before
                       Key that could give rise to extra unwanted characters
                       (usually only between keyboards of different languages).
                       Only use this option if you observe problems with
                       some keystrokes.
-skip_dups             Some VNC viewers send impossible repeated key events,
-noskip_dups           e.g. key-down, key-down, key-up, key-up all for the same
                       key, or 20 downs in a row for the same modifier key!
                       Setting -skip_dups means to skip these duplicates and
                       just process the first event. Note: some VNC viewers
                       assume they can send down's without the corresponding
                       up's and so you should not set this option for
                       these viewers (symptom: some keys do not autorepeat)
                       Default: -noskip_dups
-add_keysyms           If a Keysym is received from a VNC viewer and that
-noadd_keysyms         Keysym does not exist in the X server, then add the
                       Keysym to the X server's keyboard mapping on an unused
                       key.  Added Keysyms will be removed periodically and
                       also when x11vnc exits.  Default: -add_keysyms
-clear_mods            At startup and exit clear the modifier keys by sending
                       KeyRelease for each one. The Lock modifiers are skipped.
                       Used to clear the state if the display was accidentally
                       left with any pressed down.
-clear_keys            As -clear_mods, except try to release any pressed key.
                       Note that this option and -clear_mods can interfere
                       with a person typing at the physical keyboard.
-remap string          Read Keysym remappings from file named "string".
                       Format is one pair of Keysyms per line (can be name
                       or hex value) separated by a space.  If no file named
                       "string" exists, it is instead interpreted as this
                       form: key1-key2,key3-key4,...  See <X11/keysymdef.h>
                       header file for a list of Keysym names, or use xev(1).
                       To map a key to a button click, use the fake Keysyms
                       "Button1", ..., etc. E.g: "-remap Super_R-Button2"
                       (useful for pasting on a laptop)

                       To disable a keysym (i.e. make it so it will not be
                       injected), remap it to "NoSymbol" or "None".

                       Dead keys: "dead" (or silent, mute) keys are keys that
                       do not produce a character but must be followed by a 2nd
                       keystroke.  This is often used for accenting characters,
                       e.g. to put "`" on top of "a" by pressing the dead
                       key and then "a".  Note that this interpretation
                       is not part of core X11, it is up to the toolkit or
                       application to decide how to react to the sequence.
                       The X11 names for these keysyms are "dead_grave",
                       "dead_acute", etc.  However some VNC viewers send the
                       keysyms "grave", "acute" instead thereby disabling
                       the accenting.  To work around this -remap can be used.
                       For example "-remap grave-dead_grave,acute-dead_acute"
                       As a convenience, "-remap DEAD" applies these remaps:

                               g     grave-dead_grave
                               a     acute-dead_acute
                               c     asciicircum-dead_circumflex
                               t     asciitilde-dead_tilde
                               m     macron-dead_macron
                               b     breve-dead_breve
                               D     abovedot-dead_abovedot
                               d     diaeresis-dead_diaeresis
                               o     degree-dead_abovering
                               A     doubleacute-dead_doubleacute
                               r     caron-dead_caron
                               e     cedilla-dead_cedilla

                       If you just want a subset use the first letter
                       label, e.g. "-remap DEAD=ga" to get the first two.
                       Additional remaps may also be supplied via commas,
                       e.g.  "-remap DEAD=ga,Super_R-Button2".  Finally,
                       "DEAD=missing" means to apply all of the above as
                       long as the left hand member is not already in the
                       X11 keymap.

-norepeat              Option -norepeat disables X server key auto repeat when
-repeat                VNC clients are connected and VNC keyboard input is
                       not idle for more than 5 minutes.  This works around a
                       repeating keystrokes bug (triggered by long processing
                       delays between key down and key up client events: either
                       from large screen changes or high latency).
                       Default: -norepeat

                       Note: your VNC viewer side will likely do autorepeating,
                       so this is no loss unless someone is simultaneously at
                       the real X display.

                       Use "-norepeat N" to set how many times norepeat will
                       be reset if something else (e.g. X session manager)
                       undoes it.  The default is 2.  Use a negative value
                       for unlimited resets.

-nofb                  Ignore video framebuffer: only process keyboard and
                       pointer.  Intended for use with Win2VNC and x2vnc
                       dual-monitor setups.
-nobell                Do not watch for XBell events. (no beeps will be heard)
                       Note: XBell monitoring requires the XKEYBOARD extension.
-nosel                 Do not manage exchange of X selection/cutbuffer between
                       VNC viewers and the X server at all.
-noprimary             Do not poll the PRIMARY selection for changes to send
                       back to clients.  (PRIMARY is still set on received
                       changes, however).
-nosetprimary          Do not set the PRIMARY selection for changes received
                       from VNC clients.
-noclipboard           Do not poll the CLIPBOARD selection for changes to send
                       back to clients.  (CLIPBOARD is still set on received
                       changes, however).
-nosetclipboard        Do not set the CLIPBOARD selection for changes
                       received from VNC clients.
-seldir string         If direction string is "send", only send the selection
                       to viewers, and if it is "recv" only receive it from
                       viewers.  To work around apps setting the selection
                       too frequently and messing up the other end.  You can
                       actually supply a comma separated list of directions,
                       including "debug" to turn on debugging output.

-cursor [mode]         Sets how the pointer cursor shape (little icon at the
-nocursor              mouse pointer) should be handled.  The "mode" string
                       is optional and is described below.  The default
                       is to show some sort of cursor shape(s).  How this
                       is done depends on the VNC viewer and the X server.
                       Use -nocursor to disable cursor shapes completely.

                       Some VNC viewers support the TightVNC CursorPosUpdates
                       and CursorShapeUpdates extensions (cuts down on
                       network traffic by not having to send the cursor image
                       every time the pointer is moved), in which case these
                       extensions are used (see -nocursorshape and -nocursorpos
                       below to disable).  For other viewers the cursor shape
                       is written directly to the framebuffer every time the
                       pointer is moved or changed and gets sent along with
                       the other framebuffer updates.  In this case, there
                       will be some lag between the vnc viewer pointer and
                       the remote cursor position.

                       If the X display supports retrieving the cursor shape
                       information from the X server, then the default is
                       to use that mode.  On Solaris this can be done with
                       the SUN_OVL extension using -overlay (see also the
                       -overlay_nocursor option).  A similar overlay scheme
                       is used on IRIX.  Xorg (e.g. Linux) and recent Solaris
                       Xsun servers support the XFIXES extension to retrieve
                       the exact cursor shape from the X server.  If XFIXES
                       is present it is preferred over Overlay and is used by
                       default (see -noxfixes below).  This can be disabled
                       with -nocursor, and also some values of the "mode"
                       option below.

                       Note that under XFIXES cursors with transparency (alpha
                       channel) will usually not be exactly represented and one
                       may find Overlay preferable.  See also the -alphacut
                       and -alphafrac options below as fudge factors to try
                       to improve the situation for cursors with transparency
                       for a given theme.

                       The "mode" string can be used to fine-tune the
                       displaying of cursor shapes.  It can be used the
                       following ways:

                       "-cursor arrow" - just show the standard arrow
                       nothing more or nothing less.

                       "-cursor none" - same as "-nocursor"

                       "-cursor X" - when the cursor appears to be on the
                       root window, draw the familiar X shape.  Some desktops
                       such as GNOME cover up the root window completely,
                       and so this will not work, try "X1", etc, to try to
                       shift the tree depth.  On high latency links or slow
                       machines there will be a time lag between expected and
                       the actual cursor shape.

                       "-cursor some" - like "X" but use additional
                       heuristics to try to guess if the window should have
                       a windowmanager-like resizer cursor or a text input
                       I-beam cursor.  This is a complete hack, but may be
                       useful in some situations because it provides a little
                       more feedback about the cursor shape.

                       "-cursor most" - try to show as many cursors as
                       possible.  Often this will only be the same as "some"
                       unless the display has overlay visuals or XFIXES
                       extensions available.  On Solaris and IRIX if XFIXES
                       is not available, -overlay mode will be attempted.

-arrow n               Choose an alternate "arrow" cursor from a set of
                       some common ones.  n can be 1 to 6.  Default is: 1
                       Ignored when in XFIXES cursor-grabbing mode.

-noxfixes              Do not use the XFIXES extension to draw the exact cursor
                       shape even if it is available.
-alphacut n            When using the XFIXES extension for the cursor shape,
                       cursors with transparency will not usually be displayed
                       exactly (but opaque ones will).  This option sets n as
                       a cutoff for cursors that have transparency ("alpha
                       channel" with values ranging from 0 to 255) Any cursor
                       pixel with alpha value less than n becomes completely
                       transparent.  Otherwise the pixel is completely opaque.
                       Default 240

-alphafrac fraction    With the threshold in -alphacut some cursors will become
                       almost completely transparent because their alpha values
                       are not high enough.  For those cursors adjust the
                       alpha threshold until fraction of the non-zero alpha
                       channel pixels become opaque.  Default 0.33
-alpharemove           By default, XFIXES cursors pixels with transparency have
                       the alpha factor multiplied into the RGB color values
                       (i.e. that corresponding to blending the cursor with a
                       black background).  Specify this option to remove the
                       alpha factor. (useful for light colored semi-transparent
                       cursors).
-noalphablend          In XFIXES mode do not send cursor alpha channel data
                       to libvncserver.  The default is to send it.  The
                       alphablend effect will only be visible in -nocursorshape
                       mode or for clients with cursorshapeupdates turned
                       off. (However there is a hack for 32bpp with depth 24,
                       it uses the extra 8 bits to store cursor transparency
                       for use with a hacked vncviewer that applies the
                       transparency locally.  See the FAQ for more info).

-nocursorshape         Do not use the TightVNC CursorShapeUpdates extension
                       even if clients support it.  See -cursor above.
-cursorpos             Option -cursorpos enables sending the X cursor position
-nocursorpos           back to all vnc clients that support the TightVNC
                       CursorPosUpdates extension.  Other clients will be able
                       to see the pointer motions. Default: -cursorpos
-xwarppointer          Move the pointer with XWarpPointer(3X) instead of
                       the XTEST extension.  Use this as a workaround
                       if the pointer motion behaves incorrectly, e.g.
                       on touchscreens or other non-standard setups.
                       Also sometimes needed on XINERAMA displays.

-buttonmap string      String to remap mouse buttons.  Format: IJK-LMN, this
                       maps buttons I -> L, etc., e.g.  -buttonmap 13-31

                       Button presses can also be mapped to keystrokes: replace
                       a button digit on the right of the dash with :<sym>:
                       or :<sym1>+<sym2>: etc. for multiple keys. For example,
                       if the viewing machine has a mouse-wheel (buttons 4 5)
                       but the x11vnc side does not, these will do scrolls:
                              -buttonmap 12345-123:Prior::Next:
                              -buttonmap 12345-123:Up+Up+Up::Down+Down+Down:

                       See <X11/keysymdef.h> header file for a list of Keysyms,
                       or use the xev(1) program.  Note: mapping of button
                       clicks to Keysyms may not work if -modtweak or -xkb is
                       needed for the Keysym.

                       If you include a modifier like "Shift_L" the
                       modifier's up/down state is toggled, e.g. to send
                       "The" use :Shift_L+t+Shift_L+h+e: (the 1st one is
                       shift down and the 2nd one is shift up). (note: the
                       initial state of the modifier is ignored and not reset)
                       To include button events use "Button1", ... etc.

-nodragging            Do not update the display during mouse dragging events
                       (mouse button held down).  Greatly improves response on
                       slow setups, but you lose all visual feedback for drags,
                       text selection, and some menu traversals.  It overrides
                       any -pointer_mode setting.

-wireframe [str]       Try to detect window moves or resizes when a mouse
-nowireframe           button is held down and show a wireframe instead of
                       the full opaque window.  This is based completely on
                       heuristics and may not always work: it depends on your
                       window manager and even how you move things around.
                       See -pointer_mode below for discussion of the "bogging
                       down" problem this tries to avoid.
                       Default: -wireframe

                       Shorter aliases:  -wf [str]  and -nowf

                       The value "str" is optional and, of course, is
                       packed with many tunable parameters for this scheme:

                       Format: shade,linewidth,percent,T+B+L+R,mod,t1+t2+t3+t4
                       Default: 0xff,3,0,32+8+8+8,all,0.15+0.30+5.0+0.125

                       If you leave nothing between commas: ",," the default
                       value is used.  If you don't specify enough commas,
                       the trailing parameters are set to their defaults.

                       "shade" indicate the "color" for the wireframe,
                       usually a greyscale: 0-255, however for 16 and 32bpp you
                       can specify an rgb.txt X color (e.g. "dodgerblue") or
                       a value > 255 is treated as RGB (e.g. red is 0xff0000).
                       "linewidth" sets the width of the wireframe in pixels.
                       "percent" indicates to not apply the wireframe scheme
                       to windows with area less than this percent of the
                       full screen.

                       "T+B+L+R" indicates four integers for how close in
                       pixels the pointer has to be from the Top, Bottom, Left,
                       or Right edges of the window to consider wireframing.
                       This is a speedup to quickly exclude a window from being
                       wireframed: set them all to zero to not try the speedup
                       (scrolling and selecting text will likely be slower).

                       "mod" specifies if a button down event in the
                       interior of the window with a modifier key (Alt, Shift,
                       etc.) down should indicate a wireframe opportunity.
                       It can be "0" or "none" to skip it, "1" or "all"
                       to apply it to any modifier, or "Shift", "Alt",
                       "Control", "Meta", "Super", or "Hyper" to only
                       apply for that type of modifier key.

                       "t1+t2+t3+t4" specify four floating point times in
                       seconds: t1 is how long to wait for the pointer to move,
                       t2 is how long to wait for the window to start moving
                       or being resized (for some window managers this can be
                       rather long), t3 is how long to keep a wireframe moving
                       before repainting the window. t4 is the minimum time
                       between sending wireframe "animations".  If a slow
                       link is detected, these values may be automatically
                       changed to something better for a slow link.

-wirecopyrect mode     Since the -wireframe mechanism evidently tracks moving
-nowirecopyrect        windows accurately, a speedup can be obtained by
                       telling the VNC viewers to locally copy the translated
                       window region.  This is the VNC CopyRect encoding:
                       the framebuffer update doesn't need to send the actual
                       new image data.

                       Shorter aliases:  -wcr [mode]  and -nowcr

                       "mode" can be "never" (same as -nowirecopyrect)
                       to never try the copyrect, "top" means only do it if
                       the window was not covered by any other windows, and
                       "always" means to translate the orginally unobscured
                       region (this may look odd as the remaining pieces come
                       in, but helps on a slow link).  Default: "always"

                       Note: there can be painting errors or slow response
                       when using -scale so you may want to disable CopyRect
                       in this case "-wirecopyrect never" on the command
                       line or by remote-control.  Or you can also use the
                       "-scale xxx:nocr" scale option.

-debug_wireframe       Turn on debugging info printout for the wireframe
                       heuristics.  "-dwf" is an alias.  Specify multiple
                       times for more output.

-scrollcopyrect mode   Like -wirecopyrect, but use heuristics to try to guess
-noscrollcopyrect      if a window has scrolled its contents (either vertically
                       or horizontally).  This requires the RECORD X extension
                       to "snoop" on X applications (currently for certain
                       XCopyArea and XConfigureWindow X protocol requests).
                       Examples: Hitting <Return> in a terminal window when the
                       cursor was at the bottom, the text scrolls up one line.
                       Hitting <Down> arrow in a web browser window, the web
                       page scrolls up a small amount.  Or scrolling with a
                       scrollbar or mouse wheel.

                       Shorter aliases:  -scr [mode]  and -noscr

                       This scheme will not always detect scrolls, but when
                       it does there is a nice speedup from using the VNC
                       CopyRect encoding (see -wirecopyrect).  The speedup
                       is both in reduced network traffic and reduced X
                       framebuffer polling/copying.  On the other hand, it may
                       induce undesired transients (e.g. a terminal cursor
                       being scrolled up when it should not be) or other
                       painting errors (window tearing, bunching-up, etc).
                       These are automatically repaired in a short period
                       of time.  If this is unacceptable disable the feature
                       with -noscrollcopyrect.

                       Screen clearing kludges:  for testing at least, there
                       are some "magic key sequences" (must be done in less
                       than 1 second) to aid repairing painting errors that
                       may be seen when using this mode:

                       3 Alt_L's   in a row: resend whole screen,
                       4 Alt_L's   in a row: reread and resend whole screen,
                       3 Super_L's in a row: mark whole screen for polling,
                       4 Super_L's in a row: reset RECORD context,
                       5 Super_L's in a row: try to push a black screen

                       note: Alt_L is the Left "Alt" key (a single key)
                       Super_L is the Left "Super" key (Windows flag).
                       Both of these are modifier keys, and so should not
                       generate characters when pressed by themselves.  Also,
                       your VNC viewer may have its own refresh hot-key
                       or button.

                       "mode" can be "never" (same as -noscrollcopyrect)
                       to never try the copyrect, "keys" means to try it
                       in response to keystrokes only, "mouse" means to
                       try it in response to mouse events only, "always"
                       means to do both. Default: "always"

                       Note: there can be painting errors or slow response
                       when using -scale so you may want to disable CopyRect
                       in this case "-scrollcopyrect never" on the command
                       line or by remote-control.  Or you can also use the
                       "-scale xxx:nocr" scale option.

-scr_area n            Set the minimum area in pixels for a rectangle
                       to be considered for the -scrollcopyrect detection
                       scheme.  This is to avoid wasting the effort on small
                       rectangles that would be quickly updated the normal way.
                       E.g. suppose an app updated the position of its skinny
                       scrollbar first and then shifted the large panel
                       it controlled.  We want to be sure to skip the small
                       scrollbar and get the large panel. Default: 60000

-scr_skip list         Skip scroll detection for applications matching
                       the comma separated list of strings in "list".
                       Some applications implement their scrolling in
                       strange ways where the XCopyArea, etc, also applies
                       to invisible portions of the window: if we CopyRect
                       those areas it looks awful during the scroll and
                       there may be painting errors left after the scroll.
                       Soffice.bin is the worst known offender.

                       Use "##" to denote the start of the application class
                       (e.g. "##XTerm") and "++" to denote the start
                       of the application instance name (e.g. "++xterm").
                       The string your list is matched against is of the form
                       "^^WM_NAME##Class++Instance<same-for-any-subwindows>"
                       The "xlsclients -la" command will provide this info.

                       If a pattern is prefixed with "KEY:" it only applies
                       to Keystroke generated scrolls (e.g. Up arrow).  If it
                       is prefixed with "MOUSE:" it only applies to Mouse
                       induced scrolls (e.g. dragging on a scrollbar).
                       Default: ##Soffice.bin,##StarOffice

-scr_inc list          Opposite of -scr_skip: this list is consulted first
                       and if there is a match the window will be monitored
                       via RECORD for scrolls irrespective of -scr_skip.
                       Use -scr_skip '*' to skip anything that does not match
                       your -scr_inc.  Use -scr_inc '*' to include everything.

-scr_keys list         For keystroke scroll detection, only apply the RECORD
                       heuristics to the comma separated list of keysyms in
                       "list".  You may find the RECORD overhead for every
                       one of your keystrokes disrupts typing too much, but you
                       don't want to turn it off completely with "-scr mouse"
                       and -scr_parms does not work or is too confusing.

                       The listed keysyms can be numeric or the keysym
                       names in the <X11/keysymdef.h> header file or from the
                       xev(1) program.  Example: "-scr_keys Up,Down,Return".
                       One probably wants to have application specific lists
                       (e.g. for terminals, etc) but that is too icky to think
                       about for now...

                       If "list" begins with the "-" character the list
                       is taken as an exclude list: all keysyms except those
                       list will be considered.  The special string "builtin"
                       expands to an internal list of keysyms that are likely
                       to cause scrolls.  BTW, by default modifier keys,
                       Shift_L, Control_R, etc, are skipped since they almost
                       never induce scrolling by themselves.

-scr_term list         Yet another cosmetic kludge.  Apply shell/terminal
                       heuristics to applications matching comma separated
                       list (same as for -scr_skip/-scr_inc).  For example an
                       annoying transient under scroll detection is if you
                       hit Enter in a terminal shell with full text window,
                       the solid text cursor block will be scrolled up.
                       So for a short time there are two (or more) block
                       cursors on the screen.  There are similar scenarios,
                       (e.g. an output line is duplicated).

                       These transients are induced by the approximation of
                       scroll detection (e.g. it detects the scroll, but not
                       the fact that the block cursor was cleared just before
                       the scroll).  In nearly all cases these transient errors
                       are repaired when the true X framebuffer is consulted
                       by the normal polling.  But they are distracting, so
                       what this option provides is extra "padding" near the
                       bottom of the terminal window: a few extra lines near
                       the bottom will not be scrolled, but rather updated
                       from the actual X framebuffer.  This usually reduces
                       the annoying artifacts.  Use "none" to disable.
                       Default: "term"

-scr_keyrepeat lo-hi   If a key is held down (or otherwise repeats rapidly) and
                       this induces a rapid sequence of scrolls (e.g. holding
                       down an Arrow key) the "scrollcopyrect" detection
                       and overhead may not be able to keep up.  A time per
                       single scroll estimate is performed and if that estimate
                       predicts a sustainable scrollrate of keys per second
                       between "lo" and "hi" then repeated keys will be
                       DISCARDED to maintain the scrollrate. For example your
                       key autorepeat may be 25 keys/sec, but for a large
                       window or slow link only 8 scrolls per second can be
                       sustained, then roughly 2 out of every 3 repeated keys
                       will be discarded during this period. Default: "4-20"

-scr_parms string      Set various parameters for the scrollcopyrect mode.
                       The format is similar to that for -wireframe and packed
                       with lots of parameters:

                       Format: T+B+L+R,t1+t2+t3,s1+s2+s3+s4+s5
                       Default: 0+64+32+32,0.02+0.10+0.9,0.03+0.06+0.5+0.1+5.0

                       If you leave nothing between commas: ",," the default
                       value is used.  If you don't specify enough commas,
                       the trailing parameters are set to their defaults.

                       "T+B+L+R" indicates four integers for how close in
                       pixels the pointer has to be from the Top, Bottom, Left,
                       or Right edges of the window to consider scrollcopyrect.
                       If -wireframe overlaps it takes precedence.  This is a
                       speedup to quickly exclude a window from being watched
                       for scrollcopyrect: set them all to zero to not try
                       the speedup (things like selecting text will likely
                       be slower).

                       "t1+t2+t3" specify three floating point times in
                       seconds that apply to scrollcopyrect detection with
                       *Keystroke* input: t1 is how long to wait after a key
                       is pressed for the first scroll, t2 is how long to keep
                       looking after a Keystroke scroll for more scrolls.
                       t3 is how frequently to try to update surrounding
                       scrollbars outside of the scrolling area (0.0 to
                       disable)

                       "s1+s2+s3+s4+s5" specify five floating point times
                       in seconds that apply to scrollcopyrect detection with
                       *Mouse* input: s1 is how long to wait after a mouse
                       button is pressed for the first scroll, s2 is how long
                       to keep waiting for additional scrolls after the first
                       Mouse scroll was detected.  s3 is how frequently to
                       try to update surrounding scrollbars outside of the
                       scrolling area (0.0 to disable).  s4 is how long to
                       buffer pointer motion (to try to get fewer, bigger
                       mouse scrolls). s5 is the maximum time to spend just
                       updating the scroll window without updating the rest
                       of the screen.

-fixscreen string      Periodically "repair" the screen based on settings
                       in "string".  Hopefully you won't need this option,
                       it is intended for cases when the -scrollcopyrect or
                       -wirecopyrect features leave too many painting errors,
                       but it can be used for any scenario.  This option
                       periodically performs costly operations and so
                       interactive response may be reduced when it is on.
                       You can use 3 Alt_L's (the Left "Alt" key) taps in
                       a row (as described under -scrollcopyrect) instead to
                       manually request a screen repaint when it is needed.

                       "string" is a comma separated list of one or more of
                       the following: "V=t", "C=t", "X=t", and "8=t".
                       In these "t" stands for a time in seconds (it is
                       a floating point even though one should usually use
                       values > 2 to avoid wasting resources).  V sets how
                       frequently the entire screen should be sent to viewers
                       (it is like the 3 Alt_L's).  C sets how long to wait
                       after a CopyRect to repaint the full screen.  X sets
                       how frequently to reread the full X11 framebuffer from
                       the X server and push it out to connected viewers.
                       Use of X should be rare, please report a bug if you
                       find you need it. 8= applies only for -8to24 mode: it
                       sets how often the non-default visual regions of the
                       screen (e.g. 8bpp windows) are refreshed.  Examples:
                       -fixscreen V=10 -fixscreen C=10

-debug_scroll          Turn on debugging info printout for the scroll
                       heuristics.  "-ds" is an alias.  Specify it multiple
                       times for more output.

-noxrecord             Disable any use of the RECORD extension.  This is
                       currently used by the -scrollcopyrect scheme and to
                       monitor X server grabs.

-grab_buster           Some of the use of the RECORD extension can leave a
-nograb_buster         tiny window for XGrabServer deadlock.  This is only if
                       the whole-server grabbing application expects mouse or
                       keyboard input before releasing the grab.  It is usually
                       a window manager that does this.  x11vnc takes care to
                       avoid the the problem, but if caught x11vnc will freeze.
                       Without -grab_buster, the only solution is to go the
                       physical display and give it some input to satisfy the
                       grabbing app.  Or manually kill and restart the window
                       manager if that is feasible.  With -grab_buster, x11vnc
                       will fork a helper thread and if x11vnc appears to be
                       stuck in a grab after a period of time (20-30 sec) then
                       it will inject some user input: button clicks, Escape,
                       mouse motion, etc to try to break the grab.  If you
                       experience a lot of grab deadlock, please report a bug.

-debug_grabs           Turn on debugging info printout with respect to
                       XGrabServer() deadlock for -scrollcopyrect mode.

-debug_sel             Turn on debugging info printout with respect to
                       PRIMARY, CLIPBOARD, and CUTBUFFER0 selections.

-pointer_mode n        Various pointer motion update schemes. "-pm" is
                       an alias.  The problem is pointer motion can cause
                       rapid changes on the screen: consider the rapid
                       changes when you drag a large window around opaquely.
                       Neither x11vnc's screen polling and vnc compression
                       routines nor the bandwidth to the vncviewers can keep
                       up these rapid screen changes: everything will bog down
                       when dragging or scrolling.  So a scheme has to be used
                       to "eat" much of that pointer input before re-polling
                       the screen and sending out framebuffer updates. The
                       mode number "n" can be 0 to 4 and selects one of
                       the schemes desribed below.

                       Note that the -wireframe and -scrollcopyrect modes
                       complement -pointer_mode by detecting (and improving)
                       certain periods of "rapid screen change".

                       n=0: does the same as -nodragging. (all screen polling
                       is suspended if a mouse button is pressed.)

                       n=1: was the original scheme used to about Jan 2004:
                       it basically just skips -input_skip keyboard or pointer
                       events before repolling the screen.

                       n=2 is an improved scheme: by watching the current rate
                       of input events it tries to detect if it should try to
                       "eat" additional pointer events before continuing.

                       n=3 is basically a dynamic -nodragging mode: it detects
                       when the mouse motion has paused and then refreshes
                       the display.

                       n=4 attempts to measures network rates and latency,
                       the video card read rate, and how many tiles have been
                       changed on the screen.  From this, it aggressively tries
                       to push screen "frames" when it decides it has enough
                       resources to do so.  NOT FINISHED.

                       The default n is 2. Note that modes 2, 3, 4 will skip
                       -input_skip keyboard events (but it will not count
                       pointer events).  Also note that these modes are not
                       available in -threads mode which has its own pointer
                       event handling mechanism.

                       To try out the different pointer modes to see which
                       one gives the best response for your usage, it is
                       convenient to use the remote control function, for
                       example "x11vnc -R pm:4" or the tcl/tk gui (Tuning ->
                       pointer_mode -> n).

-input_skip n          For the pointer handling when non-threaded: try to
                       read n user input events before scanning display. n < 0
                       means to act as though there is always user input.
                       Default: 10

-speeds rd,bw,lat      x11vnc tries to estimate some speed parameters that
                       are used to optimize scheduling (e.g. -pointer_mode
                       4, -wireframe, -scrollcopyrect) and other things.
                       Use the -speeds option to set these manually.
                       The triple "rd,bw,lat" corresponds to video h/w
                       read rate in MB/sec, network bandwidth to clients in
                       KB/sec, and network latency to clients in milliseconds,
                       respectively.  If a value is left blank, e.g. "-speeds
                       ,100,15", then the internal scheme is used to estimate
                       the empty value(s).

                       Typical PC video cards have read rates of 5-10 MB/sec.
                       If the framebuffer is in main memory instead of video
                       h/w (e.g. SunRay, shadowfb, dummy driver, Xvfb), the
                       read rate may be much faster.  "x11perf -getimage500"
                       can be used to get a lower bound (remember to factor
                       in the bytes per pixel).  It is up to you to estimate
                       the network bandwith and latency to clients.  For the
                       latency the ping(1) command can be used.

                       For convenience there are some aliases provided,
                       e.g. "-speeds modem".  The aliases are: "modem" for
                       6,4,200; "dsl" for 6,100,50; and "lan" for 6,5000,1

-wmdt string           For some features, e.g. -wireframe and -scrollcopyrect,
                       x11vnc has to work around issues for certain window
                       managers or desktops (currently kde and xfce).
                       By default it tries to guess which one, but it can
                       guess incorrectly.  Use this option to indicate which
                       wm/dt.  "string" can be "gnome", "kde", "cde",
                       "xfce", or "root" (classic X wm).  Anything else
                       is interpreted as "root".

-debug_pointer         Print debugging output for every pointer event.
-debug_keyboard        Print debugging output for every keyboard event.
                       Same as -dp and -dk, respectively.  Use multiple
                       times for more output.

-defer time            Time in ms to wait for updates before sending to client
                       (deferUpdateTime)  Default: 30
-wait time             Time in ms to pause between screen polls.  Used to cut
                       down on load.  Default: 30
-wait_ui factor        Factor by which to cut the -wait time if there
                       has been recent user input (pointer or keyboard).
                       Improves response, but increases the load whenever you
                       are moving the mouse or typing.  Default: 2.00
-nowait_bog            Do not detect if the screen polling is "bogging down"
                       and sleep more.  Some activities with no user input can
                       slow things down a lot: consider a large terminal window
                       with a long build running in it continously streaming
                       text output.  By default x11vnc will try to detect this
                       (3 screen polls in a row each longer than 0.25 sec with
                       no user input), and sleep up to 1.5 secs to let things
                       "catch up".  Use this option to disable that detection.
-slow_fb time          Floating point time in seconds delay all screen polling.
                       For special purpose usage where a low frame rate is
                       acceptable and desirable, but you want the user input
                       processed at the normal rate so you cannot use -wait.
-readtimeout n         Set libvncserver rfbMaxClientWait to n seconds. On
                       slow links that take a long time to paint the first
                       screen libvncserver may hit the timeout and drop the
                       connection.  Default: 20 seconds.
-nap                   Monitor activity and if it is low take longer naps
-nonap                 between screen polls to really cut down load when idle.
                       Default: take naps
-sb time               Time in seconds after NO activity (e.g. screen blank)
                       to really throttle down the screen polls (i.e. sleep
                       for about 1.5 secs). Use 0 to disable.  Default: 60

-nofbpm                If the system supports the FBPM (Frame Buffer Power
-fbpm                  Management) extension (i.e. some Sun systems), then
                       prevent the video h/w from going into a reduced power
                       state when VNC clients are connected.

                       FBPM capable video h/w save energy when the workstation
                       is idle by going into low power states (similar to DPMS
                       for monitors).  This interferes with x11vnc's polling
                       of the framebuffer data.

                       "-nofbpm" means prevent FBPM low power states whenever
                       VNC clients are connected, while "-fbpm" means to not
                       monitor the FBPM state at all.  See the xset(1) manpage
                       for details.  -nofbpm is basically the same as running
                       "xset fbpm force on" periodically.  Default: -fbpm

-noxdamage             Do not use the X DAMAGE extension to detect framebuffer
                       changes even if it is available.  Use -xdamage if your
                       default is to have it off.

                       x11vnc's use of the DAMAGE extension: 1) significantly
                       reduces the load when the screen is not changing much,
                       and 2) detects changed areas (small ones by default)
                       more quickly.

                       Currently the DAMAGE extension is overly conservative
                       and often reports large areas (e.g. a whole terminal
                       or browser window) as damaged even though the actual
                       changed region is much smaller (sometimes just a few
                       pixels).  So heuristics were introduced to skip large
                       areas and use the damage rectangles only as "hints"
                       for the traditional scanline polling.  The following
                       tuning parameters are introduced to adjust this
                       behavior:

-xd_area A             Set the largest DAMAGE rectangle area "A" (in
                       pixels: width * height) to trust as truly damaged:
                       the rectangle will be copied from the framebuffer
                       (slow) no matter what.  Set to zero to trust *all*
                       rectangles. Default: 20000
-xd_mem f              Set how long DAMAGE rectangles should be "remembered",
                       "f" is a floating point number and is in units of the
                       scanline repeat cycle time (32 iterations).  The default
                       (1.0) should give no painting problems. Increase it if
                       there are problems or decrease it to live on the edge
                       (perhaps useful on a slow machine).

-sigpipe string        Broken pipe (SIGPIPE) handling.  "string" can be
                       "ignore" or "exit".  For "ignore" libvncserver
                       will handle the abrupt loss of a client and continue,
                       for "exit" x11vnc will cleanup and exit at the 1st
                       broken connection.  Default: "ignore".  This option
                       is obsolete.
-threads               Whether or not to use the threaded libvncserver
-nothreads             algorithm [rfbRunEventLoop] if libpthread is available
                       Default: -nothreads

-fs f                  If the fraction of changed tiles in a poll is greater
                       than f, the whole screen is updated.  Default: 0.75
-gaps n                Heuristic to fill in gaps in rows or cols of n or
                       less tiles.  Used to improve text paging.  Default: 4
-grow n                Heuristic to grow islands of changed tiles n or wider
                       by checking the tile near the boundary.  Default: 3
-fuzz n                Tolerance in pixels to mark a tiles edges as changed.
                       Default: 2
-debug_tiles           Print debugging output for tiles, fb updates, etc.

-snapfb                Instead of polling the X display framebuffer (fb) for
                       changes, periodically copy all of X display fb into main
                       memory and examine that copy for changes.  Under some
                       circumstances this will improve interactive response,
                       or at least make things look smoother, but in others
                       (most!) it will make the response worse.  If the video
                       h/w fb is such that reading small tiles is very slow
                       this mode could help.  To keep the "framerate" up
                       the screen size x bpp cannot be too large.  Note that
                       this mode is very wasteful of memory I/O resources
                       (it makes full screen copies even if nothing changes).
                       It may be of use in video capture-like applications,
                       or where window tearing is a problem.

-rawfb string          Experimental option, instead of polling X, poll the
                       memory object specified in "string".

                       For shared memory segments string is of the
                       form: "shm:N@WxHxB" which specifies a shmid
                       N and framebuffer Width, Height, and Bits
                       per pixel.  To memory map mmap(2) a file use:
                       "map:/path/to/a/file@WxHxB".  If there is trouble
                       with mmap, use  "file:/..." for slower lseek(2) based
                       reading. Use "snap:..." to imply -snapfb mode and the
                       "file:" access (this is for devices that only provide
                       the fb all at once). If you do not supply a type "map"
                       is assumed if the file exists.

                       If string is "setup:cmd", then the command "cmd"
                       is run and the first line from it is read and used
                       as "string".  This allows initializing the device,
                       determining WxHxB, etc. These are often done as root
                       so take care.

                       If the string begins with "video", see the video4linux
                       discusion below where the device may be queried for
                       (and possibly set) the framebuffer parameters.

                       If the strings begins with "cons", see the linux
                       console discussion below where the framebuffer device
                       is opened and keystrokes are inserted into the console.

                       Optional suffixes are ":R/G/B" and "+O" to specify
                       red, green, and blue masks and an offset into the
                       memory object.  If the masks are not provided x11vnc
                       guesses them based on the bpp.

                       Examples:
                           -rawfb shm:210337933@800x600x32:ff/ff00/ff0000
                           -rawfb map:/dev/fb0@1024x768x32
                           -rawfb map:/tmp/Xvfb_screen0@640x480x8+3232
                           -rawfb file:/tmp/my.pnm@250x200x24+37
                           -rawfb file:/dev/urandom@128x128x8
                           -rawfb snap:/dev/video0@320x240x24 -24to32
                           -rawfb video0
                           -rawfb video -pipeinput VID
                           -rawfb console

                       (see ipcs(1) and fbset(1) for the first two examples)

                       All user input is discarded by default (but see the
                       -pipeinput option).  Most of the X11 (screen, keyboard,
                       mouse) options do not make sense and many will cause
                       this mode to crash, so please think twice before
                       setting or changing them in a running x11vnc.

                       If you DO NOT want x11vnc to close the X DISPLAY in
                       rawfb mode, prepend a "+" e.g. +file:/dev/fb0...
                       Keeping the display open enables the default
                       remote-control channel, which could be useful.
                       Alternatively, if you specify -noviewonly, then the
                       mouse and keyboard input are STILL sent to the X
                       display, this usage should be very rare, i.e. doing
                       something strange with /dev/fb0.

                       If the device is not "seekable" try reading it all
                       at once in full snaps via the "snap:" mode (note:
                       this is a resource hog).  If you are using file: or
                       map: and the device needs to be reopened for *every*
                       snapfb snapshot, set the environment variable:
                       SNAPFB_RAWFB_RESET=1 as well.

                       If you want x11vnc to dynamically transform a 24bpp
                       rawfb to 32bpp (note that this will be slower) use
                       the -24to32 option.  This would be useful for, say,
                       for a video camera that delivers the pixel data as
                       24bpp packed RGB.  This is the default under "video"
                       mode if the bpp is 24.

                       video4linux: on Linux some attempt is made to handle
                       video devices (webcams or TV tuners) automatically.
                       The idea is the WxHxB will be extracted from the
                       device itself.  So if you do not supply "@WxHxB...
                       parameters x11vnc will try to determine them.  It first
                       tries the v4l API if that support has been compiled in.
                       Otherwise it will run the v4l-info(1) external program
                       if it is available.

                       The simplest examples are "-rawfb video" and "-rawfb
                       video1" which imply the device file /dev/video and
                       /dev/video1, respectively.  You can also supply the
                       /dev if you like, e.g. "-rawfb /dev/video0"

                       Since the video capture device framebuffer usually
                       changes continuously (e.g. brightness fluctuations),
                       you may want to use the -wait, -slow_fb, or -defer
                       options to lower the "framerate" to cut down on
                       network VNC traffic.

                       A more sophisticated video device scheme allows
                       initializing the device's settings using:

                           -rawfb video:<settings>

                       The prefix could also be, as above, e.g. "video1:" to
                       specify the device file.  The v4l API must be available
                       for this to work.  Otherwise, you will need to try
                       to initialize the device with an external program,
                       e.g. xawtv, spcaview, and hope they persist when x11vnc
                       re-opens the device.

                       <settings> is a comma separated list of key=value pairs.
                       The device's brightness, color, contrast, and hue can
                       be set to percentages, e.g. br=80,co=50,cn=44,hu=60.

                       The device filename can be set too if needed (if it
                       does not start with "video"), e.g. fn=/dev/qcam.

                       The width, height and bpp of the framebuffer can be
                       set via, e.g., w=160,h=120,bpp=16.

                       Related to the bpp above, the pixel format can be set
                       via the fmt=XXX, where XXX can be one of: GREY, HI240,
                       RGB555, RGB565, RGB24, and RGB32 (with bpp 8, 8, 16, 16,
                       24, and 32 respectively).  See http://www.linuxtv.org
                       for more info (V4L api).

                       For TV/rf tuner cards one can set the tuning mode
                       via tun=XXX where XXX can be one of PAL, NTSC, SECAM,
                       or AUTO.

                       One can switch the input channel by the inp=XXX setting,
                       where XXX is the name of the input channel (Television,
                       Composite1, S-Video, etc).  Use the name that is in the
                       information about the device that is printed at startup.

                       For input channels with tuners (e.g. Television) one
                       can change which station is selected by the sta=XXX
                       setting.  XXX is the station number.  Currently only
                       the ntsc-cable-us (US cable) channels are built into
                       x11vnc.  See the -freqtab option below to supply one
                       from xawtv. If XXX is greater than 500, then it is
                       interpreted as a raw frequency in KHz.

                       Example:

                       -rawfb video:br=80,w=320,h=240,fmt=RGB32,tun=NTSC,sta=47

                       one might need to add inp=Television too for the input
                       channel to be TV if the card doesn't come up by default
                       in that one.

                       Note that not all video capture devices will support
                       all of the above settings.

                       See the -pipeinput VID option below for a way to control
                       the settings through the VNC Viewer via keystrokes.

                       As above, if you specify a "@WxHxB..." after the
                       <settings> string they are used verbatim: the device
                       is not queried for the current values.  Otherwise the
                       device will be queried.

                       Linux console:  If the libvncserver LinuxVNC command is
                       on your system use that instead of the following method
                       because it will be faster and more accurate for Linux
                       text console.

                       If the rawfb string begins with "cons" the framebuffer
                       device /dev/fb0 is opened (this requires the appropriate
                       kernel modules) and so is /dev/tty0.  The latter is
                       used to inject keystrokes (not all are supported,
                       but the basic ones are).  You will need to be root to
                       inject keystrokes.  /dev/tty0 refers to the active VT,
                       to indicate one explicitly, use "cons2", etc. using
                       the VT number.  Note you can change VT remotely using
                       the chvt(1) command.  Sometimes switching out and back
                       corrects the framebuffer.  To skip injecting entirely
                       use "consx".

                       The strings "console", or "/dev/fb0" can be used
                       instead of "cons".  The latter can be used to specify
                       a different framebuffer device, e.g. /dev/fb1.  If the
                       name is something nonstandard, use "cons:/dev/foofb"

                       If you do not want x11vnc to guess the framebuffer's
                       WxHxB and masks automatically, specify them with a
                       @WxHxB at the end of the string.

                       Examples:
                           -rawfb cons               (same as -rawfb console)
                           -rawfb /dev/fb0           (same)
                           -rawfb cons3              (force /dev/tty3)
                           -rawfb consx              (no keystrokes)
                           -rawfb console:/dev/nonstd

-freqtab file          For use with "-rawfb video" for TV tuner devices to
                       specify station frequencies.  Instead of using the built
                       in ntsc-cable-us mapping of station number to frequency,
                       use the data in file.  For stations that are not
                       numeric, e.g. SE20, they are placed above the highest
                       numbered station in the order they are found.  Example:
                       "-freqtab /usr/X11R6/share/xawtv/europe-west.list"
                       You can make your own freqtab by copying the xawtv
                       format.

-pipeinput cmd         Another experimental option: it lets you supply an
                       external command in "cmd" that x11vnc will pipe
                       all of the user input events to in a simple format.
                       In -pipeinput mode by default x11vnc will not process
                       any of the user input events.  If you prefix "cmd"
                       with "tee:" it will both send them to the pipe
                       command and process them.  For a description of the
                       format run "-pipeinput tee:/bin/cat".  Another prefix
                       is "reopen" which means to reopen pipe if it exits.
                       Separate multiple prefixes with commas.

                       In combination with -rawfb one might be able to
                       do amusing things (e.g. control non-X devices).
                       To facilitate this, if -rawfb is in effect then the
                       value is stored in X11VNC_RAWFB_STR for the pipe command
                       to use if it wants. Do 'env | grep X11VNC' for more.

                       If cmd is "VID" and you are using the -rawfb for a
                       video capture device, then an internal list of keyboard
                       mappings is used to set parameters of the video.
                       The mappings are:

                         "B" and "b" adjust the brightness up and down.
                         "H" and "h" adjust the hue.
                         "C" and "c" adjust the colour.
                         "N" and "n" adjust the contrast.
                         "S" and "s" adjust the size of the capture screen.
                         "I" and "i" cycle through input channels.
                         Up and Down arrows adjust the station (if a tuner)
                         F1, F2, ..., F6 will switch the video capture pixel
                         format to HI240, RGB565, RGB24, RGB32, RGB555, and
                         GREY respectively.  See -rawfb video for details.

                       If cmd is "CONS" or "CONSn" where n is a Linux
                       console number, then the linux console keystroke
                       insertion (see -rawfb cons) is performed.

-gui [gui-opts]        Start up a simple tcl/tk gui based on the the remote
                       control options -remote/-query described below.
                       Requires the "wish" program to be installed on the
                       machine.  "gui-opts" is not required: the default
                       is to start up both the full gui and x11vnc with the
                       gui showing up on the X display in the environment
                       variable DISPLAY.

                       "gui-opts" can be a comma separated list of items.
                       Currently there are these types of items: 1) a gui
                       mode, a 2) gui "simplicity", 3) the X display the
                       gui should display on, 4) a "tray" or "icon" mode,
                       and 5) a gui geometry.

                       1) The gui mode can be "start", "conn", or "wait"
                       "start" is the default mode above and is not required.
                       "conn" means do not automatically start up x11vnc,
                       but instead just try to connect to an existing x11vnc
                       process.  "wait" means just start the gui and nothing
                       else (you will later instruct the gui to start x11vnc
                       or connect to an existing one.)

                       2) The gui simplicity is off by default (a power-user
                       gui with all options is presented) To start with
                       something less daunting supply the string "simple"
                       ("ez" is an alias for this).  Once the gui is
                       started you can toggle between the two with "Misc ->
                       simple_gui".

                       3) Note the possible confusion regarding the potentially
                       two different X displays: x11vnc polls one, but you
                       may want the gui to appear on another.  For example, if
                       you ssh in and x11vnc is not running yet you may want
                       the gui to come back to you via your ssh redirected X
                       display (e.g. localhost:10).

                       If you do not specify a gui X display in "gui-opts"
                       then the DISPLAY environment variable and -display
                       option are tried (in that order).  Regarding the x11vnc
                       X display the gui will try to communication with, it
                       first tries -display and then DISPLAY.  For example,
                       "x11vnc -display :0 -gui otherhost:0", will remote
                       control an x11vnc polling :0 and display the gui on
                       otherhost:0 The "tray/icon" mode below reverses this
                       preference, preferring to display on the x11vnc display.

                       4) When "tray" or "icon" is specified, the gui
                       presents itself as a small icon with behavior typical
                       of a "system tray" or "dock applet".  The color
                       of the icon indicates status (connected clients) and
                       there is also a balloon status.  Clicking on the icon
                       gives a menu from which properties, etc, can be set and
                       the full gui is available under "Advanced".  To be
                       fully functional, the gui mode should be "start"
                       (the default).

                       For "icon" the gui just a small standalone window.
                       For "tray" it will attempt to embed itself in the
                       "system tray" if possible. If "=setpass" is appended the
n
                       at startup the X11 user will be prompted to set the
                       VNC session password.  If =<hexnumber> is appended
                       that icon will attempt to embed itself in the window
                       given by hexnumber.  Use =noadvanced to disable the
                       full gui. (To supply more than one, use "+" sign).
                       E.g. -gui tray=setpass and -gui icon=0x3600028

                       Other modes: "full", the default and need not be
                       specified.  "-gui none", do not show a gui, useful
                       to override a ~/.x11vncrc setting, etc.

                       5) When "geom=+X+Y" is specified, that geometry
                       is passed to the gui toplevel.  This is the icon in
                       icon/tray mode, or the full gui otherwise.  You can
                       also specify width and height, i.e. WxH+X+Y, but it
                       is not recommended.  In "tray" mode the geometry is
                       ignored unless the system tray manager does not seem
                       to be running.  One could imagine using something like
                       "-gui tray,geom=+4000+4000" with a display manager
                       to keep the gui invisible until someone logs in...

                       More icon tricks, "icon=minimal" gives an icon just
                       with the VNC display number.  You can also set the font
                       with "iconfont=...".  The following could be useful:
                       "-gui icon=minimal,iconfont=5x8,geom=24x10+0-0"

                       General examples of the -gui option: "x11vnc -gui",
                       "x11vnc -gui ez" "x11vnc -gui localhost:10",
                       "x11vnc -gui conn,host:0", "x11vnc -gui tray,ez"
                       "x11vnc -gui tray=setpass"

                       If you do not intend to start x11vnc from the gui
                       (i.e. just remote control an existing one), then the
                       gui process can run on a different machine from the
                       x11vnc server as long as X permissions, etc. permit
                       communication between the two.

-remote command        Remotely control some aspects of an already running
                       x11vnc server.  "-R" and "-r" are aliases for
                       "-remote".  After the remote control command is
                       sent to the running server the 'x11vnc -remote ...'
                       command exits.  You can often use the -query command
                       (see below) to see if the x11vnc server processed your
                       -remote command.

                       The default communication channel is that of X
                       properties (specifically X11VNC_REMOTE), and so this
                       command must be run with correct settings for DISPLAY
                       and possibly XAUTHORITY to connect to the X server
                       and set the property.  Alternatively, use the -display
                       and -auth options to set them to the correct values.
                       The running server cannot use the -novncconnect option
                       because that disables the communication channel.
                       See below for alternate channels.

                       For example: 'x11vnc -remote stop' (which is the same as
                       'x11vnc -R stop') will close down the x11vnc server.
                       'x11vnc -R shared' will enable shared connections, and
                       'x11vnc -R scale:3/4' will rescale the desktop.

                       The following -remote/-R commands are supported:

                       stop            terminate the server, same as "quit"
                                       "exit" or "shutdown".
                       ping            see if the x11vnc server responds.
                                       Return is: ans=ping:<xdisplay>
                       blacken         try to push a black fb update to all
                                       clients (due to timings a client
                                       could miss it). Same as "zero", also
                                       "zero:x1,y1,x2,y2" for a rectangle.
                       refresh         send the entire fb to all clients.
                       reset           recreate the fb, polling memory, etc.
                       id:windowid     set -id window to "windowid". empty
                                       or "root" to go back to root window
                       sid:windowid    set -sid window to "windowid"
                       waitmapped      wait until subwin is mapped.
                       nowaitmapped    do not wait until subwin is mapped.
                       clip:WxH+X+Y    set -clip mode to "WxH+X+Y"
                       flashcmap       enable  -flashcmap mode.
                       noflashcmap     disable -flashcmap mode.
                       shiftcmap:n     set -shiftcmap to n.
                       notruecolor     enable  -notruecolor mode.
                       truecolor       disable -notruecolor mode.
                       overlay         enable  -overlay mode (if applicable).
                       nooverlay       disable -overlay mode.
                       overlay_cursor  in -overlay mode, enable cursor drawing.
                       overlay_nocursor disable cursor drawing. same as
                                        nooverlay_cursor.
                       8to24           enable  -8to24 mode (if applicable).
                       no8to24         disable -8to24 mode.
                       8to24_opts:str  set the -8to24 opts to "str".
                       24to32          enable  -24to32 mode (if applicable).
                       no24to32        disable -24to32 mode.
                       visual:vis      set -visual to "vis"
                       scale:frac      set -scale to "frac"
                       scale_cursor:f  set -scale_cursor to "f"
                       viewonly        enable  -viewonly mode.
                       noviewonly      disable -viewonly mode.
                       shared          enable  -shared mode.
                       noshared        disable -shared mode.
                       forever         enable  -forever mode.
                       noforever       disable -forever mode.
                       timeout:n       reset -timeout to n, if there are
                                       currently no clients, exit unless one
                                       connects in the next n secs.
                       filexfer        enable  filetransfer for new clients.
                       nofilexfer      disable filetransfer for new clients.
                       http            enable  http client connections.
                       nohttp          disable http client connections.
                       deny            deny any new connections, same as "lock"
                       nodeny          allow new connections, same as "unlock"
                       connect:host    do reverse connection to host, "host"
                                       may be a comma separated list of hosts
                                       or host:ports.  See -connect.  Passwords
                                       required as with fwd connections.
                                       See X11VNC_REVERSE_CONNECTION_NO_AUTH=1
                       disconnect:host disconnect any clients from "host"
                                       same as "close:host".  Use host
                                       "all" to close all current clients.
                                       If you know the client internal hex ID,
                                       e.g. 0x3 (returned by "-query clients"
                                       and RFB_CLIENT_ID) you can use that too.
                       allowonce:host  For the next connection only, allow
                                       connection from "host".
                       allow:hostlist  set -allow list to (comma separated)
                                       "hostlist". See -allow and -localhost.
                                       Do not use with -allow /path/to/file
                                       Use "+host" to add a single host, and
                                       use "-host" to delete a single host
                       localhost       enable  -localhost mode
                       nolocalhost     disable -localhost mode
                       listen:str      set -listen to str, empty to disable.
                       nolookup        enable  -nolookup mode.
                       lookup          disable -nolookup mode.
                       input:str       set -input to "str", empty to disable.
                       grabkbd         enable  -grabkbd mode.
                       nograbkbd       disable -grabkbd mode.
                       grabptr         enable  -grabptr mode.
                       nograbptr       disable -grabptr mode.
                       client_input:str set the K, M, B -input on a per-client
                                       basis.  select which client as for
                                       disconnect, e.g. client_input:host:MB
                                       or client_input:0x2:K
                       accept:cmd      set -accept "cmd" (empty to disable).
                       afteraccept:cmd set -afteraccept (empty to disable).
                       gone:cmd        set -gone "cmd" (empty to disable).
                       noshm           enable  -noshm mode.
                       shm             disable -noshm mode (i.e. use shm).
                       flipbyteorder   enable -flipbyteorder mode, you may need
                                       to set noshm for this to do something.
                       noflipbyteorder disable -flipbyteorder mode.
                       onetile         enable  -onetile mode. (you may need to
                                       set shm for this to do something)
                       noonetile       disable -onetile mode.
                       solid           enable  -solid mode
                       nosolid         disable -solid mode.
                       solid_color:color set -solid color (and apply it).
                       blackout:str    set -blackout "str" (empty to disable).
                                       See -blackout for the form of "str"
                                       (basically: WxH+X+Y,...)
                                       Use "+WxH+X+Y" to append a single
                                       rectangle use "-WxH+X+Y" to delete one
                       xinerama        enable  -xinerama mode. (if applicable)
                       noxinerama      disable -xinerama mode.
                       xtrap           enable  -xtrap input mode(if applicable)
                       noxtrap         disable -xtrap input mode.
                       xrandr          enable  -xrandr mode. (if applicable)
                       noxrandr        disable -xrandr mode.
                       xrandr_mode:mode set the -xrandr mode to "mode".
                       padgeom:WxH     set -padgeom to WxH (empty to disable)
                                       If WxH is "force" or "do" the padded
                                       geometry fb is immediately applied.
                       quiet           enable  -quiet mode.
                       noquiet         disable -quiet mode.
                       modtweak        enable  -modtweak mode.
                       nomodtweak      enable  -nomodtweak mode.
                       xkb             enable  -xkb modtweak mode.
                       noxkb           disable -xkb modtweak mode.
                       capslock        enable  -capslock mode.
                       nocapslock      disable -capslock mode.
                       skip_lockkeys   enable  -skip_lockkeys mode.
                       noskip_lockkeys disable -skip_lockkeys mode.
                       skip_keycodes:str enable -xkb -skip_keycodes "str".
                       sloppy_keys     enable  -sloppy_keys mode.
                       nosloppy_keys   disable -sloppy_keys mode.
                       skip_dups       enable  -skip_dups mode.
                       noskip_dups     disable -skip_dups mode.
                       add_keysyms     enable -add_keysyms mode.
                       noadd_keysyms   stop adding keysyms. those added will
                                       still be removed at exit.
                       clear_mods      enable  -clear_mods mode and clear them.
                       noclear_mods    disable -clear_mods mode.
                       clear_keys      enable  -clear_keys mode and clear them.
                       noclear_keys    disable -clear_keys mode.
                       remap:str       set -remap "str" (empty to disable).
                                       See -remap for the form of "str"
                                       (basically: key1-key2,key3-key4,...)
                                       Use "+key1-key2" to append a single
                                       keymapping, use "-key1-key2" to delete.
                       norepeat        enable  -norepeat mode.
                       repeat          disable -norepeat mode.
                       nofb            enable  -nofb mode.
                       fb              disable -nofb mode.
                       bell            enable  bell (if supported).
                       nobell          disable bell.
                       nosel           enable  -nosel mode.
                       sel             disable -nosel mode.
                       noprimary       enable  -noprimary mode.
                       primary         disable -noprimary mode.
                       nosetprimary    enable  -nosetprimary mode.
                       setprimary      disable -nosetprimary mode.
                       noclipboard     enable  -noclipboard mode.
                       clipboard       disable -noclipboard mode.
                       nosetclipboard  enable  -nosetclipboard mode.
                       setclipboard    disable -nosetclipboard mode.
                       seldir:str      set -seldir to "str"
                       cursor:mode     enable  -cursor "mode".
                       show_cursor     enable  showing a cursor.
                       noshow_cursor   disable showing a cursor. (same as
                                       "nocursor")
                       arrow:n         set -arrow to alternate n.
                       xfixes          enable  xfixes cursor shape mode.
                       noxfixes        disable xfixes cursor shape mode.
                       alphacut:n      set -alphacut to n.
                       alphafrac:f     set -alphafrac to f.
                       alpharemove     enable  -alpharemove mode.
                       noalpharemove   disable -alpharemove mode.
                       alphablend      disable -noalphablend mode.
                       noalphablend    enable  -noalphablend mode.
                       cursorshape     disable -nocursorshape mode.
                       nocursorshape   enable  -nocursorshape mode.
                       cursorpos       disable -nocursorpos mode.
                       nocursorpos     enable  -nocursorpos mode.
                       xwarp           enable  -xwarppointer mode.
                       noxwarp         disable -xwarppointer mode.
                       buttonmap:str   set -buttonmap "str", empty to disable
                       dragging        disable -nodragging mode.
                       nodragging      enable  -nodragging mode.
                       wireframe       enable  -wireframe mode. same as "wf"
                       nowireframe     disable -wireframe mode. same as "nowf"
                       wireframe:str   enable  -wireframe mode string.
                       wireframe_mode:str enable  -wireframe mode string.
                       wirecopyrect:str set -wirecopyrect string. same as "wcr:
"
                       scrollcopyrect:str set -scrollcopyrect string. same "scr
"
                       noscrollcopyrect disable -scrollcopyrect mode. "noscr"
                       scr_area:n      set -scr_area to n
                       scr_skip:list   set -scr_skip to "list"
                       scr_inc:list    set -scr_inc to "list"
                       scr_keys:list   set -scr_keys to "list"
                       scr_term:list   set -scr_term to "list"
                       scr_keyrepeat:str set -scr_keyrepeat to "str"
                       scr_parms:str   set -scr_parms parameters.
                       fixscreen:str   set -fixscreen to "str".
                       noxrecord       disable all use of RECORD extension.
                       xrecord         enable  use of RECORD extension.
                       reset_record    reset RECORD extension (if avail.)
                       pointer_mode:n  set -pointer_mode to n. same as "pm"
                       input_skip:n    set -input_skip to n.
                       speeds:str      set -speeds to str.
                       wmdt:str        set -wmdt to str.
                       debug_pointer   enable  -debug_pointer, same as "dp"
                       nodebug_pointer disable -debug_pointer, same as "nodp"
                       debug_keyboard   enable  -debug_keyboard, same as "dk"
                       nodebug_keyboard disable -debug_keyboard, same as "nodk"
                       defer:n         set -defer to n ms,same as deferupdate:n
                       wait:n          set -wait to n ms.
                       wait_ui:f       set -wait_ui factor to f.
                       wait_bog        disable -nowait_bog mode.
                       nowait_bog      enable  -nowait_bog mode.
                       slow_fb:f       set -slow_fb to f seconds.
                       readtimeout:n   set read timeout to n seconds.
                       nap             enable  -nap mode.
                       nonap           disable -nap mode.
                       sb:n            set -sb to n s, same as screen_blank:n
                       fbpm            disable -nofbpm mode.
                       nofbpm          enable  -nofbpm mode.
                       xdamage         enable  xdamage polling hints.
                       noxdamage       disable xdamage polling hints.
                       xd_area:A       set -xd_area max pixel area to "A"
                       xd_mem:f        set -xd_mem remembrance to "f"
                       fs:frac         set -fs fraction to "frac", e.g. 0.5
                       gaps:n          set -gaps to n.
                       grow:n          set -grow to n.
                       fuzz:n          set -fuzz to n.
                       snapfb          enable  -snapfb mode.
                       nosnapfb        disable -snapfb mode.
                       rawfb:str       set -rawfb mode to "str".
                       progressive:n   set libvncserver -progressive slice
                                       height parameter to n.
                       desktop:str     set -desktop name to str for new clients
.
                       rfbport:n       set -rfbport to n.
                       httpport:n      set -httpport to n.
                       httpdir:dir     set -httpdir to dir (and enable http).
                       enablehttpproxy   enable  -enablehttpproxy mode.
                       noenablehttpproxy disable -enablehttpproxy mode.
                       alwaysshared     enable  -alwaysshared mode.
                       noalwaysshared   disable -alwaysshared mode.
                                        (may interfere with other options)
                       nevershared      enable  -nevershared mode.
                       nonevershared    disable -nevershared mode.
                                        (may interfere with other options)
                       dontdisconnect   enable  -dontdisconnect mode.
                       nodontdisconnect disable -dontdisconnect mode.
                                        (may interfere with other options)
                       debug_xevents   enable  debugging X events.
                       nodebug_xevents disable debugging X events.
                       debug_xdamage   enable  debugging X DAMAGE mechanism.
                       nodebug_xdamage disable debugging X DAMAGE mechanism.
                       debug_wireframe enable   debugging wireframe mechanism.
                       nodebug_wireframe disable debugging wireframe mechanism.
                       debug_scroll    enable  debugging scrollcopy mechanism.
                       nodebug_scroll  disable debugging scrollcopy mechanism.
                       debug_tiles     enable  -debug_tiles
                       nodebug_tiles   disable -debug_tiles
                       debug_grabs     enable  -debug_grabs
                       nodebug_grabs   disable -debug_grabs
                       debug_sel       enable  -debug_sel
                       nodebug_sel     disable -debug_sel
                       dbg             enable  -dbg crash shell
                       nodbg           disable -dbg crash shell

                       noremote        disable the -remote command processing,
                                       it cannot be turned back on.

                       The vncconnect(1) command from standard VNC
                       distributions may also be used if string is prefixed
                       with "cmd=" E.g. 'vncconnect cmd=stop'.  Under some
                       circumstances xprop(1) can used if it supports -set
                       (see the FAQ).

                       If "-connect /path/to/file" has been supplied to the
                       running x11vnc server then that file can be used as a
                       communication channel (this is the only way to remote
                       control one of many x11vnc's polling the same X display)
                       Simply run: 'x11vnc -connect /path/to/file -remote ...'
                       or you can directly write to the file via something
                       like: "echo cmd=stop > /path/to/file", etc.

-query variable        Like -remote, except just query the value of
                       "variable".  "-Q" is an alias for "-query".
                       Multiple queries can be done by separating variables
                       by commas, e.g. -query var1,var2. The results come
                       back in the form ans=var1:value1,ans=var2:value2,...
                       to the standard output.  If a variable is read-only,
                       it comes back with prefix "aro=" instead of "ans=".

                       Some -remote commands are pure actions that do not make
                       sense as variables, e.g. "stop" or "disconnect", in
                       these cases the value returned is "N/A".  To direct a
                       query straight to the X11VNC_REMOTE property or connect
                       file use "qry=..." instead of "cmd=..."

                       Here is the current list of "variables" that can
                       be supplied to the -query command. This includes the
                       "N/A" ones that return no useful info.  For variables
                       names that do not correspond to an x11vnc option or
                       remote command, we hope the name makes it obvious what
                       the returned value corresponds to (hint: the ext_*
                       variables correspond to the presence of X extensions):

                       ans= stop quit exit shutdown ping blacken zero
                       refresh reset close disconnect id sid waitmapped
                       nowaitmapped clip flashcmap noflashcmap shiftcmap
                       truecolor notruecolor overlay nooverlay overlay_cursor
                       overlay_yescursor nooverlay_nocursor nooverlay_cursor
                       nooverlay_yescursor overlay_nocursor 8to24 no8to24
                       8to24_opts 24to32 no24to32 visual scale scale_cursor
                       viewonly noviewonly shared noshared forever noforever
                       once timeout filexfer nofilexfer deny lock nodeny
                       unlock connect allowonce allow localhost nolocalhost
                       listen lookup nolookup accept afteraccept gone shm
                       noshm flipbyteorder noflipbyteorder onetile noonetile
                       solid_color solid nosolid blackout xinerama noxinerama
                       xtrap noxtrap xrandr noxrandr xrandr_mode padgeom
                       quiet q noquiet modtweak nomodtweak xkb noxkb capslock
                       nocapslock skip_lockkeys noskip_lockkeys skip_keycodes
                       sloppy_keys nosloppy_keys skip_dups noskip_dups
                       add_keysyms noadd_keysyms clear_mods noclear_mods
                       clear_keys noclear_keys remap repeat norepeat fb nofb
                       bell nobell sel nosel primary noprimary setprimary
                       nosetprimary clipboard noclipboard setclipboard
                       nosetclipboard seldir cursorshape nocursorshape
                       cursorpos nocursorpos cursor show_cursor noshow_cursor
                       nocursor arrow xfixes noxfixes xdamage noxdamage
                       xd_area xd_mem alphacut alphafrac alpharemove
                       noalpharemove alphablend noalphablend xwarppointer
                       xwarp noxwarppointer noxwarp buttonmap dragging
                       nodragging wireframe_mode wireframe wf nowireframe
                       nowf wirecopyrect wcr nowirecopyrect nowcr scr_area
                       scr_skip scr_inc scr_keys scr_term scr_keyrepeat
                       scr_parms scrollcopyrect scr noscrollcopyrect noscr
                       fixscreen noxrecord xrecord reset_record pointer_mode
                       pm input_skip input grabkbd nograbkbd grabptr
                       nograbptr client_input speeds wmdt debug_pointer dp
                       nodebug_pointer nodp debug_keyboard dk nodebug_keyboard
                       nodk deferupdate defer wait_ui wait_bog nowait_bog
                       slow_fb wait readtimeout nap nonap sb screen_blank
                       fbpm nofbpm fs gaps grow fuzz snapfb nosnapfb rawfb
                       progressive rfbport http nohttp httpport httpdir
                       enablehttpproxy noenablehttpproxy alwaysshared
                       noalwaysshared nevershared noalwaysshared dontdisconnect
                       nodontdisconnect desktop debug_xevents nodebug_xevents
                       debug_xevents debug_xdamage nodebug_xdamage
                       debug_xdamage debug_wireframe nodebug_wireframe
                       debug_wireframe debug_scroll nodebug_scroll debug_scroll
                       debug_tiles dbt nodebug_tiles nodbt debug_tiles
                       debug_grabs nodebug_grabs debug_sel nodebug_sel dbg
                       nodbg noremote

                       aro=  noop display vncdisplay desktopname guess_desktop
                       http_url auth xauth users rootshift clipshift
                       scale_str scaled_x scaled_y scale_numer scale_denom
                       scale_fac scaling_blend scaling_nomult4 scaling_pad
                       scaling_interpolate inetd privremote unsafe safer nocmds
                       passwdfile unixpw unixpw_nis unixpw_list ssl ssl_pem
                       sslverify stunnel stunnel_pem https usepw using_shm
                       logfile o flag rc norc h help V version lastmod bg
                       sigpipe threads readrate netrate netlatency pipeinput
                       clients client_count pid ext_xtest ext_xtrap ext_xrecord
                       ext_xkb ext_xshm ext_xinerama ext_overlay ext_xfixes
                       ext_xdamage ext_xrandr rootwin num_buttons button_mask
                       mouse_x mouse_y bpp depth indexed_color dpy_x dpy_y
                       wdpy_x wdpy_y off_x off_y cdpy_x cdpy_y coff_x coff_y
                       rfbauth passwd viewpasswd

-QD variable           Just like -query variable, but returns the default
                       value for that parameter (no running x11vnc server
                       is consulted)

-sync                  By default -remote commands are run asynchronously, that
                       is, the request is posted and the program immediately
                       exits.  Use -sync to have the program wait for an
                       acknowledgement from the x11vnc server that command was
                       processed (somehow).  On the other hand -query requests
                       are always processed synchronously because they have
                       to wait for the answer.

                       Also note that if both -remote and -query requests are
                       supplied on the command line, the -remote is processed
                       first (synchronously: no need for -sync), and then
                       the -query request is processed in the normal way.
                       This allows for a reliable way to see if the -remote
                       command was processed by querying for any new settings.
                       Note however that there is timeout of a few seconds so
                       if the x11vnc takes longer than that to process the
                       requests the requestor will think that a failure has
                       taken place.

-noremote              Do not process any remote control commands or queries.
-yesremote             Do process remote control commands or queries.
                       Default: -yesremote

                       A note about security wrt remote control commands.
                       If someone can connect to the X display and change
                       the property X11VNC_REMOTE, then they can remotely
                       control x11vnc.  Normally access to the X display is
                       protected.  Note that if they can modify X11VNC_REMOTE
                       on the X server, they have enough permissions to also
                       run their own x11vnc and thus have complete control
                       of the desktop.  If the  "-connect /path/to/file"
                       channel is being used, obviously anyone who can write
                       to /path/to/file can remotely control x11vnc.  So be
                       sure to protect the X display and that file's write
                       permissions.  See -privremote below.

                       If you are paranoid and do not think -noremote is
                       enough, to disable the X11VNC_REMOTE property channel
                       completely use -novncconnect, or use the -safer option
                       that shuts many things off.

-unsafe                A few remote commands are disabled by default
                       (currently: id:pick, accept:<cmd>, gone:<cmd>, and
                       rawfb:setup:<cmd>) because they are associated with
                       running external programs.  If you specify -unsafe, then
                       these remote-control commands are allowed.  Note that
                       you can still specify these parameters on the command
                       line, they just cannot be invoked via remote-control.
-safer                 Equivalent to: -novncconnect -noremote and prohibiting
                       -gui and the -connect file. Shuts off communcation
                       channels.
-privremote            Perform some sanity checks and disable remote-control
                       commands if it appears that the X DISPLAY and/or
                       connectfile can be accessed by other users.  Once
                       remote-control is disabled it cannot be turned back on.
-nocmds                No external commands (e.g. system(3), popen(3), exec(3))
                       will be run.
-allowedcmds list      "list" contains a comma separated list of the only
                       external commands that can be run.  The full list of
                       associated options is:

                        stunnel, ssl, unixpw, WAIT, id, accept, afteraccept,
                        gone, pipeinput, v4l-info, rawfb-setup, dt, gui,
                        storepasswd, crash.

                       See each option's help to learn the associated external
                       command.  Note that the -nocmds option takes precedence
                       and disables all external commands.

-deny_all              For use with -remote nodeny: start out denying all
                       incoming clients until "-remote nodeny" is used to
                       let them in.


These options are passed to libvncserver:

-rfbport port          TCP port for RFB protocol
-rfbwait time          max time in ms to wait for RFB client
-rfbauth passwd-file   use authentication on RFB protocol
                       (use 'storepasswd' to create a password file)
-rfbversion 3.x        Set the version of the RFB we choose to advertise
-permitfiletransfer    permit file transfer support
-passwd plain-password use authentication
                       (use plain-password as password, USE AT YOUR RISK)
-deferupdate time      time in ms to defer updates (default 40)
-deferptrupdate time   time in ms to defer pointer updates (default none)
-desktop name          VNC desktop name (default "LibVNCServer")
-alwaysshared          always treat new clients as shared
-nevershared           never treat new clients as shared
-dontdisconnect        don't disconnect existing clients when a new non-shared
                       connection comes in (refuse new connection instead)
-httpdir dir-path      enable http server using dir-path home
-httpport portnum      use portnum for http connection
-enablehttpproxy       enable http proxy support
-progressive height    enable progressive updating for slow links
-listen ipaddr         listen for connections only on network interface with
                       addr ipaddr. '-listen localhost' and hostname work too.

libvncserver-tight-extension options:
-disablefiletransfer   disable file transfer
-ftproot string        set ftp root

   Pretty wild huh? [1]Contact me if you have any questions or problems.

   Personally, I use:
x11vnc -rfbauth $HOME/.vnc/passwd -solid

References

   1. mailto:xvml@karlrunge.com
